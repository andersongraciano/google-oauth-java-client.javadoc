<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Mon Oct 17 10:17:18 PDT 2011 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="Google API Client Library for Java 1.4.1-beta"
  jdversion="1.1.1">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath /home/rmistry/jdiff-1.1.1/jdiff.jar:/home/rmistry/jdiff-1.1.1/xerces.jar -d /home/rmistry/apiary/releases/javadoc/1.5.1-beta/jdiff -classpath /usr/share/ant/lib/ant-launcher.jar:/usr/share/java/xmlParserAPIs.jar:/usr/share/java/xercesImpl.jar:/usr/share/ant/lib/ant-apache-bcel.jar:/usr/share/ant/lib/ant-apache-oro.jar:/usr/share/ant/lib/ant.jar:/usr/share/ant/lib/ant-antlr.jar:/usr/share/ant/lib/ant-swing.jar:/usr/share/ant/lib/ant-apache-bsf.jar:/usr/share/ant/lib/ant-jmf.jar:/usr/share/ant/lib/ant-jdepend.jar:/usr/share/ant/lib/ant-junit.jar:/usr/share/ant/lib/ant-nodeps.jar:/usr/share/ant/lib/ant-javamail.jar:/usr/share/ant/lib/ant-apache-regexp.jar:/usr/share/ant/lib/ant-apache-log4j.jar:/usr/share/ant/lib/ant-commons-logging.jar:/usr/share/ant/lib/ant-jsch.jar:/usr/share/ant/lib/ant-apache-resolver.jar:/usr/share/ant/lib/ant-commons-net.jar:/usr/share/ant/lib/ant-trax.jar:/usr/local/buildtools/java/jdk6-google-v4/lib/tools.jar -sourcepath /home/rmistry/apiary/releases/1.4.1-beta/google-api-client/src/main/java:/home/rmistry/apiary/releases/1.4.1-beta/google-api-client-extensions/src/main/java -apiname Google API Client Library for Java 1.4.1-beta -baseURI http://www.w3.org -apidir /home/rmistry/apiary/releases/javadoc/1.5.1-beta/jdiff -source 1.5 -->
<package name="com.google.api.client.auth">
  <!-- start class com.google.api.client.auth.HmacSha -->
  <class name="HmacSha" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="sign" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="data" type="java.lang.String"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
      <doc>
      <![CDATA[Signs the given data using the given secret key.

 @throws GeneralSecurityException general security exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility methods for {@code "HMAC-SHA1"} signing method.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.HmacSha -->
  <!-- start class com.google.api.client.auth.RsaSha -->
  <class name="RsaSha" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getPrivateKeyFromKeystore" return="java.security.PrivateKey"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyStream" type="java.io.InputStream"/>
      <param name="storePass" type="java.lang.String"/>
      <param name="alias" type="java.lang.String"/>
      <param name="keyPass" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
      <doc>
      <![CDATA[Retrieves the private key from the specified key store.

 @param keyStream input stream to the key store file
 @param storePass password protecting the key store file
 @param alias alias under which the private key is stored
 @param keyPass password protecting the private key
 @return the private key from the specified key store
 @throws GeneralSecurityException if the key store cannot be loaded
 @throws IOException if the file cannot be accessed]]>
      </doc>
    </method>
    <method name="getPrivateKeyFromPk8" return="java.security.PrivateKey"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
      <doc>
      <![CDATA[Reads a {@code PKCS#8} format private key from a given file.

 @throws NoSuchAlgorithmException]]>
      </doc>
    </method>
    <method name="sign" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="privateKey" type="java.security.PrivateKey"/>
      <param name="data" type="java.lang.String"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
      <doc>
      <![CDATA[Signs the given data using the given private key.

 @throws GeneralSecurityException general security exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility methods for {@code "RSA-SHA1"} signing method.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.RsaSha -->
</package>
<package name="com.google.api.client.auth.oauth">
  <!-- start class com.google.api.client.auth.oauth.AbstractOAuthGetToken -->
  <class name="AbstractOAuthGetToken" extends="com.google.api.client.http.GenericUrl"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractOAuthGetToken" type="java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param authorizationServerUrl encoded authorization server URL]]>
      </doc>
    </constructor>
    <method name="execute" return="com.google.api.client.auth.oauth.OAuthCredentialsResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Executes the HTTP request for a temporary or long-lived token.

 @return OAuth credentials response object
 @throws HttpResponseException for an HTTP error code
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="createParameters" return="com.google.api.client.auth.oauth.OAuthParameters"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new instance of the OAuth authentication provider. Subclasses may override by calling
 this super implementation and then adding OAuth parameters.]]>
      </doc>
    </method>
    <field name="transport" type="com.google.api.client.http.HttpTransport"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP transport required for executing request in {@link #execute()}.

 @since 1.3]]>
      </doc>
    </field>
    <field name="consumerKey" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required identifier portion of the client credentials (equivalent to a username).]]>
      </doc>
    </field>
    <field name="signer" type="com.google.api.client.auth.oauth.OAuthSigner"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required OAuth signature algorithm.]]>
      </doc>
    </field>
    <field name="usePost" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code true} for POST request or the default {@code false} for GET request.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Generic OAuth 1.0a URL to request a temporary or long-lived token from an authorization server.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.AbstractOAuthGetToken -->
  <!-- start class com.google.api.client.auth.oauth.OAuthAuthorizeTemporaryTokenUrl -->
  <class name="OAuthAuthorizeTemporaryTokenUrl" extends="com.google.api.client.http.GenericUrl"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="OAuthAuthorizeTemporaryTokenUrl" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param encodedUserAuthorizationUrl encoded user authorization URL]]>
      </doc>
    </constructor>
    <field name="temporaryToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The temporary credentials token obtained from temporary credentials request in the
 "oauth_token" parameter. It is found in the {@link OAuthCredentialsResponse#token} returned by
 {@link OAuthGetTemporaryToken#execute()}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 1.0a URL builder for an authorization web page to allow the end user to authorize the
 temporary token.
 <p>
 The {@link #temporaryToken} should be set from the {@link OAuthCredentialsResponse#token}
 returned by {@link OAuthGetTemporaryToken#execute()}. Use {@link #build()} to build the
 authorization URL. If a {@link OAuthGetTemporaryToken#callback} was specified, after the end user
 grants the authorization, the authorization server will redirect to that callback URL. To parse
 the response, use {@link OAuthCallbackUrl}.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.OAuthAuthorizeTemporaryTokenUrl -->
  <!-- start class com.google.api.client.auth.oauth.OAuthCallbackUrl -->
  <class name="OAuthCallbackUrl" extends="com.google.api.client.http.GenericUrl"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="OAuthCallbackUrl" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="token" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The temporary credentials identifier received from the client.]]>
      </doc>
    </field>
    <field name="verifier" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The verification code.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Generic URL that parses the callback URL after a temporary token has been authorized by the end
 user.
 <p>
 The {@link #verifier} is required in order to exchange the authorized temporary token for a
 long-lived access token in {@link OAuthGetAccessToken#verifier}.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.OAuthCallbackUrl -->
  <!-- start class com.google.api.client.auth.oauth.OAuthCredentialsResponse -->
  <class name="OAuthCredentialsResponse" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="OAuthCredentialsResponse"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="token" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Credentials token.]]>
      </doc>
    </field>
    <field name="tokenSecret" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Credentials shared-secret for use with {@code "HMAC-SHA1"} signature algorithm. Used for
 {@link OAuthHmacSigner#tokenSharedSecret}.]]>
      </doc>
    </field>
    <field name="callbackConfirmed" type="java.lang.Boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "true"} for temporary credentials request or {@code null} for a token credentials
 request. The parameter is used to differentiate from previous versions of the protocol.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Data to parse a success response to a request for temporary or token credentials.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.OAuthCredentialsResponse -->
  <!-- start class com.google.api.client.auth.oauth.OAuthGetAccessToken -->
  <class name="OAuthGetAccessToken" extends="com.google.api.client.auth.oauth.AbstractOAuthGetToken"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="OAuthGetAccessToken" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param authorizationServerUrl encoded authorization server URL]]>
      </doc>
    </constructor>
    <method name="createParameters" return="com.google.api.client.auth.oauth.OAuthParameters"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="temporaryToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required temporary token. It is retrieved from the {@link OAuthCredentialsResponse#token}
 returned from {@link OAuthGetTemporaryToken#execute()}.]]>
      </doc>
    </field>
    <field name="verifier" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required verifier code received from the server when the temporary token was authorized. It is
 retrieved from {@link OAuthCallbackUrl#verifier}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Generic OAuth 1.0a URL to request to exchange the temporary credentials token (or "request
 token") for a long-lived credentials token (or "access token") from an authorization server.
 <p>
 Use {@link #execute()} to execute the request. The long-lived access token acquired with this
 request is found in {@link OAuthCredentialsResponse#token} . This token must be stored. It may
 then be used to authorize HTTP requests to protected resources by using {@link OAuthParameters}.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.OAuthGetAccessToken -->
  <!-- start class com.google.api.client.auth.oauth.OAuthGetTemporaryToken -->
  <class name="OAuthGetTemporaryToken" extends="com.google.api.client.auth.oauth.AbstractOAuthGetToken"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="OAuthGetTemporaryToken" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param authorizationServerUrl encoded authorization server URL]]>
      </doc>
    </constructor>
    <method name="createParameters" return="com.google.api.client.auth.oauth.OAuthParameters"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="callback" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Optional absolute URI back to which the server will redirect the resource owner when the
 Resource Owner Authorization step is completed or {@code null} for none.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Generic OAuth 1.0a URL to request a temporary credentials token (or "request token") from an
 authorization server.
 <p>
 Use {@link #execute()} to execute the request. The temporary token acquired with this request is
 found in {@link OAuthCredentialsResponse#token}. This temporary token is used in
 {@link OAuthAuthorizeTemporaryTokenUrl#temporaryToken} to direct the end user to an authorization
 page to allow the end user to authorize the temporary token.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.OAuthGetTemporaryToken -->
  <!-- start class com.google.api.client.auth.oauth.OAuthHmacSigner -->
  <class name="OAuthHmacSigner" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.auth.oauth.OAuthSigner"/>
    <constructor name="OAuthHmacSigner"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSignatureMethod" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="computeSignature" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="signatureBaseString" type="java.lang.String"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
    </method>
    <field name="clientSharedSecret" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Client-shared secret or {@code null} for none.]]>
      </doc>
    </field>
    <field name="tokenSharedSecret" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Token-shared secret or {@code null} for none.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth {@code "HMAC-SHA1"} signature method.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.OAuthHmacSigner -->
  <!-- start class com.google.api.client.auth.oauth.OAuthParameters -->
  <class name="OAuthParameters" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpExecuteInterceptor"/>
    <implements name="com.google.api.client.http.HttpRequestInitializer"/>
    <constructor name="OAuthParameters"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="computeNonce"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Computes a nonce based on the hex string of a random non-negative long, setting the value of
 the {@link #nonce} field.]]>
      </doc>
    </method>
    <method name="computeTimestamp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Computes a timestamp based on the current system time, setting the value of the
 {@link #timestamp} field.]]>
      </doc>
    </method>
    <method name="computeSignature"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="requestMethod" type="java.lang.String"/>
      <param name="requestUrl" type="com.google.api.client.http.GenericUrl"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
      <doc>
      <![CDATA[Computes a new signature based on the fields and the given request method and URL, setting the
 values of the {@link #signature} and {@link #signatureMethod} fields.

 @throws GeneralSecurityException general security exception]]>
      </doc>
    </method>
    <method name="getAuthorizationHeader" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code Authorization} header value to use with the OAuth parameter values found in
 the fields.]]>
      </doc>
    </method>
    <method name="escape" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the escaped form of the given value using OAuth escaping rules.]]>
      </doc>
    </method>
    <method name="signRequestsUsingAuthorizationHeader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.5) Use {@link OAuthParameters} directly">
      <param name="transport" type="com.google.api.client.http.HttpTransport"/>
      <doc>
      <![CDATA[Performs OAuth HTTP request signing via the {@code Authorization} header as the final HTTP
 request execute intercepter for the given HTTP transport.

 @deprecated (scheduled to be removed in 1.5) Use {@link OAuthParameters} directly]]>
      </doc>
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.api.client.http.HttpRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="intercept"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.api.client.http.HttpRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="signer" type="com.google.api.client.auth.oauth.OAuthSigner"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required OAuth signature algorithm.]]>
      </doc>
    </field>
    <field name="callback" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Absolute URI back to which the server will redirect the resource owner when the Resource Owner
 Authorization step is completed.]]>
      </doc>
    </field>
    <field name="consumerKey" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required identifier portion of the client credentials (equivalent to a username).]]>
      </doc>
    </field>
    <field name="nonce" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required nonce value. Should be computed using {@link #computeNonce()}.]]>
      </doc>
    </field>
    <field name="realm" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Realm.]]>
      </doc>
    </field>
    <field name="signature" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Signature. Required but normally computed using {@link #computeSignature}.]]>
      </doc>
    </field>
    <field name="signatureMethod" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Name of the signature method used by the client to sign the request. Required, but normally
 computed using {@link #computeSignature}.]]>
      </doc>
    </field>
    <field name="timestamp" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required timestamp value. Should be computed using {@link #computeTimestamp()}.]]>
      </doc>
    </field>
    <field name="token" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Token value used to associate the request with the resource owner or {@code null} if the
 request is not associated with a resource owner.]]>
      </doc>
    </field>
    <field name="verifier" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The verification code received from the server.]]>
      </doc>
    </field>
    <field name="version" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Must either be "1.0" or {@code null} to skip. Provides the version of the authentication
 process as defined in this specification.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 1.0a parameter manager.
 <p>
 The only required non-computed fields are {@link #signer} and {@link #consumerKey}. Use
 {@link #token} to specify token or temporary credentials.

 <p>
 Sample usage, taking advantage that this class implements {@link HttpRequestInitializer}:
 </p>

 <pre>
  public static HttpRequestFactory createRequestFactory(HttpTransport transport) {
    OAuthParameters parameters = new OAuthParameters();
    // ...
    return transport.createRequestFactory(parameters);
  }
 </pre>

 <p>
 If you have a custom request initializer, take a look at the sample usage for
 {@link HttpExecuteInterceptor}, which this class also implements.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.OAuthParameters -->
  <!-- start class com.google.api.client.auth.oauth.OAuthRsaSigner -->
  <class name="OAuthRsaSigner" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.auth.oauth.OAuthSigner"/>
    <constructor name="OAuthRsaSigner"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSignatureMethod" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="computeSignature" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="signatureBaseString" type="java.lang.String"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
    </method>
    <field name="privateKey" type="java.security.PrivateKey"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Private key.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth {@code "RSA-SHA1"} signature method.
 <p>
 The private key may be retrieved using the utilities in {@link RsaSha}.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.OAuthRsaSigner -->
  <!-- start interface com.google.api.client.auth.oauth.OAuthSigner -->
  <interface name="OAuthSigner"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getSignatureMethod" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the signature method.]]>
      </doc>
    </method>
    <method name="computeSignature" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="signatureBaseString" type="java.lang.String"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
      <doc>
      <![CDATA[Returns the signature computed from the given signature base string.

 @throws GeneralSecurityException general security exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[OAuth signature method.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </interface>
  <!-- end interface com.google.api.client.auth.oauth.OAuthSigner -->
</package>
<package name="com.google.api.client.auth.oauth2">
  <!-- start class com.google.api.client.auth.oauth2.AccessProtectedResource -->
  <class name="AccessProtectedResource" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="(scheduled to be removed in 1.5) Use
             {@link com.google.api.client.auth.oauth2.draft10.AccessProtectedResource}">
    <method name="usingAuthorizationHeader"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transport" type="com.google.api.client.http.HttpTransport"/>
      <param name="accessToken" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "Authorization"} header using the given access token for every executed HTTP
 request for the given HTTP transport.
 <p>
 Any existing HTTP request execute intercepters for setting the OAuth 2 access token will be
 removed.
 </p>

 @param transport HTTP transport
 @param accessToken access token]]>
      </doc>
    </method>
    <method name="usingQueryParameter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transport" type="com.google.api.client.http.HttpTransport"/>
      <param name="accessToken" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "oauth_token"} URI query parameter using the given access token for every
 executed HTTP request for the given HTTP transport.
 <p>
 Any existing HTTP request execute intercepters for setting the OAuth 2 access token will be
 removed.

 @param transport HTTP transport
 @param accessToken access token]]>
      </doc>
    </method>
    <method name="usingFormEncodedBody"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transport" type="com.google.api.client.http.HttpTransport"/>
      <param name="accessToken" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "oauth_token"} parameter in the form-encoded HTTP body using the given access
 token for every executed HTTP request for the given HTTP transport.
 <p>
 Any existing HTTP request execute intercepters for setting the OAuth 2 access token will be
 removed. Requirements:
 <ul>
 <li>The HTTP method must be "POST", "PUT", or "DELETE".</li>
 <li>The HTTP content must be {@code null} or {@link UrlEncodedContent}.</li>
 <li>The {@link UrlEncodedContent#data} must be {@code null} or {@link GenericData}.</li>
 </ul>

 @param transport HTTP transport
 @param accessToken access token]]>
      </doc>
    </method>
    <doc>
    <![CDATA[OAuth 2.0 methods for specifying the access token parameter as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-5">Accessing a Protected
 Resource</a>.

 @author Yaniv Inbar
 @since 1.2
 @deprecated (scheduled to be removed in 1.5) Use
             {@link com.google.api.client.auth.oauth2.draft10.AccessProtectedResource}]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.AccessProtectedResource -->
  <!-- start class com.google.api.client.auth.oauth2.AccessTokenErrorResponse -->
  <class name="AccessTokenErrorResponse" extends="com.google.api.client.util.GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="(scheduled to be removed in 1.5) Use
             {@link com.google.api.client.auth.oauth2.draft10.AccessTokenErrorResponse}">
    <constructor name="AccessTokenErrorResponse"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getErrorCodeIfKnown" return="com.google.api.client.auth.oauth2.AccessTokenErrorResponse.KnownError"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a known error code if {@link #error} is one of the error codes listed in the OAuth 2
 specification or {@code null} if the {@link #error} is {@code null} or not known.]]>
      </doc>
    </method>
    <field name="error" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) A single error code.

 @see #getErrorCodeIfKnown()]]>
      </doc>
    </field>
    <field name="errorDescription" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) A human-readable text providing additional information, used to assist in the
 understanding and resolution of the error occurred.]]>
      </doc>
    </field>
    <field name="errorUri" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) A URI identifying a human-readable web page with information about the error, used
 to provide the end-user with additional information about the error.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 access token error response as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-4.3">Error Response</a>.

 @since 1.2
 @author Yaniv Inbar
 @deprecated (scheduled to be removed in 1.5) Use
             {@link com.google.api.client.auth.oauth2.draft10.AccessTokenErrorResponse}]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.AccessTokenErrorResponse -->
  <!-- start class com.google.api.client.auth.oauth2.AccessTokenErrorResponse.KnownError -->
  <class name="AccessTokenErrorResponse.KnownError" extends="java.lang.Enum&lt;com.google.api.client.auth.oauth2.AccessTokenErrorResponse.KnownError&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.api.client.auth.oauth2.AccessTokenErrorResponse.KnownError[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.api.client.auth.oauth2.AccessTokenErrorResponse.KnownError"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Error codes listed in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-4.3.1">Error Codes</a>.]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.AccessTokenErrorResponse.KnownError -->
  <!-- start class com.google.api.client.auth.oauth2.AccessTokenRequest -->
  <class name="AccessTokenRequest" extends="com.google.api.client.util.GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="(scheduled to be removed in 1.5) Use
             {@link com.google.api.client.auth.oauth2.draft10.AccessTokenRequest}">
    <constructor name="AccessTokenRequest"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="execute" return="com.google.api.client.http.HttpResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Executes request for an access token, and returns the HTTP response.

 @return HTTP response, which can then be parsed using {@link HttpResponse#parseAs(Class)} with
         {@link AccessTokenResponse}
 @throws HttpResponseException for an HTTP error response, which can then be parsed using
         {@link HttpResponse#parseAs(Class)} on {@link HttpResponseException#response} using
         {@link AccessTokenErrorResponse}
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <field name="transport" type="com.google.api.client.http.HttpTransport"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) HTTP transport required for executing request in {@link #execute()}.

 @since 1.3]]>
      </doc>
    </field>
    <field name="jsonFactory" type="com.google.api.client.json.JsonFactory"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) JSON factory to use for parsing response in {@link #execute()}.

 @since 1.3]]>
      </doc>
    </field>
    <field name="grantType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The access grant type included in the request. Value MUST be one of
 "authorization_code", "password", "assertion", "refresh_token", or "none".]]>
      </doc>
    </field>
    <field name="clientId" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED, unless the client identity can be establish via other means, for example assertion)
 The client identifier or {@code null} for none.]]>
      </doc>
    </field>
    <field name="clientSecret" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The client secret.]]>
      </doc>
    </field>
    <field name="scope" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The scope of the access request expressed as a list of space-delimited strings or
 {@code null} for none. The value of the "scope" parameter is defined by the authorization
 server. If the value contains multiple space-delimited strings, their order does not matter,
 and each string adds an additional access range to the requested scope. If the access grant
 being used already represents an approved scope (e.g. authorization code, assertion), the
 requested scope MUST be equal or lesser than the scope previously granted.]]>
      </doc>
    </field>
    <field name="authorizationServerUrl" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) Encoded authorization server URL.]]>
      </doc>
    </field>
    <field name="useBasicAuthorization" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Defaults to {@code true} to use Basic Authentication as recommended in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-2.1">Client Password
 Credentials</a>, but may be set to {@code false} for for specifying the password in the request
 body using the {@code "clientSecret"} parameter in the HTTP body.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 request for an access token as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-4">Obtaining an Access Token</a>.
 <p>
 This class may be used directly when no access grant is included, such as when the client is
 requesting access to the protected resources under its control. Otherwise, use one of the
 subclasses, which add custom parameters to specify the access grant. Call {@link #execute()} to
 execute the request from which the {@link AccessTokenResponse} may be parsed. On error, use
 {@link AccessTokenErrorResponse} instead.
 <p>
 Sample usage when the client is requesting access to the protected resources under its control:

 <pre>
 <code>
  static void requestAccessToken() throws IOException {
    try {
      AccessTokenRequest request =
          new AccessTokenRequest(new NetHttpTransport(), new JacksonFactory(),
              "https://server.example.com/authorize", "s6BhdRkqt3", "gX1fBat3bV");
      AccessTokenResponse response = request.execute().parseAs(AccessTokenResponse.class);
      System.out.println("Access token: " + response.accessToken);
    } catch (HttpResponseException e) {
      AccessTokenErrorResponse response = e.response.parseAs(AccessTokenErrorResponse.class);
      System.out.println("Error: " + response.error);
    }
  }
 </code>
 </pre>
 </p>

 @since 1.2
 @author Yaniv Inbar
 @deprecated (scheduled to be removed in 1.5) Use
             {@link com.google.api.client.auth.oauth2.draft10.AccessTokenRequest}]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.AccessTokenRequest -->
  <!-- start class com.google.api.client.auth.oauth2.AccessTokenRequest.AssertionGrant -->
  <class name="AccessTokenRequest.AssertionGrant" extends="com.google.api.client.auth.oauth2.AccessTokenRequest"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="(scheduled to be removed in 1.5) Use {@link
             com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.AssertionGrant}">
    <constructor name="AccessTokenRequest.AssertionGrant"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="assertionType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The format of the assertion as defined by the authorization server. The value MUST
 be an absolute URI.]]>
      </doc>
    </field>
    <field name="assertion" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The assertion.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 Assertion Flow: request an access token based on as assertion as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-4.1.3">Assertion</a>.
 <p>
 Sample usage:

 <pre>
 <code>
    static void requestAccessToken() throws IOException {
      try {
        AssertionGrant request = new AssertionGrant(new NetHttpTransport(),
            new JacksonFactory(),
            "https://server.example.com/authorize",
            "gX1fBat3bV",
            "urn:oasis:names:tc:SAML:2.0:",
            "PHNhbWxwOl...[omitted for brevity]...ZT4=");
        AccessTokenResponse response = request.execute().parseAs(AccessTokenResponse.class);
        System.out.println("Access token: " + response.accessToken);
      } catch (HttpResponseException e) {
        AccessTokenErrorResponse response = e.response.parseAs(AccessTokenErrorResponse.class);
        System.out.println("Error: " + response.error);
      }
    }
 </code>
 </pre>
 </p>

 @deprecated (scheduled to be removed in 1.5) Use {@link
             com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.AssertionGrant}]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.AccessTokenRequest.AssertionGrant -->
  <!-- start class com.google.api.client.auth.oauth2.AccessTokenRequest.AuthorizationCodeGrant -->
  <class name="AccessTokenRequest.AuthorizationCodeGrant" extends="com.google.api.client.auth.oauth2.AccessTokenRequest"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="(scheduled to be removed in 1.5) Use {@link
             com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.AuthorizationCodeGrant}">
    <constructor name="AccessTokenRequest.AuthorizationCodeGrant"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="code" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The authorization code received from the authorization server.]]>
      </doc>
    </field>
    <field name="redirectUri" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The redirection URI used in the initial request.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 Web Server Flow: request an access token based on a verification code as specified in
 <a href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-4.1.1">Authorization
 Code</a>.
 <p>
 Sample usage:

 <pre>
 <code>
    static void requestAccessToken() throws IOException {
      try {
        AuthorizationCodeGrant request = new AuthorizationCodeGrant(new NetHttpTransport(),
            new JacksonFactory(),
            "https://server.example.com/authorize",
            "s6BhdRkqt3",
            "gX1fBat3bV",
            "i1WsRn1uB1",
            "https://client.example.com/cb");
        AccessTokenResponse response = request.execute().parseAs(AccessTokenResponse.class);
        System.out.println("Access token: " + response.accessToken);
      } catch (HttpResponseException e) {
        AccessTokenErrorResponse response = e.response.parseAs(AccessTokenErrorResponse.class);
        System.out.println("Error: " + response.error);
      }
    }
 </code>
 </pre>
 </p>

 @deprecated (scheduled to be removed in 1.5) Use {@link
             com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.AuthorizationCodeGrant}]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.AccessTokenRequest.AuthorizationCodeGrant -->
  <!-- start class com.google.api.client.auth.oauth2.AccessTokenRequest.RefreshTokenGrant -->
  <class name="AccessTokenRequest.RefreshTokenGrant" extends="com.google.api.client.auth.oauth2.AccessTokenRequest"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="(scheduled to be removed in 1.5) Use {@link
             com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.RefreshTokenGrant}">
    <constructor name="AccessTokenRequest.RefreshTokenGrant"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="refreshToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The refresh token associated with the access token to be refreshed.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 request to refresh an access token as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-4.1.4">Refresh Token</a>.
 <p>
 Sample usage:

 <pre>
 <code>
    static void requestAccessToken() throws IOException {
      try {
        RefreshTokenGrant request = new RefreshTokenGrant(new NetHttpTransport(),
            new JacksonFactory(),
            "https://server.example.com/authorize",
            "s6BhdRkqt3",
            "gX1fBat3bV",
            "n4E9O119d");
        AccessTokenResponse response = request.execute().parseAs(AccessTokenResponse.class);
        System.out.println("Access token: " + response.accessToken);
      } catch (HttpResponseException e) {
        AccessTokenErrorResponse response = e.response.parseAs(AccessTokenErrorResponse.class);
        System.out.println("Error: " + response.error);
      }
    }
 </code>
 </pre>
 </p>

 @deprecated (scheduled to be removed in 1.5) Use {@link
             com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.RefreshTokenGrant}]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.AccessTokenRequest.RefreshTokenGrant -->
  <!-- start class com.google.api.client.auth.oauth2.AccessTokenRequest.ResourceOwnerPasswordCredentialsGrant -->
  <class name="AccessTokenRequest.ResourceOwnerPasswordCredentialsGrant" extends="com.google.api.client.auth.oauth2.AccessTokenRequest"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="(scheduled to be removed in 1.5) Use {@link
             com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.ResourceOwnerPasswordCredentialsGrant}">
    <constructor name="AccessTokenRequest.ResourceOwnerPasswordCredentialsGrant"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="username" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The resource owner's username.]]>
      </doc>
    </field>
    <field name="password" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The resource owner's password.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 Username and Password Flow: request an access token based on resource owner
 credentials used in the as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-4.1.2">Resource Owner Password
 Credentials</a>.
 <p>
 Sample usage:

 <pre>
 <code>
    static void requestAccessToken() throws IOException {
      try {
        ResourceOwnerPasswordCredentialsGrant request =
            new ResourceOwnerPasswordCredentialsGrant(new NetHttpTransport(),
                new JacksonFactory(),
                "https://server.example.com/authorize",
                "s6BhdRkqt3",
                "gX1fBat3bV",
                "johndoe",
                "A3ddj3w");
        AccessTokenResponse response = request.execute().parseAs(AccessTokenResponse.class);
        System.out.println("Access token: " + response.accessToken);
      } catch (HttpResponseException e) {
        AccessTokenErrorResponse response = e.response.parseAs(AccessTokenErrorResponse.class);
        System.out.println("Error: " + response.error);
      }
    }
 </code>
 </pre>
 </p>

 @deprecated (scheduled to be removed in 1.5) Use {@link
             com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.ResourceOwnerPasswordCredentialsGrant}]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.AccessTokenRequest.ResourceOwnerPasswordCredentialsGrant -->
  <!-- start class com.google.api.client.auth.oauth2.AccessTokenResponse -->
  <class name="AccessTokenResponse" extends="com.google.api.client.util.GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="(scheduled to be removed in 1.5) Use
             {@link com.google.api.client.auth.oauth2.draft10.AccessTokenResponse}">
    <constructor name="AccessTokenResponse"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="accessToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The access token issued by the authorization server.]]>
      </doc>
    </field>
    <field name="expiresIn" type="java.lang.Long"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The duration in seconds of the access token lifetime. For example, the value "3600"
 denotes that the access token will expire in one hour from the time the response was generated
 by the authorization server.]]>
      </doc>
    </field>
    <field name="refreshToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The refresh token used to obtain new access tokens. The authorization server SHOULD
 NOT issue a refresh token when the access grant type is set to "none".]]>
      </doc>
    </field>
    <field name="scope" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The scope of the access token as a list of space- delimited strings. The value of
 the "scope" parameter is defined by the authorization server. If the value contains multiple
 space-delimited strings, their order does not matter, and each string adds an additional access
 range to the requested scope. The authorization server SHOULD include the parameter if the
 requested scope is different from the one requested by the client.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 access token success response content as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-4.2">Access Token Response</a>.
 <p>
 Use {@link AccessProtectedResource} to authorize executed HTTP requests based on the
 {@link #accessToken}, for example {@link AccessProtectedResource}. {@link
 AccessProtectedResource#usingAuthorizationHeader(com.google.api.client.http.HttpTransport,
 String) usingAuthorizationHeader}{@code (transport, response.accessToken)}.
 </p>

 @since 1.2
 @author Yaniv Inbar
 @deprecated (scheduled to be removed in 1.5) Use
             {@link com.google.api.client.auth.oauth2.draft10.AccessTokenResponse}]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.AccessTokenResponse -->
  <!-- start class com.google.api.client.auth.oauth2.AuthorizationRequestUrl -->
  <class name="AuthorizationRequestUrl" extends="com.google.api.client.http.GenericUrl"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="(scheduled to be removed in 1.5) Use
             {@link com.google.api.client.auth.oauth2.draft10.AuthorizationRequestUrl}">
    <constructor name="AuthorizationRequestUrl" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param encodedAuthorizationServerUrl encoded authorization server URL]]>
      </doc>
    </constructor>
    <field name="responseType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The requested response: an access token, an authorization code, or both. The
 parameter value MUST be set to "token" for requesting an access token, "code" for requesting an
 authorization code, or "code_and_token" to request both. The authorization server MAY decline
 to provide one or more of these response types. For convenience, you may use
 {@link ResponseType} to set this value.
 <p>
 By default, the response type is {@code "code"}, but this may be overridden.
 </p>]]>
      </doc>
    </field>
    <field name="clientId" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The client identifier.]]>
      </doc>
    </field>
    <field name="redirectUri" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED, unless a redirection URI has been established between the client and authorization
 server via other means) An absolute URI to which the authorization server will redirect the
 user-agent to when the end-user authorization step is completed. The authorization server
 SHOULD require the client to pre-register their redirection URI.]]>
      </doc>
    </field>
    <field name="scope" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The scope of the access request expressed as a list of space-delimited strings. The
 value of the "scope" parameter is defined by the authorization server. If the value contains
 multiple space-delimited strings, their order does not matter, and each string adds an
 additional access range to the requested scope.]]>
      </doc>
    </field>
    <field name="state" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) An opaque value used by the client to maintain state between the request and
 callback. The authorization server includes this value when redirecting the user-agent back to
 the client.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 URL builder for an authorization web page to allow the end user to authorize the
 application to access their protected resources as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-3">Obtaining End-User
 Authorization</a>.
 <p>
 Use {@link AuthorizationResponse} to parse the redirect response after the end user grants/denies
 the request.
 </p>
 <p>
 Sample usage for a web application:

 <pre>
 <code>
  public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    AuthorizationRequestUrl builder =
        new AuthorizationRequestUrl(BASE_AUTHORIZATION_URL, CLIENT_ID);
    builder.redirectUri = REDIRECT_URL;
    builder.scope = SCOPE;
    response.sendRedirect(builder.build());
    return;
  }
 </code>
 </pre>

 @since 1.2
 @author Yaniv Inbar
 @deprecated (scheduled to be removed in 1.5) Use
             {@link com.google.api.client.auth.oauth2.draft10.AuthorizationRequestUrl}]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.AuthorizationRequestUrl -->
  <!-- start class com.google.api.client.auth.oauth2.AuthorizationRequestUrl.ResponseType -->
  <class name="AuthorizationRequestUrl.ResponseType" extends="java.lang.Enum&lt;com.google.api.client.auth.oauth2.AuthorizationRequestUrl.ResponseType&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.api.client.auth.oauth2.AuthorizationRequestUrl.ResponseType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.api.client.auth.oauth2.AuthorizationRequestUrl.ResponseType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="com.google.api.client.auth.oauth2.AuthorizationRequestUrl"/>
      <doc>
      <![CDATA[Sets the response type on an authorization request URL.

 @param url authorization request URL]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Response type enumeration that may be used for setting the
 {@link AuthorizationRequestUrl#responseType}.
 <p>
 Call {@link #set(AuthorizationRequestUrl)} to set the response type on an authorization request
 URL.
 </p>]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.AuthorizationRequestUrl.ResponseType -->
  <!-- start class com.google.api.client.auth.oauth2.AuthorizationResponse -->
  <class name="AuthorizationResponse" extends="com.google.api.client.util.GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="(scheduled to be removed in 1.5) Use
             {@link com.google.api.client.auth.oauth2.draft10.AuthorizationResponse}">
    <constructor name="AuthorizationResponse" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param redirectUrl encoded redirect URL
 @throws IllegalArgumentException URI syntax exception]]>
      </doc>
    </constructor>
    <method name="getErrorCodeIfKnown" return="com.google.api.client.auth.oauth2.AuthorizationResponse.KnownError"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a known error code if {@link #error} is one of the error codes listed in the OAuth 2
 specification or {@code null} if the {@link #error} is {@code null} or not known.]]>
      </doc>
    </method>
    <field name="code" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED if the end user grants authorization and the response type is "code" or
 "code_and_token", otherwise MUST NOT be included) The authorization code generated by the
 authorization server. The authorization code SHOULD expire shortly after it is issued. The
 authorization server MUST invalidate the authorization code after a single usage. The
 authorization code is bound to the client identifier and redirection URI.]]>
      </doc>
    </field>
    <field name="accessToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED if the end user grants authorization and the response type is "token" or
 "code_and_token", otherwise MUST NOT be included) The access token issued by the authorization
 server.]]>
      </doc>
    </field>
    <field name="expiresIn" type="java.lang.Long"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The duration in seconds of the access token lifetime if an access token is included.
 For example, the value "3600" denotes that the access token will expire in one hour from the
 time the response was generated by the authorization server.]]>
      </doc>
    </field>
    <field name="scope" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The scope of the access token as a list of space- delimited strings if an access
 token is included. The value of the "scope" parameter is defined by the authorization server.
 If the value contains multiple space-delimited strings, their order does not matter, and each
 string adds an additional access range to the requested scope. The authorization server SHOULD
 include the parameter if the requested scope is different from the one requested by the client.]]>
      </doc>
    </field>
    <field name="error" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED if the end user denies authorization) A single error code.

 @see #getErrorCodeIfKnown()]]>
      </doc>
    </field>
    <field name="errorDescription" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) A human-readable text providing additional information, used to assist in the
 understanding and resolution of the error occurred.]]>
      </doc>
    </field>
    <field name="errorUri" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) A URI identifying a human-readable web page with information about the error, used
 to provide the end-user with additional information about the error.]]>
      </doc>
    </field>
    <field name="state" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED if the "state" parameter was present in the client authorization request) Set to the
 exact value received from the client.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 parser for the redirect URL after end user grants or denies authorization as specified
 in <a href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-3.1">Authorization
 Response</a>.
 <p>
 Check if {@link #error} is {@code null} to check if the end-user granted authorization.
 </p>
 <p>
 Sample usage for a web application:

 <pre><code>
  public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    StringBuffer fullUrlBuf = request.getRequestURL();
    if (request.getQueryString() != null) {
      fullUrlBuf.append('?').append(request.getQueryString());
    }
    AuthorizationResponse authResponse = new AuthorizationResponse(fullUrlBuf.toString());
    // check for user-denied error
    if (authResponse.error != null) {
      // authorization denied...
    } else {
      // request access token using authResponse.code...
    }
  }
 </code></pre>
 </p>
 <p>
 Sample usage for an installed application:

 <pre><code>
  static void processRedirectUrl(HttpTransport transport, String redirectUrl) {
    AuthorizationResponse response = new AuthorizationResponse(redirectUrl);
    if (response.error != null) {
      throw new RuntimeException("Authorization denied");
    }
    AccessProtectedResource.usingAuthorizationHeader(transport, response.accessToken);
  }
 </code></pre>
 </p>

 @since 1.2
 @author Yaniv Inbar
 @deprecated (scheduled to be removed in 1.5) Use
             {@link com.google.api.client.auth.oauth2.draft10.AuthorizationResponse}]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.AuthorizationResponse -->
  <!-- start class com.google.api.client.auth.oauth2.AuthorizationResponse.KnownError -->
  <class name="AuthorizationResponse.KnownError" extends="java.lang.Enum&lt;com.google.api.client.auth.oauth2.AuthorizationResponse.KnownError&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.api.client.auth.oauth2.AuthorizationResponse.KnownError[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.api.client.auth.oauth2.AuthorizationResponse.KnownError"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Error codes listed in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-3.2.1">Error Codes</a>.]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.AuthorizationResponse.KnownError -->
</package>
<package name="com.google.api.client.auth.oauth2.draft10">
  <!-- start class com.google.api.client.auth.oauth2.draft10.AccessProtectedResource -->
  <class name="AccessProtectedResource" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpExecuteInterceptor"/>
    <implements name="com.google.api.client.http.HttpRequestInitializer"/>
    <implements name="com.google.api.client.http.HttpUnsuccessfulResponseHandler"/>
    <constructor name="AccessProtectedResource" type="java.lang.String, com.google.api.client.auth.oauth2.draft10.AccessProtectedResource.Method"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param accessToken access token or {@code null} for none (does not call
        {@link #setAccessToken(String)})
 @param method method of accessing protected resources]]>
      </doc>
    </constructor>
    <constructor name="AccessProtectedResource" type="java.lang.String, com.google.api.client.auth.oauth2.draft10.AccessProtectedResource.Method, com.google.api.client.http.HttpTransport, com.google.api.client.json.JsonFactory, java.lang.String, java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor to use to be able to refresh token when an access token expires.

 @param accessToken access token or {@code null} for none (does not call
        {@link #setAccessToken(String)})
 @param method method of accessing protected resources
 @param transport HTTP transport for executing refresh token request
 @param jsonFactory JSON factory to use for parsing response for refresh token request
 @param authorizationServerUrl encoded authorization server URL
 @param clientId client identifier
 @param clientSecret client secret
 @param refreshToken refresh token associated with the access token to be refreshed]]>
      </doc>
    </constructor>
    <method name="getAccessToken" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the access token or {@code null} for none.]]>
      </doc>
    </method>
    <method name="setAccessToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="accessToken" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the access token.

 @param accessToken access token or {@code null} for none]]>
      </doc>
    </method>
    <method name="getMethod" return="com.google.api.client.auth.oauth2.draft10.AccessProtectedResource.Method"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the method of accessing protected resources.]]>
      </doc>
    </method>
    <method name="getTransport" return="com.google.api.client.http.HttpTransport"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the HTTP transport for executing refresh token request or {@code null} for none.]]>
      </doc>
    </method>
    <method name="getJsonFactory" return="com.google.api.client.json.JsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the JSON factory to use for parsing response for refresh token request or {@code null}
 for none.]]>
      </doc>
    </method>
    <method name="getAuthorizationServerUrl" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the encoded authorization server URL or {@code null} for none.]]>
      </doc>
    </method>
    <method name="getClientId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the client identifier or {@code null} for none.]]>
      </doc>
    </method>
    <method name="getClientSecret" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the client secret or {@code null} for none.]]>
      </doc>
    </method>
    <method name="getRefreshToken" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the refresh token associated with the access token to be refreshed or {@code null} for
 none.]]>
      </doc>
    </method>
    <method name="refreshToken" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Request a new access token from the authorization endpoint, acquiring a lock on the access
 token so other threads calling {@link #getAccessToken()} must wait until the new access token
 has been retrieved.

 @return whether a new access token was retrieved]]>
      </doc>
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.api.client.http.HttpRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="intercept"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.api.client.http.HttpRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}
 <p>
 Default implementation checks if there is an access token and sets the access token parameter
 using the appropriate method. Subclasses may override.
 </p>]]>
      </doc>
    </method>
    <method name="handleResponse" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.api.client.http.HttpRequest"/>
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="retrySupported" type="boolean"/>
      <doc>
      <![CDATA[{@inheritDoc}
 <p>
 Default implementation checks for a 401 error code and calls {@link #refreshToken()}. If
 {@link #executeRefreshToken()} throws an I/O exception, this implementation will log the
 exception and return {@code false}. Subclasses may override.
 </p>]]>
      </doc>
    </method>
    <method name="executeRefreshToken" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Request a new access token from the authorization endpoint.

 <p>
 Default implementation executes the refresh token grant parameter passed to the constructor or
 {@code false} if it was {@code null}. Subclasses may override. If a new access token was
 retrieved, implementations must call {@link #setAccessToken(String)}. Implementations can
 assume proper thread synchronization is already taken care of inside {@link #refreshToken()},
 where this is called from.
 </p>

 @return whether a new access token was retrieved
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="onAccessToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="accessToken" type="java.lang.String"/>
      <doc>
      <![CDATA[Notifies of a new access token.

 <p>
 Default implementation does nothing, but subclasses may override in order to provide
 functionality like persisting the access token in a data store. Implementations can assume
 proper thread synchronization is already taken care of inside {@link #setAccessToken(String)},
 where this is called from.
 </p>

 @param accessToken access token or {@code null} for none]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Thread-safe OAuth 2.0 (draft 10) method for specifying and refreshing the access token parameter
 as a request parameter as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-5">Accessing a Protected
 Resource</a>.

 <p>
 Sample usage, taking advantage that this class implements {@link HttpRequestInitializer}:
 </p>

 <pre>
  public static HttpRequestFactory createRequestFactoryNoRefresh(HttpTransport transport,
      JsonFactory jsonFactory, AccessTokenResponse accessTokenResponse) {
    return transport.createRequestFactory(new AccessProtectedResource(
        accessTokenResponse.accessToken, Method.AUTHORIZATION_HEADER));
  }

  public static HttpRequestFactory createRequestFactory(HttpTransport transport,
      JsonFactory jsonFactory, AccessTokenResponse accessTokenResponse) {
    return transport.createRequestFactory(new AccessProtectedResource(
        accessTokenResponse.accessToken, Method.AUTHORIZATION_HEADER, transport, jsonFactory,
        "https://server.example.com/authorize", "s6BhdRkqt3", "gX1fBat3bV",
        accessTokenResponse.refreshToken));
  }
 </pre>

 <p>
 If you need to persist the access token in a data store, override {@link #onAccessToken(String)}.
 </p>

 <p>
 If you have a custom request initializer, request execute interceptor, or unsuccessful response
 handler, take a look at the sample usage for {@link HttpExecuteInterceptor} and
 {@link HttpUnsuccessfulResponseHandler}, which are interfaces that this class also implements.
 </p>

 @author Yaniv Inbar
 @since 1.4]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AccessProtectedResource -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AccessProtectedResource.Method -->
  <class name="AccessProtectedResource.Method" extends="java.lang.Enum&lt;com.google.api.client.auth.oauth2.draft10.AccessProtectedResource.Method&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.api.client.auth.oauth2.draft10.AccessProtectedResource.Method[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.api.client.auth.oauth2.draft10.AccessProtectedResource.Method"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Method of accessing protected resources.
 <p>
 The only method required to be implemented by the specification is
 {@link #AUTHORIZATION_HEADER}.
 </p>]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AccessProtectedResource.Method -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AccessTokenErrorResponse -->
  <class name="AccessTokenErrorResponse" extends="com.google.api.client.util.GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AccessTokenErrorResponse"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getErrorCodeIfKnown" return="com.google.api.client.auth.oauth2.draft10.AccessTokenErrorResponse.KnownError"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a known error code if {@link #error} is one of the error codes listed in the OAuth 2
 specification or {@code null} if the {@link #error} is {@code null} or not known.]]>
      </doc>
    </method>
    <field name="error" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) A single error code.

 @see #getErrorCodeIfKnown()]]>
      </doc>
    </field>
    <field name="errorDescription" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) A human-readable text providing additional information, used to assist in the
 understanding and resolution of the error occurred.]]>
      </doc>
    </field>
    <field name="errorUri" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) A URI identifying a human-readable web page with information about the error, used
 to provide the end-user with additional information about the error.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 (draft 10) access token error response as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-4.3">Error Response</a>.

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AccessTokenErrorResponse -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AccessTokenErrorResponse.KnownError -->
  <class name="AccessTokenErrorResponse.KnownError" extends="java.lang.Enum&lt;com.google.api.client.auth.oauth2.draft10.AccessTokenErrorResponse.KnownError&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.api.client.auth.oauth2.draft10.AccessTokenErrorResponse.KnownError[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.api.client.auth.oauth2.draft10.AccessTokenErrorResponse.KnownError"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Error codes listed in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-4.3.1">Error Codes</a>.]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AccessTokenErrorResponse.KnownError -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AccessTokenRequest -->
  <class name="AccessTokenRequest" extends="com.google.api.client.util.GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AccessTokenRequest"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AccessTokenRequest" type="com.google.api.client.http.HttpTransport, com.google.api.client.json.JsonFactory, java.lang.String, java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param transport HTTP transport for executing request in {@link #execute()}
 @param jsonFactory JSON factory to use for parsing response in {@link #execute()}
 @param authorizationServerUrl encoded authorization server URL
 @param clientSecret client secret]]>
      </doc>
    </constructor>
    <constructor name="AccessTokenRequest" type="com.google.api.client.http.HttpTransport, com.google.api.client.json.JsonFactory, java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param transport HTTP transport for executing request in {@link #execute()}
 @param jsonFactory JSON factory to use for parsing response in {@link #execute()}
 @param authorizationServerUrl encoded authorization server URL
 @param clientId client identifier
 @param clientSecret client secret]]>
      </doc>
    </constructor>
    <method name="executeUnparsed" return="com.google.api.client.http.HttpResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Executes request for an access token, and returns the HTTP response.

 <p>
 To execute and parse the response to {@link AccessTokenResponse}, use {@link #execute()}
 </p>

 @return HTTP response, which can then be parsed directly using
         {@link HttpResponse#parseAs(Class)} or some other parsing method
 @throws HttpResponseException for an HTTP error response, which can then be parsed using
         {@link HttpResponse#parseAs(Class)} on {@link HttpResponseException#response} using
         {@link AccessTokenErrorResponse}]]>
      </doc>
    </method>
    <method name="execute" return="com.google.api.client.auth.oauth2.draft10.AccessTokenResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Executes request for an access token, and returns the parsed access token response.

 <p>
 To execute without parsing the response, use {@link #executeUnparsed()}
 </p>

 @return parsed access token response
 @throws HttpResponseException for an HTTP error response, which can then be parsed using
         {@link HttpResponse#parseAs(Class)} on {@link HttpResponseException#response} using
         {@link AccessTokenErrorResponse}]]>
      </doc>
    </method>
    <field name="transport" type="com.google.api.client.http.HttpTransport"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) HTTP transport required for executing request in {@link #execute()}.]]>
      </doc>
    </field>
    <field name="jsonFactory" type="com.google.api.client.json.JsonFactory"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) JSON factory to use for parsing response in {@link #execute()}.]]>
      </doc>
    </field>
    <field name="grantType" type="com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.GrantType"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The access grant type included in the request.]]>
      </doc>
    </field>
    <field name="clientId" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED, unless the client identity can be establish via other means, for example assertion)
 The client identifier or {@code null} for none.]]>
      </doc>
    </field>
    <field name="clientSecret" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The client secret.]]>
      </doc>
    </field>
    <field name="scope" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The scope of the access request expressed as a list of space-delimited strings or
 {@code null} for none. The value of the "scope" parameter is defined by the authorization
 server. If the value contains multiple space-delimited strings, their order does not matter,
 and each string adds an additional access range to the requested scope. If the access grant
 being used already represents an approved scope (e.g. authorization code, assertion), the
 requested scope MUST be equal or lesser than the scope previously granted.]]>
      </doc>
    </field>
    <field name="authorizationServerUrl" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) Encoded authorization server URL.]]>
      </doc>
    </field>
    <field name="useBasicAuthorization" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code false} to specify the password in the request body using the {@code "clientSecret"}
 parameter in the HTTP body or {@code true} to use Basic Authentication as recommended in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-2.1">Client Password
 Credentials</a>.
 <p>
 Defaults to {@code false}.
 </p>]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 (draft 10) request for an access token as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-4">Obtaining an Access Token</a>.
 <p>
 The {@link #AccessTokenRequest()} or
 {@link #AccessTokenRequest(HttpTransport, JsonFactory, String, String, String)} constructors may
 be used directly when no access grant is included, such as when the client is requesting access
 to the protected resources under its control. Otherwise, use one of the subclasses, which add
 custom parameters to specify the access grant. Call {@link #execute()} to execute the request and
 use the {@link AccessTokenResponse}. On error, use {@link AccessTokenErrorResponse} instead.
 <p>
 Sample usage when the client is requesting access to the protected resources under its control:

 <pre>
 <code>
  static void requestAccessToken() throws IOException {
    try {
      AccessTokenRequest request =
          new AccessTokenRequest(new NetHttpTransport(), new JacksonFactory(),
              "https://server.example.com/authorize", "s6BhdRkqt3", "gX1fBat3bV");
      AccessTokenResponse response = request.execute();
      System.out.println("Access token: " + response.accessToken);
    } catch (HttpResponseException e) {
      AccessTokenErrorResponse response = e.response.parseAs(AccessTokenErrorResponse.class);
      System.out.println("Error: " + response.error);
    }
  }
 </code>
 </pre>
 </p>

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AccessTokenRequest -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.AssertionGrant -->
  <class name="AccessTokenRequest.AssertionGrant" extends="com.google.api.client.auth.oauth2.draft10.AccessTokenRequest"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AccessTokenRequest.AssertionGrant"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AccessTokenRequest.AssertionGrant" type="com.google.api.client.http.HttpTransport, com.google.api.client.json.JsonFactory, java.lang.String, java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param transport HTTP transport for executing request in {@link #execute()}
 @param jsonFactory JSON factory to use for parsing response in {@link #execute()}
 @param authorizationServerUrl encoded authorization server URL
 @param clientSecret client secret
 @param assertionType format of the assertion as defined by the authorization server. The
        value MUST be an absolute URI
 @param assertion assertion]]>
      </doc>
    </constructor>
    <field name="assertionType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The format of the assertion as defined by the authorization server. The value MUST
 be an absolute URI.]]>
      </doc>
    </field>
    <field name="assertion" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The assertion.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 Assertion Flow: request an access token based on as assertion as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-4.1.3">Assertion</a>.
 <p>
 Sample usage:

 <pre>
 <code>
    static void requestAccessToken() throws IOException {
      try {
        AssertionGrant request = new AssertionGrant(new NetHttpTransport(),
            new JacksonFactory(),
            "https://server.example.com/authorize",
            "gX1fBat3bV",
            "urn:oasis:names:tc:SAML:2.0:",
            "PHNhbWxwOl...[omitted for brevity]...ZT4=");
        AccessTokenResponse response = request.execute();
        System.out.println("Access token: " + response.accessToken);
      } catch (HttpResponseException e) {
        AccessTokenErrorResponse response = e.response.parseAs(AccessTokenErrorResponse.class);
        System.out.println("Error: " + response.error);
      }
    }
 </code>
 </pre>
 </p>]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.AssertionGrant -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.AuthorizationCodeGrant -->
  <class name="AccessTokenRequest.AuthorizationCodeGrant" extends="com.google.api.client.auth.oauth2.draft10.AccessTokenRequest"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AccessTokenRequest.AuthorizationCodeGrant"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AccessTokenRequest.AuthorizationCodeGrant" type="com.google.api.client.http.HttpTransport, com.google.api.client.json.JsonFactory, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param transport HTTP transport for executing request in {@link #execute()}
 @param jsonFactory JSON factory to use for parsing response in {@link #execute()}
 @param authorizationServerUrl encoded authorization server URL
 @param clientId client identifier
 @param clientSecret client secret
 @param code authorization code received from the authorization server
 @param redirectUri redirection URI used in the initial request]]>
      </doc>
    </constructor>
    <field name="code" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The authorization code received from the authorization server.]]>
      </doc>
    </field>
    <field name="redirectUri" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The redirection URI used in the initial request.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 Web Server Flow: request an access token based on a verification code as specified in
 <a href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-4.1.1">Authorization
 Code</a>.
 <p>
 Sample usage:

 <pre>
 <code>
    static void requestAccessToken() throws IOException {
      try {
        AuthorizationCodeGrant request = new AuthorizationCodeGrant(new NetHttpTransport(),
            new JacksonFactory(),
            "https://server.example.com/authorize",
            "s6BhdRkqt3",
            "gX1fBat3bV",
            "i1WsRn1uB1",
            "https://client.example.com/cb");
        AccessTokenResponse response = request.execute();
        System.out.println("Access token: " + response.accessToken);
      } catch (HttpResponseException e) {
        AccessTokenErrorResponse response = e.response.parseAs(AccessTokenErrorResponse.class);
        System.out.println("Error: " + response.error);
      }
    }
 </code>
 </pre>
 </p>]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.AuthorizationCodeGrant -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.GrantType -->
  <class name="AccessTokenRequest.GrantType" extends="java.lang.Enum&lt;com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.GrantType&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.GrantType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.GrantType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Access grant type.]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.GrantType -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.RefreshTokenGrant -->
  <class name="AccessTokenRequest.RefreshTokenGrant" extends="com.google.api.client.auth.oauth2.draft10.AccessTokenRequest"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AccessTokenRequest.RefreshTokenGrant"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AccessTokenRequest.RefreshTokenGrant" type="com.google.api.client.http.HttpTransport, com.google.api.client.json.JsonFactory, java.lang.String, java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param transport HTTP transport for executing request in {@link #execute()}
 @param jsonFactory JSON factory to use for parsing response in {@link #execute()}
 @param authorizationServerUrl encoded authorization server URL
 @param clientId client identifier
 @param clientSecret client secret
 @param refreshToken refresh token associated with the access token to be refreshed]]>
      </doc>
    </constructor>
    <field name="refreshToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The refresh token associated with the access token to be refreshed.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 request to refresh an access token as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-4.1.4">Refresh Token</a>.
 <p>
 Sample usage:

 <pre>
 <code>
    static void requestAccessToken() throws IOException {
      try {
        RefreshTokenGrant request = new RefreshTokenGrant(new NetHttpTransport(),
            new JacksonFactory(),
            "https://server.example.com/authorize",
            "s6BhdRkqt3",
            "gX1fBat3bV",
            "n4E9O119d");
        AccessTokenResponse response = request.execute();
        System.out.println("Access token: " + response.accessToken);
      } catch (HttpResponseException e) {
        AccessTokenErrorResponse response = e.response.parseAs(AccessTokenErrorResponse.class);
        System.out.println("Error: " + response.error);
      }
    }
 </code>
 </pre>
 </p>]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.RefreshTokenGrant -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.ResourceOwnerPasswordCredentialsGrant -->
  <class name="AccessTokenRequest.ResourceOwnerPasswordCredentialsGrant" extends="com.google.api.client.auth.oauth2.draft10.AccessTokenRequest"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AccessTokenRequest.ResourceOwnerPasswordCredentialsGrant"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AccessTokenRequest.ResourceOwnerPasswordCredentialsGrant" type="com.google.api.client.http.HttpTransport, com.google.api.client.json.JsonFactory, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param transport HTTP transport for executing request in {@link #execute()}
 @param jsonFactory JSON factory to use for parsing response in {@link #execute()}
 @param authorizationServerUrl encoded authorization server URL
 @param clientId client identifier
 @param clientSecret client secret
 @param username resource owner's username
 @param password resource owner's password]]>
      </doc>
    </constructor>
    <field name="username" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The resource owner's username.]]>
      </doc>
    </field>
    <field name="password" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The resource owner's password.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 Username and Password Flow: request an access token based on resource owner
 credentials used in the as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-4.1.2">Resource Owner Password
 Credentials</a>.
 <p>
 Sample usage:

 <pre>
 <code>
    static void requestAccessToken() throws IOException {
      try {
        ResourceOwnerPasswordCredentialsGrant request =
            new ResourceOwnerPasswordCredentialsGrant(new NetHttpTransport(),
                new JacksonFactory(),
                "https://server.example.com/authorize",
                "s6BhdRkqt3",
                "gX1fBat3bV",
                "johndoe",
                "A3ddj3w");
        AccessTokenResponse response = request.execute();
        System.out.println("Access token: " + response.accessToken);
      } catch (HttpResponseException e) {
        AccessTokenErrorResponse response = e.response.parseAs(AccessTokenErrorResponse.class);
        System.out.println("Error: " + response.error);
      }
    }
 </code>
 </pre>
 </p>]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.ResourceOwnerPasswordCredentialsGrant -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AccessTokenResponse -->
  <class name="AccessTokenResponse" extends="com.google.api.client.util.GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AccessTokenResponse"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="accessToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The access token issued by the authorization server.]]>
      </doc>
    </field>
    <field name="expiresIn" type="java.lang.Long"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The duration in seconds of the access token lifetime. For example, the value "3600"
 denotes that the access token will expire in one hour from the time the response was generated
 by the authorization server.]]>
      </doc>
    </field>
    <field name="refreshToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The refresh token used to obtain new access tokens. The authorization server SHOULD
 NOT issue a refresh token when the access grant type is set to "none".]]>
      </doc>
    </field>
    <field name="scope" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The scope of the access token as a list of space- delimited strings. The value of
 the "scope" parameter is defined by the authorization server. If the value contains multiple
 space-delimited strings, their order does not matter, and each string adds an additional access
 range to the requested scope. The authorization server SHOULD include the parameter if the
 requested scope is different from the one requested by the client.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 (draft 10) access token success response content as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-4.2">Access Token Response</a>.
 <p>
 Use {@link AccessProtectedResource} to authorize executed HTTP requests based on the
 {@link #accessToken}.
 </p>

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AccessTokenResponse -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AuthorizationRequestUrl -->
  <class name="AuthorizationRequestUrl" extends="com.google.api.client.http.GenericUrl"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AuthorizationRequestUrl" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param encodedAuthorizationServerUrl encoded authorization server URL]]>
      </doc>
    </constructor>
    <constructor name="AuthorizationRequestUrl" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param encodedAuthorizationServerUrl encoded authorization server URL
 @param clientId client identifier]]>
      </doc>
    </constructor>
    <field name="responseType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The requested response: an access token, an authorization code, or both. The
 parameter value MUST be set to "token" for requesting an access token, "code" for requesting an
 authorization code, or "code_and_token" to request both. The authorization server MAY decline
 to provide one or more of these response types. For convenience, you may use
 {@link ResponseType} to set this value.
 <p>
 By default, the response type is {@code "code"}, but this may be overridden.
 </p>]]>
      </doc>
    </field>
    <field name="clientId" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The client identifier.]]>
      </doc>
    </field>
    <field name="redirectUri" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED, unless a redirection URI has been established between the client and authorization
 server via other means) An absolute URI to which the authorization server will redirect the
 user-agent to when the end-user authorization step is completed. The authorization server
 SHOULD require the client to pre-register their redirection URI.]]>
      </doc>
    </field>
    <field name="scope" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The scope of the access request expressed as a list of space-delimited strings. The
 value of the "scope" parameter is defined by the authorization server. If the value contains
 multiple space-delimited strings, their order does not matter, and each string adds an
 additional access range to the requested scope.]]>
      </doc>
    </field>
    <field name="state" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) An opaque value used by the client to maintain state between the request and
 callback. The authorization server includes this value when redirecting the user-agent back to
 the client.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 (draft 10) URL builder for an authorization web page to allow the end user to authorize
 the application to access their protected resources as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-3">Obtaining End-User
 Authorization</a>.
 <p>
 Use {@link AuthorizationResponse} to parse the redirect response after the end user grants/denies
 the request.
 </p>
 <p>
 Sample usage for a web application:

 <pre>
 <code>
  public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    AuthorizationRequestUrl builder =
        new AuthorizationRequestUrl(BASE_AUTHORIZATION_URL, CLIENT_ID);
    builder.redirectUri = REDIRECT_URL;
    builder.scope = SCOPE;
    response.sendRedirect(builder.build());
    return;
  }
 </code>
 </pre>

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AuthorizationRequestUrl -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AuthorizationRequestUrl.ResponseType -->
  <class name="AuthorizationRequestUrl.ResponseType" extends="java.lang.Enum&lt;com.google.api.client.auth.oauth2.draft10.AuthorizationRequestUrl.ResponseType&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.api.client.auth.oauth2.draft10.AuthorizationRequestUrl.ResponseType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.api.client.auth.oauth2.draft10.AuthorizationRequestUrl.ResponseType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="com.google.api.client.auth.oauth2.draft10.AuthorizationRequestUrl"/>
      <doc>
      <![CDATA[Sets the response type on an authorization request URL.

 @param url authorization request URL]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Response type enumeration that may be used for setting the
 {@link AuthorizationRequestUrl#responseType}.
 <p>
 Call {@link #set(AuthorizationRequestUrl)} to set the response type on an authorization request
 URL.
 </p>]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AuthorizationRequestUrl.ResponseType -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AuthorizationResponse -->
  <class name="AuthorizationResponse" extends="com.google.api.client.json.GenericJson"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AuthorizationResponse" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param redirectUrl encoded redirect URL
 @throws IllegalArgumentException URI syntax exception]]>
      </doc>
    </constructor>
    <method name="getErrorCodeIfKnown" return="com.google.api.client.auth.oauth2.draft10.AuthorizationResponse.KnownError"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a known error code if {@link #error} is one of the error codes listed in the OAuth 2
 specification or {@code null} if the {@link #error} is {@code null} or not known.]]>
      </doc>
    </method>
    <field name="code" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED if the end user grants authorization and the response type is "code" or
 "code_and_token", otherwise MUST NOT be included) The authorization code generated by the
 authorization server. The authorization code SHOULD expire shortly after it is issued. The
 authorization server MUST invalidate the authorization code after a single usage. The
 authorization code is bound to the client identifier and redirection URI.]]>
      </doc>
    </field>
    <field name="accessToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED if the end user grants authorization and the response type is "token" or
 "code_and_token", otherwise MUST NOT be included) The access token issued by the authorization
 server.]]>
      </doc>
    </field>
    <field name="expiresIn" type="java.lang.Long"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The duration in seconds of the access token lifetime if an access token is included.
 For example, the value "3600" denotes that the access token will expire in one hour from the
 time the response was generated by the authorization server.]]>
      </doc>
    </field>
    <field name="scope" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The scope of the access token as a list of space- delimited strings if an access
 token is included. The value of the "scope" parameter is defined by the authorization server.
 If the value contains multiple space-delimited strings, their order does not matter, and each
 string adds an additional access range to the requested scope. The authorization server SHOULD
 include the parameter if the requested scope is different from the one requested by the client.]]>
      </doc>
    </field>
    <field name="error" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED if the end user denies authorization) A single error code.

 @see #getErrorCodeIfKnown()]]>
      </doc>
    </field>
    <field name="errorDescription" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) A human-readable text providing additional information, used to assist in the
 understanding and resolution of the error occurred.]]>
      </doc>
    </field>
    <field name="errorUri" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) A URI identifying a human-readable web page with information about the error, used
 to provide the end-user with additional information about the error.]]>
      </doc>
    </field>
    <field name="state" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED if the "state" parameter was present in the client authorization request) Set to the
 exact value received from the client.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 (draft 10) parser for the redirect URL after end user grants or denies authorization as
 specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-3.1">Authorization Response</a>.
 <p>
 Check if {@link #error} is {@code null} to check if the end-user granted authorization.
 </p>
 <p>
 Sample usage for a web application:

 <pre><code>
  public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    StringBuffer fullUrlBuf = request.getRequestURL();
    if (request.getQueryString() != null) {
      fullUrlBuf.append('?').append(request.getQueryString());
    }
    AuthorizationResponse authResponse = new AuthorizationResponse(fullUrlBuf.toString());
    // check for user-denied error
    if (authResponse.error != null) {
      // authorization denied...
    } else {
      // request access token using authResponse.code...
    }
  }
 </code></pre>
 </p>
 <p>
 Sample usage for an installed application:

 <pre><code>
  static void processRedirectUrl(HttpTransport transport, String redirectUrl) {
    AuthorizationResponse response = new AuthorizationResponse(redirectUrl);
    if (response.error != null) {
      throw new RuntimeException("Authorization denied");
    }
    AccessProtectedResource.usingAuthorizationHeader(transport, response.accessToken);
  }
 </code></pre>
 </p>

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AuthorizationResponse -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AuthorizationResponse.KnownError -->
  <class name="AuthorizationResponse.KnownError" extends="java.lang.Enum&lt;com.google.api.client.auth.oauth2.draft10.AuthorizationResponse.KnownError&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.api.client.auth.oauth2.draft10.AuthorizationResponse.KnownError[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.api.client.auth.oauth2.draft10.AuthorizationResponse.KnownError"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Error codes listed in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-3.2.1">Error Codes</a>.]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AuthorizationResponse.KnownError -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.InstalledApp -->
  <class name="InstalledApp" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="OOB_REDIRECT_URI" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Redirect URI to use for "Out Of Band", meaning that the end-user is given an access code that
 they must then enter into the installed application.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Constants for installed (or "native") applications.

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.InstalledApp -->
</package>
<package name="com.google.api.client.extensions.appengine.auth">
  <!-- start class com.google.api.client.extensions.appengine.auth.AbstractAppEngineCallbackServlet -->
  <class name="AbstractAppEngineCallbackServlet" extends="com.google.api.client.extensions.servlet.auth.AbstractCallbackServlet"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractAppEngineCallbackServlet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getUserId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the user ID of the user that is logged in.

 @throws IllegalStateException Thrown when no user is logged in.]]>
      </doc>
    </method>
    <method name="newHttpTransportInstance" return="com.google.api.client.http.HttpTransport"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="newJsonFactoryInstance" return="com.google.api.client.json.JsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This servlet fills in some of the required information for the {@link AbstractCallbackServlet}
 with reasonable defaults for App Engine. It will default the servlet to creating
 {@link UrlFetchTransport} objects whenever an {@link HttpTransport} is needed. It will also
 default the user identifier to the logged in App Engine user. This servlet requires that the App
 Engine user must be logged in to work correctly. This can be accomplished by adding a security
 constraint in your web.xml for the path at which this servlet will live.
 <p>
 Example that requires login for all pages:

 <pre>
 <code>
  <security-constraint>
    <web-resource-collection>
      <web-resource-name>any</web-resource-name>
      <url-pattern>/*</url-pattern>
    </web-resource-collection>
    <auth-constraint>
      <role-name>*</role-name>
    </auth-constraint>
  </security-constraint>
 </code>
 </pre>

 @author moshenko@google.com (Jacob Moshenko)
 @since 1.4]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.appengine.auth.AbstractAppEngineCallbackServlet -->
  <!-- start class com.google.api.client.extensions.appengine.auth.AbstractAppEngineFlowServlet -->
  <class name="AbstractAppEngineFlowServlet" extends="com.google.api.client.extensions.servlet.auth.AbstractFlowUserServlet"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractAppEngineFlowServlet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getUserId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the user ID of the user that is logged in.

 @throws IllegalStateException Thrown when no user is logged in.]]>
      </doc>
    </method>
    <method name="newHttpTransportInstance" return="com.google.api.client.http.HttpTransport"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="newJsonFactoryInstance" return="com.google.api.client.json.JsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This class fills in some of the unknowns of the generic {@link AbstractFlowUserServlet} with
 reasonable defaults for App Engine. This servlet requires that the App Engine user must be logged
 in to work correctly.

 @author moshenko@google.com (Jacob Moshenko)
 @since 1.4]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.appengine.auth.AbstractAppEngineFlowServlet -->
</package>
<package name="com.google.api.client.extensions.appengine.http.urlfetch">
  <!-- start class com.google.api.client.extensions.appengine.http.urlfetch.UrlFetchTransport -->
  <class name="UrlFetchTransport" extends="com.google.api.client.http.HttpTransport"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="UrlFetchTransport"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="supportsHead" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="buildDeleteRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildGetRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildHeadRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildPostRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildPutRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Thread-safe HTTP transport for Google App Engine based on <a
 href="http://code.google.com/appengine/docs/java/urlfetch/">URL Fetch</a>.
 <p>
 URL Fetch is only available on Google App Engine (not on any other Java environment), and is the
 underlying HTTP transport used for App Engine. Their implementation of {@link HttpURLConnection}
 is simply an abstraction layer on top of URL Fetch. By implementing a transport that directly
 uses URL Fetch, we can optimize the behavior slightly, and can potentially take advantage of
 features in URL Fetch that are not available in {@link HttpURLConnection}. Furthermore, there is
 currently a serious bug in how HTTP headers are processed in the App Engine implementation of
 {@link HttpURLConnection}, which we are able to avoid using this implementation. Therefore, this
 is the recommended transport to use on App Engine.
 </p>

 <p>
 Upgrade warning: prior version 1.3 had a {@code deadline} field. Instead now use
 {@link HttpRequest#connectTimeout} and {@link HttpRequest#readTimeout} in an
 {@link HttpRequestInitializer} (which are simply added to determine the deadline).
 </p>

 @since 1.2
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.appengine.http.urlfetch.UrlFetchTransport -->
</package>
<package name="com.google.api.client.extensions.auth.helpers">
  <!-- start interface com.google.api.client.extensions.auth.helpers.Credential -->
  <interface name="Credential"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpRequestInitializer"/>
    <implements name="com.google.api.client.http.HttpExecuteInterceptor"/>
    <implements name="com.google.api.client.http.HttpUnsuccessfulResponseHandler"/>
    <doc>
    <![CDATA[Implementations of this class will have all of the information necessary to create and install
 the necessary handlers on an {@link HttpTransport} object to allow for a streamlined auth
 experience.

 Implementations of this interface should use the {@link PersistenceCapable} annotation to allow
 credentials to be managed on behalf of the application.

 @author moshenko@google.com (Jacob Moshenko)
 @since 1.4]]>
    </doc>
  </interface>
  <!-- end interface com.google.api.client.extensions.auth.helpers.Credential -->
  <!-- start interface com.google.api.client.extensions.auth.helpers.ThreeLeggedFlow -->
  <interface name="ThreeLeggedFlow"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getAuthorizationUrl" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[After the object is created, the developer should use this method to interrogate it for the
 authorization URL to which the user should be redirected to obtain permission.

 @return URL to which the user should be directed]]>
      </doc>
    </method>
    <method name="setHttpTransport"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transport" type="com.google.api.client.http.HttpTransport"/>
      <doc>
      <![CDATA[Set {@link HttpTransport} instance for this three legged flow.]]>
      </doc>
    </method>
    <method name="setJsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="jsonFactory" type="com.google.api.client.json.JsonFactory"/>
      <doc>
      <![CDATA[Set {@link JsonFactory} instance for this three legged flow.]]>
      </doc>
    </method>
    <method name="loadCredential" return="com.google.api.client.extensions.auth.helpers.Credential"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pm" type="PersistenceManager"/>
      <doc>
      <![CDATA[Convenience function that will load a credential based on the userId for which this flow was
 instantiated.

 @param pm {@link PersistenceManager} instance which this flow should use to interact with the
        data store. The caller must remember to call {@link PersistenceManager#close()} after
        this method returns.
 @return Fully initialized {@link Credential} object or {@code null} if none exists.]]>
      </doc>
    </method>
    <method name="complete" return="com.google.api.client.extensions.auth.helpers.Credential"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="authorizationCode" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[After the user has authorized the request, the token or code obtained should be passed to this
 complete function to allow us to exchange the code with the authentication server for a
 {@link Credential}.

 @param authorizationCode Code or token obtained after the user grants permission
 @return {@link Credential} object that is obtained from token server

 @throws IOException When an error occurs when communicating with the token server]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface for auth flows that require a user authorization step through a web browser to obtain
 an authorization code.

 <p>
 Implementations are required to be {@link PersistenceCapable} for storage in JDO compliant
 datastores during user authorization step.
 </p>

 @author moshenko@google.com (Jacob Moshenko)
 @since 1.4]]>
    </doc>
  </interface>
  <!-- end interface com.google.api.client.extensions.auth.helpers.ThreeLeggedFlow -->
</package>
<package name="com.google.api.client.extensions.auth.helpers.oauth2.draft10">
  <!-- start class com.google.api.client.extensions.auth.helpers.oauth2.draft10.OAuth2Credential -->
  <class name="OAuth2Credential" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.extensions.auth.helpers.Credential"/>
    <constructor name="OAuth2Credential" type="java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an instance of an OAuth2Credential that can be used to authorize requests on behalf of
 an end user. Once you construct the object, you must call
 {@link #initializeForRefresh(String, String, String, JsonFactory, HttpTransport)} to provide
 the necessary information to allow token refresh.

 @param userId Key that can be used to associate this Credential object with an end user.
 @param accessToken Access token that can be used to authorize this request.
 @param refreshToken Token that can be given to the token server in exchange for a new access
        token.]]>
      </doc>
    </constructor>
    <constructor name="OAuth2Credential" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an instance of an OAuth2Credential that can be used to authorize requests on behalf of
 an end user. Instances created through this constructor are not eligible for token refresh.

 @param userId Key that can be used to associate this Credential object with an end user.
 @param accessToken Access token that can be used to authorize this request.]]>
      </doc>
    </constructor>
    <method name="refresh" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transport" type="com.google.api.client.http.HttpTransport"/>
      <param name="factory" type="com.google.api.client.json.JsonFactory"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Force a refresh of this credential if possible using the {@link HttpTransport} and
 {@link JsonFactory} objects provided for the network communication.

 @param transport {@link HttpTransport} to use for the refresh
 @param factory {@link JsonFactory} to use to parse the auth response

 @return Success or failure of refresh operation

 @throws IOException When the credential can not communicate with the token server.]]>
      </doc>
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.api.client.http.HttpRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="intercept"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.api.client.http.HttpRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="handleResponse" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.api.client.http.HttpRequest"/>
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="retrySupported" type="boolean"/>
    </method>
    <method name="initializeForRefresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clientId" type="java.lang.String"/>
      <param name="clientSecret" type="java.lang.String"/>
      <param name="refreshUrl" type="java.lang.String"/>
      <param name="jsonFactory" type="com.google.api.client.json.JsonFactory"/>
      <param name="transport" type="com.google.api.client.http.HttpTransport"/>
      <doc>
      <![CDATA[Initialize the instance with the required information to allow token refresh. This must be done
 after construction or after loading the object from the data store.

 @param clientId Used to identify the client server with the token server.
 @param clientSecret Secret shared between the client server and the token server.
 @param refreshUrl Url which can be used to exchange the refresh token for a new access token.
 @param jsonFactory Json factory used to deserialize communications with the token server.
 @param transport Transport used to send requests to the token server.]]>
      </doc>
    </method>
    <method name="getAccessToken" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the current access token. This may be either the access token with which the object was
 constructed, or a token fetched through a successful refresh.]]>
      </doc>
    </method>
    <method name="getRefreshToken" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the refresh token with which this object was constructed. This can be used for out of
 band use cases, but most users should just let the credential be refreshed by the library when
 a call fails.]]>
      </doc>
    </method>
    <method name="jdoPreClear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="jdoPreDelete"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="jdoPostLoad"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="jdoPreStore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[{@link Credential} implementation that is used to authorize OAuth2 enabled requests through the
 use of the access_token header, as well as refresh the token when it is required. It is important
 that access to this class be made from within a managed JDO context and that the persistence
 manager be closed in a finally block to save any updates to the access token.

 This class is safe to use from multiple threads.

 @author moshenko@google.com (Jacob Moshenko)
 @since 1.4]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.auth.helpers.oauth2.draft10.OAuth2Credential -->
  <!-- start class com.google.api.client.extensions.auth.helpers.oauth2.draft10.OAuth2ThreeLeggedFlow -->
  <class name="OAuth2ThreeLeggedFlow" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.extensions.auth.helpers.ThreeLeggedFlow"/>
    <constructor name="OAuth2ThreeLeggedFlow" type="java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create the flow object with the information provided and create the authorization url.

 @param userId Key that will be used to associate this flow object with an end user.
 @param clientId Used to identify the client server with the token server.
 @param clientSecret Secret shared between the client server and the token server.
 @param scope OAuth2 scope or space delimited list of scopes for which we require access.
 @param callbackUrl Where the authorization should redirect the user to complete the flow.
 @param authorizationEndpoint Server to which we will redirect the user to grant authorization.
 @param tokenEndpoint Server with which we will exchange an authorization code for an access
        token.]]>
      </doc>
    </constructor>
    <method name="complete" return="com.google.api.client.extensions.auth.helpers.Credential"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="authorizationCode" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getAuthorizationUrl" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="loadCredential" return="com.google.api.client.extensions.auth.helpers.Credential"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pm" type="PersistenceManager"/>
    </method>
    <method name="setHttpTransport"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transport" type="com.google.api.client.http.HttpTransport"/>
    </method>
    <method name="setJsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="jsonFactory" type="com.google.api.client.json.JsonFactory"/>
    </method>
    <doc>
    <![CDATA[This class is designed to allow the three legged web app flow for OAuth2 to be accomplished
 easily. When the constructor is called an authorization url is generated from the provided
 information. The user should be redirected to that url for confirmation. When the code has been
 received, the flow will request the access and refresh tokens.

 <p>
 It is not safe to use one instance of this implementation from multiple threads.
 </p>

 @author moshenko@google.com (Jacob Moshenko)
 @since 1.4]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.auth.helpers.oauth2.draft10.OAuth2ThreeLeggedFlow -->
</package>
<package name="com.google.api.client.extensions.servlet.auth">
  <!-- start class com.google.api.client.extensions.servlet.auth.AbstractCallbackServlet -->
  <class name="AbstractCallbackServlet" extends="HttpServlet"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractCallbackServlet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with will ask the concrete subclass for all required information on the
 environment.]]>
      </doc>
    </constructor>
    <method name="getJsonFactory" return="com.google.api.client.json.JsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the {@link JsonFactory} instance for this servlet.]]>
      </doc>
    </method>
    <method name="getHttpTransport" return="com.google.api.client.http.HttpTransport"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the {@link HttpTransport} instance for this servlet.]]>
      </doc>
    </method>
    <method name="getPersistenceManagerFactory" return="PersistenceManagerFactory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Override with your chosen method to get a PersistenceManagerFactory. For app engine
 applications this should be a singleton.

 @return PersistenceManagerFactory instance.]]>
      </doc>
    </method>
    <method name="getConcreteFlowType" return="java.lang.Class&lt;? extends com.google.api.client.extensions.auth.helpers.ThreeLeggedFlow&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Specific ThreeLeggedFlow type that this callback should retreieve and complete.]]>
      </doc>
    </method>
    <method name="getSuccessRedirectUrl" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Url to redirect the user to upon a successful credential exchange.]]>
      </doc>
    </method>
    <method name="getDeniedRedirectUrl" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Url to redirect the user to upon failure.]]>
      </doc>
    </method>
    <method name="getCompletionCodeQueryParam" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Specific query parameter keyword to key off of to get completion code. (e.g. "code" for
         OAuth2 and "verifier" for OAuth1)]]>
      </doc>
    </method>
    <method name="getUserId" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Get a string representation of a userId that can be used to associate credentials and
         flows with a specific user.]]>
      </doc>
    </method>
    <method name="newHttpTransportInstance" return="com.google.api.client.http.HttpTransport"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link HttpTransport} instance. Implementations can create any type of applicable
 transport and should be as simple as:

 <pre>
  new NetHttpTransport();
 </pre>

 @return {@link HttpTransport} instance for your particular environment]]>
      </doc>
    </method>
    <method name="newJsonFactoryInstance" return="com.google.api.client.json.JsonFactory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link JsonFactory} instance. Implementations can create any type of applicable
 json factory and should be as simple as:

 <pre>
  new JacksonFactory();
 </pre>

 @return {@link JsonFactory} instance for your particular environment]]>
      </doc>
    </method>
    <method name="doGet"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="req" type="HttpServletRequest"/>
      <param name="resp" type="HttpServletResponse"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Callback that will retrieve and complete a {@link ThreeLeggedFlow} when redirected to by a token
 server or service provider. Developer should subclass to provide the necessary information
 tailored to their specific use case.

 @author moshenko@google.com (Jacob Moshenko)
 @since 1.4]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.servlet.auth.AbstractCallbackServlet -->
  <!-- start class com.google.api.client.extensions.servlet.auth.AbstractFlowUserServlet -->
  <class name="AbstractFlowUserServlet" extends="HttpServlet"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractFlowUserServlet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="doGet"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="req" type="HttpServletRequest"/>
      <param name="resp" type="HttpServletResponse"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getJsonFactory" return="com.google.api.client.json.JsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the {@link JsonFactory} instance for this servlet.]]>
      </doc>
    </method>
    <method name="getHttpTransport" return="com.google.api.client.http.HttpTransport"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the {@link HttpTransport} instance for this servlet.]]>
      </doc>
    </method>
    <method name="getPersistenceManagerFactory" return="PersistenceManagerFactory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Obtain a PersistenceManagerFactory for working with the datastore.

 @return PersistenceManagerFactory instance.]]>
      </doc>
    </method>
    <method name="newFlow" return="com.google.api.client.extensions.auth.helpers.ThreeLeggedFlow"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="userId" type="java.lang.String"/>
      <doc>
      <![CDATA[Create a flow object which will be used to obtain credentials

 @param userId User id to be passed to the constructor of the flow object
 @return Flow object used to obtain credentials]]>
      </doc>
    </method>
    <method name="newHttpTransportInstance" return="com.google.api.client.http.HttpTransport"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link HttpTransport} instance. Implementations can create any type of applicable
 transport and should be as simple as:

 <pre>
  new NetHttpTransport();
 </pre>

 @return {@link HttpTransport} instance for your particular environment]]>
      </doc>
    </method>
    <method name="newJsonFactoryInstance" return="com.google.api.client.json.JsonFactory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link JsonFactory} instance. Implementations can create any type of applicable
 json factory and should be as simple as:

 <pre>
  new JacksonFactory();
 </pre>

 @return {@link JsonFactory} instance for your particular environment]]>
      </doc>
    </method>
    <method name="getUserId" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Get a string representation of a userId that can be used to associate credentials and
         flows with a specific user.]]>
      </doc>
    </method>
    <method name="doGetWithCredentials"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="req" type="HttpServletRequest"/>
      <param name="resp" type="HttpServletResponse"/>
      <param name="credential" type="com.google.api.client.extensions.auth.helpers.Credential"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Entry point for user code.

 @param req Request object passed to the servlet when invoked.
 @param resp Response object passed to the servlet when invoked.
 @param credential Credential which can be used to build a request factory for authenticated
        calls.
 @throws IOException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Servlet that can be used to invoke and manage a {@link ThreeLeggedFlow} object in the App Engine
 container. Developers should subclass this to provide the necessary information for their
 specific use case.

 @author moshenko@google.com (Jacob Moshenko)
 @since 1.4]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.servlet.auth.AbstractFlowUserServlet -->
</package>
<package name="com.google.api.client.http">
  <!-- start class com.google.api.client.http.AbstractInputStreamContent -->
  <class name="AbstractInputStreamContent" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpContent"/>
    <constructor name="AbstractInputStreamContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getInputStream" return="java.io.InputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return an input stream for the specific implementation type of
 {@link AbstractInputStreamContent}. If the specific implementation will return {@code true} for
 {@link #retrySupported()} this should be a factory function which will create a new
 {@link InputStream} from the source data whenever invoked.]]>
      </doc>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getEncoding" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputStream" type="java.io.InputStream"/>
      <param name="outputStream" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes the content provided by the given source input stream into the given destination output
 stream.
 <p>
 The input stream is guaranteed to be closed at the end of the method.
 </p>
 <p>
 Sample use:

 <pre><code>
  static void downloadMedia(HttpResponse response, File file)
      throws IOException {
    FileOutputStream out = new FileOutputStream(file);
    try {
      AbstractInputStreamContent.copy(response.getContent(), out);
    } finally {
      out.close();
    }
  }
 </code></pre>
 </p>

 @param inputStream source input stream
 @param outputStream destination output stream
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <field name="type" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required content type.]]>
      </doc>
    </field>
    <field name="encoding" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Content encoding (for example {@code "gzip"}) or {@code null} for none.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Serializes HTTP request content from an input stream into an output stream.
 <p>
 The {@link #type} field is required. Subclasses should implement the {@link #getLength()},
 {@link #getInputStream()}, and {@link #retrySupported()} for their specific type of input stream.
 <p>

 @since 1.4
 @author moshenko@google.com (Jacob Moshenko)]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.AbstractInputStreamContent -->
  <!-- start class com.google.api.client.http.ByteArrayContent -->
  <class name="ByteArrayContent" extends="com.google.api.client.http.AbstractInputStreamContent"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ByteArrayContent" type="byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param array Data source for creating input streams.]]>
      </doc>
    </constructor>
    <constructor name="ByteArrayContent" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an instance from the byte contents of the string. This assumes that the string is
 encoded in UTF-8 and uses {@code Strings.toBytesUtf8()} to perform the conversion.

 @param contentString String to use as the source data for creating input streams]]>
      </doc>
    </constructor>
    <constructor name="ByteArrayContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an instance with no data.]]>
      </doc>
    </constructor>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="retrySupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInputStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Concrete implementation of {@link AbstractInputStreamContent} that generates repeatable input
 streams based on the contents of byte array.
 <p>
 The {@link #type} field is required.
 <p>
 Sample use:

 <pre>
 <code>
  static void setRequestJsonContent(HttpRequest request, String json) {
    InputStreamContent content = new ByteArrayContent(json);
    content.type = "application/json";
    request.content = content;
  }
 </code>
 </pre>

 @since 1.4
 @author moshenko@google.com (Jacob Moshenko)]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.ByteArrayContent -->
  <!-- start class com.google.api.client.http.FileContent -->
  <class name="FileContent" extends="com.google.api.client.http.AbstractInputStreamContent"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="FileContent" type="java.io.File"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param file File handle which will be used to create input streams.]]>
      </doc>
    </constructor>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="retrySupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInputStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
    </method>
    <doc>
    <![CDATA[Concrete implementation of {@link AbstractInputStreamContent} that generates repeatable input
 streams based on the contents of a file.
 <p>
 The {@link #type} fields is required.
 <p>
 Sample use:

 <pre>
 <code>
  private static void setRequestJpegContent(HttpRequest request, File jpegFile) {
    FileContent content = new FileContent(jpegFile);
    content.type = "image/jpeg";
    request.content = content;
  }
 </code>
 </pre>

 @since 1.4
 @author moshenko@google.com (Jacob Moshenko)]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.FileContent -->
  <!-- start class com.google.api.client.http.GenericUrl -->
  <class name="GenericUrl" extends="com.google.api.client.util.GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GenericUrl"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="GenericUrl" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs from an encoded URL.
 <p>
 Any known query parameters with pre-defined fields as data keys will be parsed based on their
 data type. Any unrecognized query parameter will always be parsed as a string.

 @param encodedUrl encoded URL, including any existing query parameters that should be parsed
 @throws IllegalArgumentException if URL has a syntax error]]>
      </doc>
    </constructor>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="com.google.api.client.http.GenericUrl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs the string representation of the URL, including the path specified by
 {@link #pathParts} and the query parameters specified by this generic URL.]]>
      </doc>
    </method>
    <method name="getFirst" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the first query parameter value for the given query parameter name.

 @param name query parameter name
 @return first query parameter value]]>
      </doc>
    </method>
    <method name="getAll" return="java.util.Collection&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns all query parameter values for the given query parameter name.

 @param name query parameter name
 @return unmodifiable collection of query parameter values (possibly empty)]]>
      </doc>
    </method>
    <method name="getRawPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the raw encoded path computed from the {@link #pathParts}.

 @return raw encoded path computed from the {@link #pathParts} or {@code null} if
         {@link #pathParts} is {@code null}]]>
      </doc>
    </method>
    <method name="setRawPath"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="encodedPath" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@link #pathParts} from the given raw encoded path.

 @param encodedPath raw encoded path or {@code null} to set {@link #pathParts} to {@code null}]]>
      </doc>
    </method>
    <method name="appendRawPath"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="encodedPath" type="java.lang.String"/>
      <doc>
      <![CDATA[Appends the given raw encoded path to the current {@link #pathParts}, setting field only if it
 is {@code null} or empty.
 <p>
 The last part of the {@link #pathParts} is merged with the first part of the path parts
 computed from the given encoded path. Thus, if the current raw encoded path is {@code "a"}, and
 the given encoded path is {@code "b"}, then the resulting raw encoded path is {@code "ab"}.

 @param encodedPath raw encoded path or {@code null} to ignore]]>
      </doc>
    </method>
    <method name="toPathParts" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="encodedPath" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the decoded path parts for the given encoded path.

 @param encodedPath slash-prefixed encoded path, for example {@code
        "/m8/feeds/contacts/default/full"}
 @return decoded path parts, with each part assumed to be preceded by a {@code '/'}, for example
         {@code "", "m8", "feeds", "contacts", "default", "full"}, or {@code null} for {@code
         null} or {@code ""} input]]>
      </doc>
    </method>
    <field name="scheme" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Scheme (lowercase), for example {@code "https"}.]]>
      </doc>
    </field>
    <field name="host" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Host, for example {@code "www.google.com"}.]]>
      </doc>
    </field>
    <field name="port" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Port number or {@code -1} if undefined, for example {@code 443}.]]>
      </doc>
    </field>
    <field name="pathParts" type="java.util.List&lt;java.lang.String&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Decoded path component by parts with each part separated by a {@code '/'} or {@code null} for
 none, for example {@code "/m8/feeds/contacts/default/full"} is represented by {@code "", "m8",
 "feeds", "contacts", "default", "full"}.
 <p>
 Use {@link #appendRawPath(String)} to append to the path, which ensures that no extra slash is
 added.
 </p>]]>
      </doc>
    </field>
    <field name="fragment" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Fragment component or {@code null} for none.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[URL builder in which the query parameters are specified as generic data key/value pairs, based on
 the specification <a href="http://tools.ietf.org/html/rfc3986">RFC 3986: Uniform Resource
 Identifier (URI)</a>.
 <p>
 The query parameters are specified with the data key name as the parameter name, and the data
 value as the parameter value. Subclasses can declare fields for known query parameters using the
 {@link Key} annotation. {@code null} parameter names are not allowed, but {@code null} query
 values are allowed.
 </p>
 <p>
 Query parameter values are parsed using {@link UrlEncodedParser#parse(String, Object)}.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.GenericUrl -->
  <!-- start interface com.google.api.client.http.HttpContent -->
  <interface name="HttpContent"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the content length or less than zero if not known.]]>
      </doc>
    </method>
    <method name="getEncoding" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the content encoding (for example {@code "gzip"}) or {@code null} for none.]]>
      </doc>
    </method>
    <method name="getType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the content type or {@code null} for none.]]>
      </doc>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes the content to the given output stream.]]>
      </doc>
    </method>
    <method name="retrySupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether or not retry is supported on this content type. This is a backward incompatible
 change that affects versions prior to 1.4.

 @since 1.4]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Serializes HTTP request content into an output stream.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </interface>
  <!-- end interface com.google.api.client.http.HttpContent -->
  <!-- start interface com.google.api.client.http.HttpExecuteIntercepter -->
  <interface name="HttpExecuteIntercepter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="(scheduled to be removed in 1.5) Use {@link HttpExecuteInterceptor}">
    <method name="intercept"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.api.client.http.HttpRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Invoked at the start of {@link HttpRequest#execute()}.

 @throws IOException any I/O exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[HTTP request execute intercepter invoked at the start of {@link HttpRequest#execute()}.
 <p>
 Useful for example for signing HTTP requests during authentication. Care should be taken to
 ensure that intercepters not interfere with each other since there are no guarantees regarding
 their independence. In particular, the order in which the intercepters are invoked is important.

 @since 1.0
 @author Yaniv Inbar
 @deprecated (scheduled to be removed in 1.5) Use {@link HttpExecuteInterceptor}]]>
    </doc>
  </interface>
  <!-- end interface com.google.api.client.http.HttpExecuteIntercepter -->
  <!-- start interface com.google.api.client.http.HttpExecuteInterceptor -->
  <interface name="HttpExecuteInterceptor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="intercept"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.api.client.http.HttpRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Invoked at the start of {@link HttpRequest#execute()} before executing the HTTP request.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[HTTP request execute interceptor to intercept the start of {@link HttpRequest#execute()} before
 executing the HTTP request.

 <p>
 For example, this might be used to sign a request for OAuth:
 </p>

 <pre>
  public class OAuthSigner implements HttpExecuteInterceptor {
    public void intercept(HttpRequest request) throws IOException {
      // sign request...
    }
  }
 </pre>

 <p>
 Sample usage with a request factory:
 </p>

 <pre>
  public static HttpRequestFactory createRequestFactory(HttpTransport transport) {
    final OAuthSigner signer = new OAuthSigner(...);
    return transport.createRequestFactory(new HttpRequestInitializer() {
      public void initialize(HttpRequest request) {
        request.interceptor = signer;
      }
    });
  }
 </pre>

 <p>
 If you have a custom request execute interceptor, use this more complex example:
 </p>

 <pre>
  public static HttpRequestFactory createRequestFactory(HttpTransport transport) {
    final OAuthSigner signer = new OAuthSigner(...);
    return transport.createRequestFactory(new HttpRequestInitializer() {
      public void initialize(HttpRequest request) {
        request.interceptor = new HttpExecuteInterceptor() {
          public void intercept(HttpRequest request) throws IOException {
            signer.intercept(request);
          }
        };
      }
    });
  }
 </pre>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </interface>
  <!-- end interface com.google.api.client.http.HttpExecuteInterceptor -->
  <!-- start class com.google.api.client.http.HttpHeaders -->
  <class name="HttpHeaders" extends="com.google.api.client.util.GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HttpHeaders"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="clone" return="com.google.api.client.http.HttpHeaders"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setBasicAuthentication"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="username" type="java.lang.String"/>
      <param name="password" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@link #authorization} header as specified in <a
 href="http://tools.ietf.org/html/rfc2617#section-2">Basic Authentication Scheme</a>.

 @since 1.2]]>
      </doc>
    </method>
    <method name="canonicalMap" return="java.util.Map&lt;java.lang.String, java.util.Collection&lt;java.lang.Object&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.5)">
      <doc>
      <![CDATA[Computes a canonical map from lower-case header name to its values.

 @return canonical map from lower-case header name to its values
 @deprecated (scheduled to be removed in 1.5)]]>
      </doc>
    </method>
    <field name="accept" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Accept"} header.]]>
      </doc>
    </field>
    <field name="acceptEncoding" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Accept-Encoding"} header. By default, this is {@code "gzip"}.]]>
      </doc>
    </field>
    <field name="authorization" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Authorization"} header.]]>
      </doc>
    </field>
    <field name="cacheControl" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Cache-Control"} header.]]>
      </doc>
    </field>
    <field name="contentEncoding" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Content-Encoding"} header.]]>
      </doc>
    </field>
    <field name="contentLength" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Content-Length"} header.]]>
      </doc>
    </field>
    <field name="contentMD5" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Content-MD5"} header.]]>
      </doc>
    </field>
    <field name="contentRange" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Content-Range"} header.]]>
      </doc>
    </field>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Content-Type"} header.]]>
      </doc>
    </field>
    <field name="date" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Date"} header.]]>
      </doc>
    </field>
    <field name="etag" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "ETag"} header.]]>
      </doc>
    </field>
    <field name="expires" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Expires"} header.]]>
      </doc>
    </field>
    <field name="ifModifiedSince" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "If-Modified-Since"} header.]]>
      </doc>
    </field>
    <field name="ifMatch" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "If-Match"} header.]]>
      </doc>
    </field>
    <field name="ifNoneMatch" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "If-None-Match"} header.]]>
      </doc>
    </field>
    <field name="ifUnmodifiedSince" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "If-Unmodified-Since"} header.]]>
      </doc>
    </field>
    <field name="lastModified" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Last-Modified"} header.]]>
      </doc>
    </field>
    <field name="location" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Location"} header.]]>
      </doc>
    </field>
    <field name="mimeVersion" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "MIME-Version"} header.]]>
      </doc>
    </field>
    <field name="range" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Range"} header.]]>
      </doc>
    </field>
    <field name="retryAfter" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Retry-After"} header.]]>
      </doc>
    </field>
    <field name="userAgent" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "User-Agent"} header.]]>
      </doc>
    </field>
    <field name="authenticate" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "WWW-Authenticate"} header.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Stores HTTP headers used in an HTTP request or response, as defined in <a
 href="http://tools.ietf.org/html/rfc2616#section-14">Header Field Definitions</a>.
 <p>
 {@code null} is not allowed as a name or value of a header. Names are case-insensitive.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.HttpHeaders -->
  <!-- start class com.google.api.client.http.HttpMethod -->
  <class name="HttpMethod" extends="java.lang.Enum&lt;com.google.api.client.http.HttpMethod&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.api.client.http.HttpMethod[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.api.client.http.HttpMethod"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[HTTP request method.

 @since 1.3
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.HttpMethod -->
  <!-- start interface com.google.api.client.http.HttpParser -->
  <interface name="HttpParser"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getContentType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the content type.]]>
      </doc>
    </method>
    <method name="parse" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="dataClass" type="java.lang.Class&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parses the given HTTP response into a new instance of the the given data class of key/value
 pairs.
 <p>
 How the parsing is performed is not restricted by this interface, and is instead defined by the
 concrete implementation. Implementations should check {@link HttpResponse#isSuccessStatusCode}
 to know whether they are parsing a success or error response.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Parses HTTP response content into an data class of key/value pairs.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </interface>
  <!-- end interface com.google.api.client.http.HttpParser -->
  <!-- start class com.google.api.client.http.HttpRequest -->
  <class name="HttpRequest" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="setUrl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.5) Use {@link GenericUrl#GenericUrl(String)}">
      <param name="encodedUrl" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@link #url} based on the given encoded URL string.

 @deprecated (scheduled to be removed in 1.5) Use {@link GenericUrl#GenericUrl(String)}]]>
      </doc>
    </method>
    <method name="addParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parser" type="com.google.api.client.http.HttpParser"/>
      <doc>
      <![CDATA[Adds an HTTP response content parser.
 <p>
 If there is already a previous parser defined for this new parser (as defined by
 {@link #getParser(String)} then the previous parser will be removed.
 </p>

 @since 1.4]]>
      </doc>
    </method>
    <method name="getParser" return="com.google.api.client.http.HttpParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="contentType" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the HTTP response content parser to use for the given content type or {@code null} if
 none is defined.

 @param contentType content type or {@code null} for {@code null} result
 @return HTTP response content parser or {@code null} for {@code null} input
 @since 1.4]]>
      </doc>
    </method>
    <method name="execute" return="com.google.api.client.http.HttpResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Execute the HTTP request and returns the HTTP response.
 <p>
 Note that regardless of the returned status code, the HTTP response content has not been parsed
 yet, and must be parsed by the calling code.
 <p>
 Almost all details of the request and response are logged if {@link Level#CONFIG} is loggable.
 The only exception is the value of the {@code Authorization} header which is only logged if
 {@link Level#ALL} is loggable.

 @return HTTP response for an HTTP success code
 @throws HttpResponseException for an HTTP error code
 @see HttpResponse#isSuccessStatusCode]]>
      </doc>
    </method>
    <method name="normalizeMediaType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mediaType" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the normalized media type without parameters of the form {@code type "/" subtype"} as
 specified in <a href="http://tools.ietf.org/html/rfc2616#section-3.7">Media Types</a>.

 @param mediaType unnormalized media type with possible parameters or {@code null} for {@code
        null} result
 @return normalized media type without parameters or {@code null} for {@code null} input
 @since 1.4]]>
      </doc>
    </method>
    <field name="USER_AGENT_SUFFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[User agent suffix for all requests.

 @since 1.4]]>
      </doc>
    </field>
    <field name="interceptor" type="com.google.api.client.http.HttpExecuteInterceptor"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP request execute interceptor to intercept the start of {@link #execute()} (before executing
 the HTTP request) or {@code null} for none.

 @since 1.4]]>
      </doc>
    </field>
    <field name="headers" type="com.google.api.client.http.HttpHeaders"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP request headers.
 <p>
 For backwards compatibility, its value is initialized by calling {@code clone()} on the
 {@link HttpTransport#defaultHeaders}, which by default is an instance of {@link HttpHeaders}.
 </p>]]>
      </doc>
    </field>
    <field name="responseHeaders" type="com.google.api.client.http.HttpHeaders"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP response headers.
 <p>
 For example, this can be used if you want to use a subclass of {@link HttpHeaders} called
 MyHeaders to process the response:
 </p>

 <pre>
  static String executeAndGetValueOfSomeCustomHeader(HttpRequest request) {
    MyHeaders responseHeaders = new MyHeaders();
    request.responseHeaders = responseHeaders;
    HttpResponse response = request.execute();
    return responseHeaders.someCustomHeader;
  }
 </pre>
 <p>
 For backwards compatibility, its value is initialized by calling {@code clone()} on the
 {@link HttpTransport#defaultHeaders}, which by default is an instance of {@link HttpHeaders}.
 </p>

 @since 1.4]]>
      </doc>
    </field>
    <field name="numRetries" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Set the number of retries that will be allowed to execute as the result of an
 {@link HttpUnsuccessfulResponseHandler} before being terminated or {@code 0} to not retry
 requests. The default value is {@code 10}.

 @since 1.4]]>
      </doc>
    </field>
    <field name="disableContentLogging" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether to disable request content logging during {@link #execute()} (unless {@link Level#ALL}
 is loggable which forces all logging).
 <p>
 Useful for example if content has sensitive data such as an authentication information.
 Defaults to {@code false}.]]>
      </doc>
    </field>
    <field name="content" type="com.google.api.client.http.HttpContent"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP request content or {@code null} for none.]]>
      </doc>
    </field>
    <field name="transport" type="com.google.api.client.http.HttpTransport"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP transport.]]>
      </doc>
    </field>
    <field name="method" type="com.google.api.client.http.HttpMethod"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP request method.

 @since 1.3]]>
      </doc>
    </field>
    <field name="url" type="com.google.api.client.http.GenericUrl"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP request URL.]]>
      </doc>
    </field>
    <field name="connectTimeout" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Timeout in milliseconds to establish a connection or {@code 0} for an infinite timeout.
 <p>
 By default it is 20 seconds.
 </p>

 @since 1.4]]>
      </doc>
    </field>
    <field name="readTimeout" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Timeout in milliseconds to read data from an established connection or {@code 0} for an
 infinite timeout.
 <p>
 By default it is 20 seconds.
 </p>

 @since 1.4]]>
      </doc>
    </field>
    <field name="unsuccessfulResponseHandler" type="com.google.api.client.http.HttpUnsuccessfulResponseHandler"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP unsuccessful (non-2XX) response handler.

 @since 1.4]]>
      </doc>
    </field>
    <field name="enableGZipContent" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether to enable gzip compression of HTTP content ({@code false} by default).

 <p>
 Upgrade warning: in prior version 1.3, gzip compression was enabled whenever the content length
 was >= 256 bytes, the content type was text-based ("text/*" or "application/*"), and there was
 no encoding defined. With version 1.4, the decision is entirely based on this field.
 </p>

 @since 1.4]]>
      </doc>
    </field>
    <doc>
    <![CDATA[HTTP request.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.HttpRequest -->
  <!-- start class com.google.api.client.http.HttpRequestFactory -->
  <class name="HttpRequestFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="buildRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="method" type="com.google.api.client.http.HttpMethod"/>
      <param name="url" type="com.google.api.client.http.GenericUrl"/>
      <param name="content" type="com.google.api.client.http.HttpContent"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a request for the given HTTP method, URL, and content.

 @param method HTTP request method
 @param url HTTP request URL or {@code null} for none
 @param content HTTP request content or {@code null} for none
 @return new HTTP request]]>
      </doc>
    </method>
    <method name="buildDeleteRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="com.google.api.client.http.GenericUrl"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code DELETE} request for the given URL.

 @param url HTTP request URL or {@code null} for none
 @return new HTTP request]]>
      </doc>
    </method>
    <method name="buildGetRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="com.google.api.client.http.GenericUrl"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code GET} request for the given URL.

 @param url HTTP request URL or {@code null} for none
 @return new HTTP request]]>
      </doc>
    </method>
    <method name="buildPostRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="com.google.api.client.http.GenericUrl"/>
      <param name="content" type="com.google.api.client.http.HttpContent"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code POST} request for the given URL and content.

 @param url HTTP request URL or {@code null} for none
 @param content HTTP request content or {@code null} for none
 @return new HTTP request]]>
      </doc>
    </method>
    <method name="buildPutRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="com.google.api.client.http.GenericUrl"/>
      <param name="content" type="com.google.api.client.http.HttpContent"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code PUT} request for the given URL and content.

 @param url HTTP request URL or {@code null} for none
 @param content HTTP request content or {@code null} for none
 @return new HTTP request]]>
      </doc>
    </method>
    <method name="buildPatchRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="com.google.api.client.http.GenericUrl"/>
      <param name="content" type="com.google.api.client.http.HttpContent"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code PATCH} request for the given URL and content.

 @param url HTTP request URL or {@code null} for none
 @param content HTTP request content or {@code null} for none
 @return new HTTP request]]>
      </doc>
    </method>
    <method name="buildHeadRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="com.google.api.client.http.GenericUrl"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code HEAD} request for the given URL.

 @param url HTTP request URL or {@code null} for none
 @return new HTTP request]]>
      </doc>
    </method>
    <field name="transport" type="com.google.api.client.http.HttpTransport"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP transport.]]>
      </doc>
    </field>
    <field name="initializer" type="com.google.api.client.http.HttpRequestInitializer"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP request initializer or {@code null} for none.

 <p>
 This initializer is invoked before setting its {@link HttpRequest#method},
 {@link HttpRequest#url}, or {@link HttpRequest#content}.
 </p>]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Thread-safe light-weight HTTP request factory layer on top of the HTTP transport that has an
 optional {@link HttpRequestInitializer HTTP request initializer} for initializing requests.

 <p>
 For example, to use a particular authorization header across all requests, use:
 </p>

 <pre>
  public static HttpRequestFactory createRequestFactory(HttpTransport transport) {
    return transport.createRequestFactory(new HttpRequestInitializer() {
      public void handle(HttpRequest request) {
        request.headers.authorization = "...";
      }
    });
  }
 </pre>

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.HttpRequestFactory -->
  <!-- start interface com.google.api.client.http.HttpRequestInitializer -->
  <interface name="HttpRequestInitializer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.api.client.http.HttpRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Initializes a request.

 @param request HTTP request]]>
      </doc>
    </method>
    <doc>
    <![CDATA[HTTP request initializer.

 <p>
 For example, this might be used to disable request timeouts:
 </p>

 <pre>
  public class DisableTimeout implements HttpRequestInitializer {
    public void initialize(HttpRequest request) {
      request.connectTimeout = request.readTimeout = 0;
    }
  }
 </pre>

 <p>
 Sample usage with a request factory:
 </p>

 <pre>
  public static HttpRequestFactory createRequestFactory(HttpTransport transport) {
    return transport.createRequestFactory(new DisableTimeout());
  }
 </pre>

 <p>
 If you have a custom request initializer, use this more complex example:
 </p>

 <pre>
  public static HttpRequestFactory createRequestFactory(HttpTransport transport) {
    final DisableTimeout disableTimeout = new DisableTimeout();
    return transport.createRequestFactory(new HttpRequestInitializer() {
      public void initialize(HttpRequest request) {
        disableTimeout.initialize(request);
      }
    });
  }
 </pre>

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </interface>
  <!-- end interface com.google.api.client.http.HttpRequestInitializer -->
  <!-- start class com.google.api.client.http.HttpResponse -->
  <class name="HttpResponse" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getContent" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the content of the HTTP response.
 <p>
 The result is cached, so subsequent calls will be fast.

 @return input stream content of the HTTP response or {@code null} for none
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="ignore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Closes the the content of the HTTP response from {@link #getContent()}, ignoring any content.]]>
      </doc>
    </method>
    <method name="disconnect"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Disconnect using {@link LowLevelHttpResponse#disconnect()}.

 @since 1.4]]>
      </doc>
    </method>
    <method name="getParser" return="com.google.api.client.http.HttpParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the HTTP response content parser to use for the content type of this HTTP response or
 {@code null} for none.]]>
      </doc>
    </method>
    <method name="parseAs" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dataClass" type="java.lang.Class&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parses the content of the HTTP response from {@link #getContent()} and reads it into a data
 class of key/value pairs using the parser returned by {@link #getParser()} .

 @return parsed data class or {@code null} for no content
 @throws IOException I/O exception
 @throws IllegalArgumentException if no parser is defined for the given content type or if there
         is no content type defined in the HTTP response]]>
      </doc>
    </method>
    <method name="parseAsString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parses the content of the HTTP response from {@link #getContent()} and reads it into a string.
 <p>
 Since this method returns {@code ""} for no content, a simpler check for no content is to check
 if {@link #getContent()} is {@code null}.

 @return parsed string or {@code ""} for no content
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="isSuccessStatusCode" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statusCode" type="int"/>
      <doc>
      <![CDATA[Returns whether the given HTTP response status code is a success code {@code >= 200 and < 300}.]]>
      </doc>
    </method>
    <field name="contentEncoding" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Content encoding or {@code null}.]]>
      </doc>
    </field>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Content type or {@code null} for none.]]>
      </doc>
    </field>
    <field name="headers" type="com.google.api.client.http.HttpHeaders"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP headers.
 <p>
 If a header name is used for multiple headers, only the last one is retained. The value is
 initialized to {@link HttpRequest#responseHeaders} before being parsed from the actual HTTP
 response headers.
 <p>]]>
      </doc>
    </field>
    <field name="isSuccessStatusCode" type="boolean"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether received a successful status code {@code >= 200 && < 300}.]]>
      </doc>
    </field>
    <field name="statusCode" type="int"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Status code.]]>
      </doc>
    </field>
    <field name="statusMessage" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Status message or {@code null}.]]>
      </doc>
    </field>
    <field name="transport" type="com.google.api.client.http.HttpTransport"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP transport.]]>
      </doc>
    </field>
    <field name="request" type="com.google.api.client.http.HttpRequest"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP request.

 @since 1.4]]>
      </doc>
    </field>
    <field name="disableContentLogging" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether to disable response content logging during {@link #getContent()} (unless
 {@link Level#ALL} is loggable which forces all logging).
 <p>
 Useful for example if content has sensitive data such as an authentication token. Defaults to
 {@code false}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[HTTP response.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.HttpResponse -->
  <!-- start class com.google.api.client.http.HttpResponseException -->
  <class name="HttpResponseException" extends="java.io.IOException"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="HttpResponseException" type="com.google.api.client.http.HttpResponse"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param response HTTP response]]>
      </doc>
    </constructor>
    <method name="computeMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <doc>
      <![CDATA[Returns an exception message to use for the given HTTP response.]]>
      </doc>
    </method>
    <field name="response" type="com.google.api.client.http.HttpResponse"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP response.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Exception thrown when an error status code is detected in an HTTP response.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.HttpResponseException -->
  <!-- start class com.google.api.client.http.HttpTransport -->
  <class name="HttpTransport" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HttpTransport"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createRequestFactory" return="com.google.api.client.http.HttpRequestFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new instance of an HTTP request factory based on this HTTP transport.

 @return new instance of an HTTP request factory
 @since 1.4]]>
      </doc>
    </method>
    <method name="createRequestFactory" return="com.google.api.client.http.HttpRequestFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="initializer" type="com.google.api.client.http.HttpRequestInitializer"/>
      <doc>
      <![CDATA[Returns a new instance of an HTTP request factory based on this HTTP transport with the given
 HTTP request initializer.

 @param initializer HTTP request initializer or {@code null} for none
 @return new instance of an HTTP request factory
 @since 1.4]]>
      </doc>
    </method>
    <method name="addParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be removed in 1.5) Use {@link HttpRequest#addParser(HttpParser)} in
             an {@link HttpRequestInitializer}">
      <param name="parser" type="com.google.api.client.http.HttpParser"/>
      <doc>
      <![CDATA[Adds an HTTP response content parser.
 <p>
 If there is already a previous parser defined for this new parser (as defined by
 {@link #getParser(String)} then the previous parser will be removed.

 @deprecated (scheduled to be removed in 1.5) Use {@link HttpRequest#addParser(HttpParser)} in
             an {@link HttpRequestInitializer}]]>
      </doc>
    </method>
    <method name="getParser" return="com.google.api.client.http.HttpParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be removed in 1.5) Use {@link HttpRequest#getParser(String)} in an
             {@link HttpRequestInitializer}">
      <param name="contentType" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the HTTP response content parser to use for the given content type or {@code null} if
 none is defined.

 @param contentType content type or {@code null} for {@code null} result
 @deprecated (scheduled to be removed in 1.5) Use {@link HttpRequest#getParser(String)} in an
             {@link HttpRequestInitializer}]]>
      </doc>
    </method>
    <method name="buildRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be made package private in 1.5) Use
             {@link HttpRequestFactory#buildRequest(HttpMethod, GenericUrl, HttpContent)}">
      <doc>
      <![CDATA[Builds a request without specifying the HTTP method.

 @return new HTTP request
 @deprecated (scheduled to be made package private in 1.5) Use
             {@link HttpRequestFactory#buildRequest(HttpMethod, GenericUrl, HttpContent)}]]>
      </doc>
    </method>
    <method name="buildDeleteRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be removed in 1.5) Use
             {@link HttpRequestFactory#buildDeleteRequest(GenericUrl)}">
      <doc>
      <![CDATA[Builds a {@code DELETE} request.

 @deprecated (scheduled to be removed in 1.5) Use
             {@link HttpRequestFactory#buildDeleteRequest(GenericUrl)}]]>
      </doc>
    </method>
    <method name="buildGetRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be removed in 1.5) Use
             {@link HttpRequestFactory#buildGetRequest(GenericUrl)}">
      <doc>
      <![CDATA[Builds a {@code GET} request.

 @deprecated (scheduled to be removed in 1.5) Use
             {@link HttpRequestFactory#buildGetRequest(GenericUrl)}]]>
      </doc>
    </method>
    <method name="buildPostRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be removed in 1.5) Use
             {@link HttpRequestFactory#buildPostRequest(GenericUrl, HttpContent)}">
      <doc>
      <![CDATA[Builds a {@code POST} request.

 @deprecated (scheduled to be removed in 1.5) Use
             {@link HttpRequestFactory#buildPostRequest(GenericUrl, HttpContent)}]]>
      </doc>
    </method>
    <method name="buildPutRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be removed in 1.5) Use
             {@link HttpRequestFactory#buildPutRequest(GenericUrl, HttpContent)}">
      <doc>
      <![CDATA[Builds a {@code PUT} request.

 @deprecated (scheduled to be removed in 1.5) Use
             {@link HttpRequestFactory#buildPutRequest(GenericUrl, HttpContent)}]]>
      </doc>
    </method>
    <method name="buildPatchRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be removed in 1.5) Use
             {@link HttpRequestFactory#buildPatchRequest(GenericUrl, HttpContent)}">
      <doc>
      <![CDATA[Builds a {@code PATCH} request.

 @deprecated (scheduled to be removed in 1.5) Use
             {@link HttpRequestFactory#buildPatchRequest(GenericUrl, HttpContent)}]]>
      </doc>
    </method>
    <method name="buildHeadRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be removed in 1.5) Use
             {@link HttpRequestFactory#buildHeadRequest(GenericUrl)}">
      <doc>
      <![CDATA[Builds a {@code HEAD} request.

 @deprecated (scheduled to be removed in 1.5) Use
             {@link HttpRequestFactory#buildHeadRequest(GenericUrl)}]]>
      </doc>
    </method>
    <method name="removeIntercepters"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be removed in 1.5) Use {@link HttpRequest#interceptor}">
      <param name="intercepterClass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Removes HTTP request execute intercepters of the given class or subclasses.

 @param intercepterClass intercepter class
 @deprecated (scheduled to be removed in 1.5) Use {@link HttpRequest#interceptor}]]>
      </doc>
    </method>
    <method name="supportsHead" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether this HTTP transport implementation supports the {@code HEAD} request method.
 <p>
 Default implementation returns {@code false}.
 </p>

 @since 1.3]]>
      </doc>
    </method>
    <method name="supportsPatch" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether this HTTP transport implementation supports the {@code PATCH} request method.
 <p>
 Default implementation returns {@code false}.
 </p>

 @since 1.3]]>
      </doc>
    </method>
    <method name="buildDeleteRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code DELETE} request.

 @param url URL
 @throws IOException I/O exception
 @since 1.3]]>
      </doc>
    </method>
    <method name="buildGetRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code GET} request.

 @param url URL
 @throws IOException I/O exception
 @since 1.3]]>
      </doc>
    </method>
    <method name="buildHeadRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code HEAD} request. Won't be called if {@link #supportsHead()} returns {@code false}
 .
 <p>
 Default implementation throws an {@link UnsupportedOperationException}.

 @param url URL
 @throws IOException I/O exception
 @since 1.3]]>
      </doc>
    </method>
    <method name="buildPatchRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code PATCH} request. Won't be called if {@link #supportsPatch()} returns {@code
 false}.
 <p>
 Default implementation throws an {@link UnsupportedOperationException}.

 @param url URL
 @throws IOException I/O exception
 @since 1.3]]>
      </doc>
    </method>
    <method name="buildPostRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code POST} request.

 @param url URL
 @throws IOException I/O exception
 @since 1.3]]>
      </doc>
    </method>
    <method name="buildPutRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code PUT} request.

 @param url URL
 @throws IOException I/O exception
 @since 1.3]]>
      </doc>
    </method>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Default implementation does nothing, but subclasses may override to possibly release allocated
 system resources or close connections.

 @throws IOException I/O exception
 @since 1.4]]>
      </doc>
    </method>
    <field name="defaultHeaders" type="com.google.api.client.http.HttpHeaders"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.5) Use {@link HttpRequest#headers} in an
             {@link HttpRequestInitializer}">
      <doc>
      <![CDATA[Default HTTP headers. These transport default headers are put into a request's headers when its
 build method is called.

 @deprecated (scheduled to be removed in 1.5) Use {@link HttpRequest#headers} in an
             {@link HttpRequestInitializer}]]>
      </doc>
    </field>
    <field name="intercepters" type="java.util.List&lt;com.google.api.client.http.HttpExecuteIntercepter&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.5) Use {@link HttpRequest#interceptor}">
      <doc>
      <![CDATA[HTTP request execute intercepters. The intercepters will be invoked in the order of the
 {@link List#iterator()}.

 @deprecated (scheduled to be removed in 1.5) Use {@link HttpRequest#interceptor}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Thread-safe abstract HTTP transport.

 <p>
 The recommended concrete implementation HTTP transport library to use depends on what environment
 you are running in:
 </p>
 <ul>
 <li>Google App Engine: use {@code com.google.api.client.appengine.UrlFetchTransport}.
 <ul>
 <li>{@code com.google.api.client.apache.ApacheHttpTransport} doesn't work on App Engine because
 the Apache HTTP Client opens its own sockets (though in theory there are ways to hack it to work
 on App Engine that might work).</li>
 <li>{@code com.google.api.client.javanet.NetHttpTransport} is discouraged due to a bug in the App
 Engine SDK itself in how it parses HTTP headers in the response.</li>
 </ul>
 </li>
 <li>Android:
 <ul>
 <li>Starting with SDK 2.3, strongly recommended to use {@code
 com.google.api.client.javanet.NetHttpTransport}. Their Apache HTTP Client implementation is not
 as well maintained.</li>
 <li>For SDK 2.2 and earlier, use {@code com.google.api.client.apache.ApacheHttpTransport}. {@code
 com.google.api.client.javanet.NetHttpTransport} is not recommended due to some bugs in the
 Android SDK implementation of HttpURLConnection.</li>
 </ul>
 </li>
 <li>Other Java environments
 <ul>
 <li>{@code com.google.api.client.javanet.NetHttpTransport} is based on the HttpURLConnection
 built into the Java SDK, so it is normally the preferred choice.</li>
 <li>{@code com.google.api.client.apache.ApacheHttpTransport} is a good choice for users of the
 Apache HTTP Client, especially if you need some of the configuration options available in that
 library.</li>
 </ul>
 </li>
 </ul>
 <p>
 Upgrade warning: users of prior version 1.3 can continue to use the deprecated fields and methods
 in this class. However, that invalidates the thread safety claims on this class, thus making this
 class potentially unsafe to share between threads.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.HttpTransport -->
  <!-- start interface com.google.api.client.http.HttpUnsuccessfulResponseHandler -->
  <interface name="HttpUnsuccessfulResponseHandler"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="handleResponse" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.api.client.http.HttpRequest"/>
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="retrySupported" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Handler that will be invoked when an abnormal response is received. There are a few simple
 rules that one must follow:
 <ul>
 <li>If you modify the request object or modify its execute interceptors in a way that should
 resolve the error, you must return true to issue a retry.</li>
 <li>Do not read from the content stream, this will prevent the eventual end user from having
 access to it.</li>
 </ul>

 @param request Request object that can be read from for context or modified before retry
 @param response Response to process
 @param retrySupported Whether there will actually be a retry if this handler return {@code
        true}. Some handlers may want to have an effect only when there will actually be a retry
        after they handle their event (e.g. a handler that implements exponential backoff).
 @return Whether or not this handler has made a change that will require the request to be
         re-sent.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface which handles abnormal HTTP responses (in other words not 2XX).

 <p>
 For example, this might be used to refresh an OAuth 2 token:
 </p>

 <pre>
  public static class RefreshTokenHandler implements HttpUnsuccessfulResponseHandler {
    public boolean handleResponse(
        HttpRequest request, HttpResponse response, boolean retrySupported) throws IOException {
      if (response.statusCode == 401) {
        refreshToken();
      }
      return false;
    }
  }
 </pre>

 <p>
 Sample usage with a request factory:
 </p>

 <pre>
  public static HttpRequestFactory createRequestFactory(HttpTransport transport) {
    final RefreshTokenHandler handler = new RefreshTokenHandler();
    return transport.createRequestFactory(new HttpRequestInitializer() {
      public void initialize(HttpRequest request) {
        request.unsuccessfulResponseHandler = handler;
      }
    });
  }
 </pre>

 <p>
 If you have a custom unsuccessful response handler, use this more complex example:
 </p>

 <pre>
  public static HttpRequestFactory createRequestFactory(HttpTransport transport) {
    final RefreshTokenHandler handler = new RefreshTokenHandler();
    return transport.createRequestFactory(new HttpRequestInitializer() {
      public void initialize(HttpRequest request) {
        request.unsuccessfulResponseHandler = new HttpUnsuccessfulResponseHandler() {
          public boolean handleResponse(
              HttpRequest request, HttpResponse response, boolean retrySupported)
              throws IOException {
            return handler.handleResponse(request, response, retrySupported);
          }
        };
      }
    });
  }
 </pre>

 @author moshenko@google.com (Jacob Moshenko)
 @since 1.4]]>
    </doc>
  </interface>
  <!-- end interface com.google.api.client.http.HttpUnsuccessfulResponseHandler -->
  <!-- start class com.google.api.client.http.InputStreamContent -->
  <class name="InputStreamContent" extends="com.google.api.client.http.AbstractInputStreamContent"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="InputStreamContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setFileInput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Scheduled for removal in 1.5. Please use {@link FileContent} instead.">
      <param name="file" type="java.io.File"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <doc>
      <![CDATA[Sets the {@link #inputStream} from a file input stream based on the given file, and the
 {@link #length} based on the file's length.
 <p>
 Sample use:

 <pre>
 <code>
  private static void setRequestJpegContent(HttpRequest request, File jpegFile)
      throws FileNotFoundException {
    InputStreamContent content = new InputStreamContent();
    content.setFileInput(jpegFile);
    content.type = "image/jpeg";
    request.content = content;
  }
 </code>
 </pre>

 @deprecated Scheduled for removal in 1.5. Please use {@link FileContent} instead.]]>
      </doc>
    </method>
    <method name="setByteArrayInput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Scheduled for removal in 1.5. Please use {@link ByteArrayContent} instead.">
      <param name="content" type="byte[]"/>
      <doc>
      <![CDATA[Sets the {@link #inputStream} and {@link #length} from the given byte array.
 <p>
 For string input, call the appropriate {@link String#getBytes} method.
 <p>
 Sample use:

 <pre>
 <code>
  static void setRequestJsonContent(HttpRequest request, String json) {
    InputStreamContent content = new InputStreamContent();
    content.setByteArrayInput(Strings.toBytesUtf8(json));
    content.type = "application/json";
    request.content = content;
  }
 </code>
 </pre>

 @deprecated Scheduled for removal in 1.5. Please use {@link ByteArrayContent} instead.]]>
      </doc>
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="retrySupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInputStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Scheduled for removal in version 1.5. Please use
             {@link AbstractInputStreamContent#copy} as an alternative.">
      <param name="inputStream" type="java.io.InputStream"/>
      <param name="outputStream" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes the content provided by the given source input stream into the given destination output
 stream.
 <p>
 The input stream is guaranteed to be closed at the end of the method.
 </p>
 <p>
 Sample use:

 <pre><code>
    static void downloadMedia(HttpResponse response, File file)
        throws IOException {
      FileOutputStream out = new FileOutputStream(file);
      try {
        InputStreamContent.copy(response.getContent(), out);
      } finally {
        out.close();
      }
     }
 </code></pre>
 </p>

 @param inputStream source input stream
 @param outputStream destination output stream
 @throws IOException I/O exception

 @deprecated Scheduled for removal in version 1.5. Please use
             {@link AbstractInputStreamContent#copy} as an alternative.]]>
      </doc>
    </method>
    <field name="length" type="long"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Content length or less than zero if not known. Defaults to {@code -1}.]]>
      </doc>
    </field>
    <field name="inputStream" type="java.io.InputStream"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required input stream to read from.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Concrete implementation of {@link AbstractInputStreamContent} that simply handles the transfer of
 data from an input stream to an output stream. This should only be used for streams that can not
 be re-opened and retried. If you have a stream that it is possible to recreate please create a
 new subclass of {@link AbstractInputStreamContent}.
 <p>
 The {@link #type} field is required. The input stream is guaranteed to be closed at the end of
 {@link #writeTo(OutputStream)}.
 <p>
 Sample use with a URL:

 <pre>
 <code>
  private static void setRequestJpegContent(HttpRequest request, URL jpegUrl) throws IOException {
    InputStreamContent content = new InputStreamContent();
    content.inputStream = jpegUrl.openStream();
    content.type = "image/jpeg";
    request.content = content;
  }
 </code>
 </pre>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.InputStreamContent -->
  <!-- start class com.google.api.client.http.LowLevelHttpRequest -->
  <class name="LowLevelHttpRequest" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LowLevelHttpRequest"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="addHeader"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds a header to the HTTP request.
 <p>
 Note that multiple headers of the same name need to be supported, in which case
 {@link #addHeader} will be called for each instance of the header.

 @param name header name
 @param value header value]]>
      </doc>
    </method>
    <method name="setContent"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="content" type="com.google.api.client.http.HttpContent"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Sets the HTTP request content.

 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="setTimeout"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="connectTimeout" type="int"/>
      <param name="readTimeout" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Sets the connection and read timeouts.

 <p>
 Default implementation does nothing, but subclasses should normally override.
 </p>

 @param connectTimeout timeout in milliseconds to establish a connection or {@code 0} for an
        infinite timeout
 @param readTimeout Timeout in milliseconds to read data from an established connection or
        {@code 0} for an infinite timeout
 @since 1.4]]>
      </doc>
    </method>
    <method name="execute" return="com.google.api.client.http.LowLevelHttpResponse"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Executes the request and returns a low-level HTTP response object.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Low-level HTTP request.
 <p>
 This allows providing a different implementation of the HTTP request that is more compatible with
 the Java environment used.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.LowLevelHttpRequest -->
  <!-- start class com.google.api.client.http.LowLevelHttpResponse -->
  <class name="LowLevelHttpResponse" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LowLevelHttpResponse"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getContent" return="java.io.InputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the HTTP response content input stream or {@code null} for none.

 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="getContentEncoding" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the content encoding (for example {@code "gzip"}) or {@code null} for none.]]>
      </doc>
    </method>
    <method name="getContentLength" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the content length or {@code 0} for none.]]>
      </doc>
    </method>
    <method name="getContentType" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the content type or {@code null} for none.]]>
      </doc>
    </method>
    <method name="getStatusLine" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the response status line or {@code null} for none.]]>
      </doc>
    </method>
    <method name="getStatusCode" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the response status code or {@code 0} for none.]]>
      </doc>
    </method>
    <method name="getReasonPhrase" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the HTTP reason phrase or {@code null} for none.]]>
      </doc>
    </method>
    <method name="getHeaderCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of HTTP response headers.
 <p>
 Note that multiple headers of the same name need to be supported, in which case each header
 value is treated as a separate header.]]>
      </doc>
    </method>
    <method name="getHeaderName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Returns the HTTP response header name at the given zero-based index.]]>
      </doc>
    </method>
    <method name="getHeaderValue" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Returns the HTTP response header value at the given zero-based index.]]>
      </doc>
    </method>
    <method name="disconnect"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Default implementation does nothing, but subclasses may override to attempt to abort the
 connection or release allocated system resources for this connection.

 @throws IOException I/O exception
 @since 1.4]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Low-level HTTP response.
 <p>
 This allows providing a different implementation of the HTTP response that is more compatible
 with the Java environment used.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.LowLevelHttpResponse -->
  <!-- start class com.google.api.client.http.MultipartRelatedContent -->
  <class name="MultipartRelatedContent" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpContent"/>
    <constructor name="MultipartRelatedContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="forRequest" return="com.google.api.client.http.MultipartRelatedContent"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.api.client.http.HttpRequest"/>
      <doc>
      <![CDATA[Returns a new multi-part content serializer as the content for the given HTTP request.

 <p>
 It also sets the {@link HttpHeaders#mimeVersion} of {@link HttpRequest#headers headers} to
 {@code "1.0"}.
 </p>

 @param request HTTP request
 @return new multi-part content serializer]]>
      </doc>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getEncoding" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="retrySupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="boundary" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Boundary string to use. By default, it is {@code "END_OF_PART"}.]]>
      </doc>
    </field>
    <field name="parts" type="java.util.Collection&lt;com.google.api.client.http.HttpContent&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Collection of HTTP content parts.
 <p>
 By default, it is an empty list. Note that the content type for each part is required, so
 {@link HttpContent#getType()} must not be {@code null}.
 </p>]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Serializes MIME Multipart/Related content as specified by <a
 href="http://tools.ietf.org/html/rfc2387">RFC 2387: The MIME Multipart/Related Content-type</a>.
 <p>
 Limitations:
 <ul>
 <li>No support of parameters other than {@code "boundary"}</li>
 <li>No support for specifying headers for each content part</li>
 </ul>
 </p>
 <p>
 Sample usage:

 <pre><code>
  static void setMediaWithMetadataContent(HttpRequest request,
      AtomContent atomContent, InputStreamContent imageContent) {
    MultipartRelatedContent content =
        MultipartRelatedContent.forRequest(request);
    content.parts.add(atomContent);
    content.parts.add(imageContent);
  }
 </code></pre>

 @since 1.1
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.MultipartRelatedContent -->
  <!-- start class com.google.api.client.http.UrlEncodedContent -->
  <class name="UrlEncodedContent" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpContent"/>
    <constructor name="UrlEncodedContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEncoding" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="retrySupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Content type. Default value is {@link UrlEncodedParser#CONTENT_TYPE}.]]>
      </doc>
    </field>
    <field name="data" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key/value data or {@code null} for none.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Implements support for HTTP form content encoding serialization of type {@code
 application/x-www-form-urlencoded} as specified in the <a href=
 "http://www.w3.org/TR/REC-html40/interact/forms.html#h-17.13.4.1">HTML 4.0 Specification</a>.
 <p>
 Sample usage:

 <pre>
 <code>
  static void setContent(HttpRequest request, Object item) {
    UrlEncodedContent content = new UrlEncodedContent();
    content.data = item;
    request.content = content;
  }
 </code>
 </pre>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.UrlEncodedContent -->
  <!-- start class com.google.api.client.http.UrlEncodedParser -->
  <class name="UrlEncodedParser" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpParser"/>
    <constructor name="UrlEncodedParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getContentType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="parse" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="dataClass" type="java.lang.Class&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="parse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="content" type="java.lang.String"/>
      <param name="data" type="java.lang.Object"/>
      <doc>
      <![CDATA[Parses the given URL-encoded content into the given data object of data key name/value pairs,
 including support for repeating data key names.

 <p>
 Declared fields of a "primitive" type (as defined by {@link Data#isPrimitive(Type)} are parsed
 using {@link Data#parsePrimitiveValue(Type, String)} where the {@link Class} parameter is the
 declared field class. Declared fields of type {@link Collection} are used to support repeating
 data key names, so each member of the collection is an additional data key value. They are
 parsed the same as "primitive" fields, except that the generic type parameter of the collection
 is used as the {@link Class} parameter.
 </p>

 <p>
 If there is no declared field for an input parameter name, it will be ignored unless the input
 {@code data} parameter is a {@link Map}. If it is a map, the parameter value will be stored
 either as a string, or as a {@link ArrayList}&lt;String&gt; in the case of repeated parameters.
 </p>

 @param content URL-encoded content or {@code null} to ignore content
 @param data data key name/value pairs]]>
      </doc>
    </method>
    <field name="CONTENT_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "application/x-www-form-urlencoded"} content type.]]>
      </doc>
    </field>
    <field name="disableContentLogging" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether to disable response content logging (unless {@link Level#ALL} is loggable which forces
 all logging).
 <p>
 Useful for example if content has sensitive data such as an authentication token. Defaults to
 {@code false}.]]>
      </doc>
    </field>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Content type. Default value is {@link #CONTENT_TYPE}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Implements support for HTTP form content encoding parsing of type {@code
 application/x-www-form-urlencoded} as specified in the <a href=
 "http://www.w3.org/TR/1998/REC-html40-19980424/interact/forms.html#h-17.13.4.1" >HTML 4.0
 Specification</a>.
 <p>
 The data is parsed using {@link #parse(String, Object)}.
 </p>
 <p>
 Sample usage:

 <pre>
 <code>
  static void setParser(HttpTransport transport) {
    transport.addParser(new UrlEncodedParser());
  }
 </code>
 </pre>

 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.UrlEncodedParser -->
</package>
<package name="com.google.api.client.http.apache">
  <!-- start class com.google.api.client.http.apache.ApacheHttpTransport -->
  <class name="ApacheHttpTransport" extends="com.google.api.client.http.HttpTransport"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ApacheHttpTransport"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 1.3]]>
      </doc>
    </constructor>
    <method name="supportsHead" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="supportsPatch" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="buildDeleteRequest" return="com.google.api.client.http.apache.ApacheHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
    </method>
    <method name="buildGetRequest" return="com.google.api.client.http.apache.ApacheHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
    </method>
    <method name="buildHeadRequest" return="com.google.api.client.http.apache.ApacheHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
    </method>
    <method name="buildPatchRequest" return="com.google.api.client.http.apache.ApacheHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
    </method>
    <method name="buildPostRequest" return="com.google.api.client.http.apache.ApacheHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
    </method>
    <method name="buildPutRequest" return="com.google.api.client.http.apache.ApacheHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
    </method>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Shuts down the connection manager and releases allocated resources. This includes closing all
 connections, whether they are currently used or not.

 @since 1.4]]>
      </doc>
    </method>
    <field name="httpClient" type="HttpClient"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Apache HTTP client.

 @since 1.1]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Thread-safe HTTP transport based on the Apache HTTP Client library.
 <p>
 Default settings:
 </p>
 <ul>
 <li>The client connection manager is set to {@link ThreadSafeClientConnManager}.</li>
 <li>Timeout is set to 20 seconds using {@link ConnManagerParams#setTimeout},
 {@link HttpConnectionParams#setConnectionTimeout}, and {@link HttpConnectionParams#setSoTimeout}.
 </li>
 <li>The socket buffer size is set to 8192 using {@link HttpConnectionParams#setSocketBufferSize}.
 </li>
 </ul>
 <p>
 These parameters may be overridden by setting the values on the {@link #httpClient}.
 {@link HttpClient#getParams() getParams()}. Please read the <a
 href="http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html">Apache HTTP
 Client connection management tutorial</a> for more complex configuration questions, such as how
 to set up an HTTP proxy.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.apache.ApacheHttpTransport -->
</package>
<package name="com.google.api.client.http.javanet">
  <!-- start class com.google.api.client.http.javanet.NetHttpTransport -->
  <class name="NetHttpTransport" extends="com.google.api.client.http.HttpTransport"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="NetHttpTransport"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="supportsHead" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="buildDeleteRequest" return="com.google.api.client.http.javanet.NetHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildGetRequest" return="com.google.api.client.http.javanet.NetHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildHeadRequest" return="com.google.api.client.http.javanet.NetHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildPostRequest" return="com.google.api.client.http.javanet.NetHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildPutRequest" return="com.google.api.client.http.javanet.NetHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Thread-safe HTTP low-level transport based on the {@code java.net} package.

 <p>
 Upgrade warning: prior version 1.3 had {@code connectTimeout} and {@code readTimeout} fields.
 Instead now use {@link HttpRequest#connectTimeout} and {@link HttpRequest#readTimeout} in an
 {@link HttpRequestInitializer}.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.javanet.NetHttpTransport -->
</package>
<package name="com.google.api.client.http.json">
  <!-- start class com.google.api.client.http.json.JsonHttpContent -->
  <class name="JsonHttpContent" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpContent"/>
    <constructor name="JsonHttpContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEncoding" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="retrySupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Content type. Default value is {@link Json#CONTENT_TYPE}.]]>
      </doc>
    </field>
    <field name="data" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key/value pair data.]]>
      </doc>
    </field>
    <field name="jsonFactory" type="com.google.api.client.json.JsonFactory"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(Required) JSON factory to use.

 @since 1.3]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Serializes JSON HTTP content based on the data key/value mapping object for an item.
 <p>
 Sample usage:

 <pre>
 <code>
  static void setContent(HttpRequest request, Object data) {
    JsonHttpContent content = new JsonHttpContent();
    content.jsonFactory = new JacksonFactory();
    content.data = data;
    request.content = content;
  }
 </code>
 </pre>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.json.JsonHttpContent -->
  <!-- start class com.google.api.client.http.json.JsonHttpParser -->
  <class name="JsonHttpParser" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpParser"/>
    <constructor name="JsonHttpParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getContentType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="parse" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="dataClass" type="java.lang.Class&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="parserForResponse" return="com.google.api.client.json.JsonParser"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="jsonFactory" type="com.google.api.client.json.JsonFactory"/>
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a JSON parser to use for parsing the given HTTP response.
 <p>
 The response content will be closed if any throwable is thrown. On success, the current token
 will be the first top token, which is normally {@link JsonToken#START_ARRAY} or
 {@link JsonToken#START_OBJECT}.
 </p>

 @param jsonFactory JSON factory to use
 @param response HTTP response
 @return JSON parser
 @throws IllegalArgumentException if content type is not {@link Json#CONTENT_TYPE}
 @throws IOException I/O exception
 @since 1.3]]>
      </doc>
    </method>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Content type. Default value is {@link Json#CONTENT_TYPE}.]]>
      </doc>
    </field>
    <field name="jsonFactory" type="com.google.api.client.json.JsonFactory"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(Required) JSON factory to use.

 @since 1.3]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Parses HTTP JSON response content into an data class of key/value pairs.
 <p>
 Sample usage:

 <pre>
 <code>
  static void setParser(HttpTransport transport) {
    JsonHttpParser parser = new JsonHttpParser();
    parser.jsonFactory = new JacksonFactory();
    transport.addParser(parser);
  }
 </code>
 </pre>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.json.JsonHttpParser -->
</package>
<package name="com.google.api.client.http.xml">
  <!-- start class com.google.api.client.http.xml.AbstractXmlHttpContent -->
  <class name="AbstractXmlHttpContent" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpContent"/>
    <constructor name="AbstractXmlHttpContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEncoding" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default implementation returns {@code null}, but subclasses may override.]]>
      </doc>
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default implementation returns {@code -1}, but subclasses may override.]]>
      </doc>
    </method>
    <method name="getType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="retrySupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="writeTo"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="serializer" type="XmlSerializer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes the content to the given XML serializer.

 @throws IOException I/O exception]]>
      </doc>
    </method>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Content type. Default value is {@link XmlHttpParser#CONTENT_TYPE}, though subclasses may define
 a different default value.]]>
      </doc>
    </field>
    <field name="namespaceDictionary" type="com.google.api.client.xml.XmlNamespaceDictionary"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[XML namespace dictionary.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Abstract serializer for XML HTTP content based on the data key/value mapping object for an item.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.xml.AbstractXmlHttpContent -->
  <!-- start class com.google.api.client.http.xml.XmlHttpContent -->
  <class name="XmlHttpContent" extends="com.google.api.client.http.xml.AbstractXmlHttpContent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="XmlHttpContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="serializer" type="XmlSerializer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="elementName" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[XML element local name, optionally prefixed by its namespace alias, for example {@code
 "atom:entry"}.]]>
      </doc>
    </field>
    <field name="data" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key/value pair data.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Serializes XML HTTP content based on the data key/value mapping object for an item.
 <p>
 Sample usage:

 <pre>
 <code>
  static void setContent(HttpRequest request, XmlNamespaceDictionary namespaceDictionary,
      String elementName, Object data) {
    XmlHttpContent content = new XmlHttpContent();
    content.namespaceDictionary = namespaceDictionary;
    content.elementName = elementName;
    content.data = data;
    request.content = content;
  }
 </code>
 </pre>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.xml.XmlHttpContent -->
  <!-- start class com.google.api.client.http.xml.XmlHttpParser -->
  <class name="XmlHttpParser" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpParser"/>
    <constructor name="XmlHttpParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getContentType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="parse" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="dataClass" type="java.lang.Class&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Default implementation parses the content of the response into the data class of key/value
 pairs, but subclasses may override.]]>
      </doc>
    </method>
    <field name="CONTENT_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "application/xml"} content type.]]>
      </doc>
    </field>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Content type. Default value is {@link #CONTENT_TYPE}.]]>
      </doc>
    </field>
    <field name="namespaceDictionary" type="com.google.api.client.xml.XmlNamespaceDictionary"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[XML namespace dictionary.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[XML HTTP parser into an data class of key/value pairs.
 <p>
 Sample usage:

 <pre>
 <code>
  static void setParser(HttpTransport transport) {
    XmlHttpParser parser = new XmlHttpParser();
    parser.namespaceDictionary = NAMESPACE_DICTIONARY;
    transport.addParser(parser);
  }
 </code>
 </pre>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.xml.XmlHttpParser -->
</package>
<package name="com.google.api.client.http.xml.atom">
  <!-- start class com.google.api.client.http.xml.atom.AtomContent -->
  <class name="AtomContent" extends="com.google.api.client.http.xml.AbstractXmlHttpContent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AtomContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="serializer" type="XmlSerializer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="entry" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key/value pair data for the Atom entry.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Serializes Atom XML HTTP content based on the data key/value mapping object for an Atom entry.
 <p>
 Default value for {@link #contentType} is {@link Atom#CONTENT_TYPE}.
 <p>
 Sample usage:

 <pre>
 <code>
  static void setContent(
      HttpRequest request, XmlNamespaceDictionary namespaceDictionary, Object entry) {
    AtomContent content = new AtomContent();
    content.namespaceDictionary = namespaceDictionary;
    content.entry = entry;
    request.content = content;
  }
 </code>
 </pre>

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.xml.atom.AtomContent -->
  <!-- start class com.google.api.client.http.xml.atom.AtomFeedContent -->
  <class name="AtomFeedContent" extends="com.google.api.client.http.xml.AbstractXmlHttpContent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AtomFeedContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="serializer" type="XmlSerializer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="feed" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key/value pair data for the Atom feed.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Serializes Atom XML HTTP content based on the data key/value mapping object for an Atom feed.
 <p>
 Default value for {@link #contentType} is {@link Atom#CONTENT_TYPE}.
 <p>
 Sample usage:

 <pre>
 <code>
  static void setContent(
      HttpRequest request, XmlNamespaceDictionary namespaceDictionary, Object feed) {
    AtomFeedContent content = new AtomFeedContent();
    content.namespaceDictionary = namespaceDictionary;
    content.feed = feed;
    request.content = content;
  }
 </code>
 </pre>

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.xml.atom.AtomFeedContent -->
  <!-- start class com.google.api.client.http.xml.atom.AtomFeedParser -->
  <class name="AtomFeedParser" extends="com.google.api.client.xml.atom.AbstractAtomFeedParser&lt;T&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AtomFeedParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="parseNextEntry" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
    </method>
    <method name="parseEntryInternal" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
    </method>
    <method name="create" return="com.google.api.client.http.xml.atom.AtomFeedParser&lt;T, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="namespaceDictionary" type="com.google.api.client.xml.XmlNamespaceDictionary"/>
      <param name="feedClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="entryClass" type="java.lang.Class&lt;E&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
      <doc>
      <![CDATA[Parses the given HTTP response using the given feed class and entry class.

 @param <T> feed type
 @param <E> entry type
 @param response HTTP response
 @param namespaceDictionary XML namespace dictionary
 @param feedClass feed class
 @param entryClass entry class
 @return Atom feed parser
 @throws IOException I/O exception
 @throws XmlPullParserException XML pull parser exception]]>
      </doc>
    </method>
    <field name="entryClass" type="java.lang.Class&lt;E&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Atom entry class to parse.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Atom feed pull parser when the Atom entry class is known in advance.

 @param <T> feed type
 @param <E> entry type
 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.xml.atom.AtomFeedParser -->
  <!-- start class com.google.api.client.http.xml.atom.AtomParser -->
  <class name="AtomParser" extends="com.google.api.client.http.xml.XmlHttpParser"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AtomParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Atom XML HTTP parser into an data class of key/value pairs.
 <p>
 It overrides the {@link #contentType} to {@link Atom#CONTENT_TYPE}.
 <p>
 Sample usage:

 <pre>
 <code>
  static void setParser(HttpTransport transport) {
    AtomParser parser = new AtomParser();
    parser.namespaceDictionary = NAMESPACE_DICTIONARY;
    transport.addParser(parser);
  }
 </code>
 </pre>

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.xml.atom.AtomParser -->
</package>
<package name="com.google.api.client.json">
  <!-- start class com.google.api.client.json.CustomizeJsonParser -->
  <class name="CustomizeJsonParser" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CustomizeJsonParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="stopAt" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="java.lang.Object"/>
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns whether to stop parsing at the given key of the given context object.]]>
      </doc>
    </method>
    <method name="handleUnrecognizedKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="java.lang.Object"/>
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Called when the given unrecognized key is encountered in the given context object.]]>
      </doc>
    </method>
    <method name="newInstanceForArray" return="java.util.Collection&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="java.lang.Object"/>
      <param name="field" type="java.lang.reflect.Field"/>
      <doc>
      <![CDATA[Returns a new instance value for the given field in the given context object for a JSON array
 or {@code null} for the default behavior.]]>
      </doc>
    </method>
    <method name="newInstanceForObject" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="java.lang.Object"/>
      <param name="fieldClass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a new instance value for the given field class in the given context object for JSON
 Object or {@code null} for the default behavior.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Customizes the behavior of a JSON parser.
 <p>
 All methods have a default trivial implementation, so subclasses need only implement the methods
 whose behavior needs customization.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.CustomizeJsonParser -->
  <!-- start class com.google.api.client.json.GenericJson -->
  <class name="GenericJson" extends="com.google.api.client.util.GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Cloneable"/>
    <constructor name="GenericJson"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="com.google.api.client.json.GenericJson"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="jsonFactory" type="com.google.api.client.json.JsonFactory"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[JSON factory to use for {@link #toString()}.

 @since 1.3]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Generic JSON data that stores all unknown key name/value pairs.
 <p>
 Subclasses can declare fields for known data keys using the {@link Key} annotation. Each field
 can be of any visibility (private, package private, protected, or public) and must not be static.
 {@code null} unknown data key names are not allowed, but {@code null} data values are allowed.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.GenericJson -->
  <!-- start class com.google.api.client.json.Json -->
  <class name="Json" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Json"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="CONTENT_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "application/json"} content type.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[JSON utilities.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.Json -->
  <!-- start class com.google.api.client.json.JsonEncoding -->
  <class name="JsonEncoding" extends="java.lang.Enum&lt;com.google.api.client.json.JsonEncoding&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.api.client.json.JsonEncoding[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.api.client.json.JsonEncoding"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Enumeration that defines legal encodings that can be used for JSON content, based on list of
 allowed encodings from <a href="http://www.ietf.org/rfc/rfc4627.txt">JSON specification</a>.

 <p>
 Limitation: currently only UTF-8 encoding is supported.
 </p>
 @since 1.3
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.JsonEncoding -->
  <!-- start class com.google.api.client.json.JsonFactory -->
  <class name="JsonFactory" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JsonFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createJsonParser" return="com.google.api.client.json.JsonParser"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a new instance of a low-level JSON parser for the given input stream.

 @param in input stream
 @return new instance of a low-level JSON parser
 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="createJsonParser" return="com.google.api.client.json.JsonParser"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a new instance of a low-level JSON parser for the given string value.

 @param value string value
 @return new instance of a low-level JSON parser
 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="createJsonParser" return="com.google.api.client.json.JsonParser"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a new instance of a low-level JSON parser for the given reader.

 @param reader reader
 @return new instance of a low-level JSON parser
 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="createJsonGenerator" return="com.google.api.client.json.JsonGenerator"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <param name="enc" type="com.google.api.client.json.JsonEncoding"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a new instance of a low-level JSON serializer for the given output stream and encoding.

 @param out output stream
 @param enc encoding
 @return new instance of a low-level JSON serializer
 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="createJsonGenerator" return="com.google.api.client.json.JsonGenerator"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a new instance of a low-level JSON serializer for the given writer.

 @param writer writer
 @return new instance of a low-level JSON serializer
 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a serialized JSON string representation for the given item using
 {@link JsonGenerator#serialize(Object)}.

 @param item data key/value pairs
 @return serialized JSON string representation]]>
      </doc>
    </method>
    <method name="fromString" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <param name="destinationClass" type="java.lang.Class&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parses a JSON string value into a JSON object of the given destination class using
 {@link JsonParser#parse(Class, CustomizeJsonParser)}.

 @param value JSON string value
 @param destinationClass destination class that has an accessibleS default constructor to use to
        create a new JSON object instance
 @return new instance of the parsed destination class
 @since 1.4]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Abstract low-level JSON factory.

 @since 1.3
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.JsonFactory -->
  <!-- start class com.google.api.client.json.JsonGenerator -->
  <class name="JsonGenerator" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JsonGenerator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getFactory" return="com.google.api.client.json.JsonFactory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the JSON factory from which this generator was created.]]>
      </doc>
    </method>
    <method name="flush"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Flushes any buffered content to the underlying output stream or writer.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="close"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Closes the serializer and the underlying output stream or writer, and releases any memory
 associated with it.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeStartArray"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON start array character '['.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeEndArray"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON end array character ']'.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeStartObject"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON start object character '{'.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeEndObject"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON end object character '}'.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeFieldName"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON quoted field name.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeNull"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a literal JSON null value.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeString"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON quoted string value.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeBoolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="state" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a literal JSON boolean value ('true' or 'false').

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeNumber"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON int value.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeNumber"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON long value.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeNumber"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.math.BigInteger"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON big integer value.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeNumber"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="float"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON float value.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeNumber"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="double"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON double value.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeNumber"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.math.BigDecimal"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON big decimal value.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="writeNumber"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="encodedValue" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a JSON numeric value that has already been encoded properly.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="serialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serializes the given JSON value object.

 @param value JSON value object or {@code null} to ignore]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Abstract low-level JSON serializer.

 @since 1.3
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.JsonGenerator -->
  <!-- start class com.google.api.client.json.JsonParser -->
  <class name="JsonParser" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JsonParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getFactory" return="com.google.api.client.json.JsonFactory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the JSON factory from which this generator was created.]]>
      </doc>
    </method>
    <method name="close"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Closes the parser and the underlying input stream or reader, and releases any memory associated
 with it.

 @throws IOException if failed]]>
      </doc>
    </method>
    <method name="nextToken" return="com.google.api.client.json.JsonToken"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the next token from the stream or {@code null} to indicate end of input.]]>
      </doc>
    </method>
    <method name="getCurrentToken" return="com.google.api.client.json.JsonToken"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the token the parser currently points to or {@code null} for none (at start of input or
 after end of input).]]>
      </doc>
    </method>
    <method name="getCurrentName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the most recent field name or {@code null} for array values or for root-level values.]]>
      </doc>
    </method>
    <method name="skipChildren" return="com.google.api.client.json.JsonParser"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Skips to the matching {@link JsonToken#END_ARRAY} if current token is
 {@link JsonToken#START_ARRAY}, the matching {@link JsonToken#END_OBJECT} if the current token
 is {@link JsonToken#START_OBJECT}, else does nothing.]]>
      </doc>
    </method>
    <method name="getText" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a textual representation of the current token or {@code null} if
 {@link #getCurrentToken()} is {@code null}.]]>
      </doc>
    </method>
    <method name="getByteValue" return="byte"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the byte value of the current token.]]>
      </doc>
    </method>
    <method name="getShortValue" return="short"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the short value of the current token.]]>
      </doc>
    </method>
    <method name="getIntValue" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the int value of the current token.]]>
      </doc>
    </method>
    <method name="getFloatValue" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the float value of the current token.]]>
      </doc>
    </method>
    <method name="getLongValue" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the long value of the current token.]]>
      </doc>
    </method>
    <method name="getDoubleValue" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the double value of the current token.]]>
      </doc>
    </method>
    <method name="getBigIntegerValue" return="java.math.BigInteger"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the {@link BigInteger} value of the current token.]]>
      </doc>
    </method>
    <method name="getDecimalValue" return="java.math.BigDecimal"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the {@link BigDecimal} value of the current token.]]>
      </doc>
    </method>
    <method name="parseAndClose" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="destinationClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="customizeParser" type="com.google.api.client.json.CustomizeJsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse a JSON Object from the given JSON parser (which is closed after parsing completes) into
 the given destination class, optionally using the given parser customizer.

 @param <T> destination class type
 @param destinationClass destination class that has a public default constructor to use to
        create a new instance
 @param customizeParser optional parser customizer or {@code null} for none
 @return new instance of the parsed destination class]]>
      </doc>
    </method>
    <method name="skipToKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="keyToFind" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Skips the values of all keys in the current object until it finds the given key.
 <p>
 Before this method is called, the parser must either point to the start or end of a JSON object
 or to a field name. After this method ends, the current token will either be the
 {@link JsonToken#END_OBJECT} of the current object if the key is not found, or the value of the
 key that was found.
 </p>

 @param keyToFind key to find]]>
      </doc>
    </method>
    <method name="parseAndClose"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="destination" type="java.lang.Object"/>
      <param name="customizeParser" type="com.google.api.client.json.CustomizeJsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse a JSON Object from the given JSON parser -- which is closed after parsing completes --
 into the given destination object, optionally using the given parser customizer.
 <p>
 Before this method is called, the parser must either point to the start or end of a JSON object
 or to a field name.
 </p>

 @param destination destination object
 @param customizeParser optional parser customizer or {@code null} for none]]>
      </doc>
    </method>
    <method name="parse" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="destinationClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="customizeParser" type="com.google.api.client.json.CustomizeJsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse a JSON Object from the given JSON parser into the given destination class, optionally
 using the given parser customizer.
 <p>
 Before this method is called, the parser must either point to the start or end of a JSON object
 or to a field name. After this method ends, the current token will be the
 {@link JsonToken#END_OBJECT} of the current object.
 </p>

 @param <T> destination class type
 @param destinationClass destination class that has a public default constructor to use to
        create a new instance
 @param customizeParser optional parser customizer or {@code null} for none
 @return new instance of the parsed destination class]]>
      </doc>
    </method>
    <method name="parse"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="destination" type="java.lang.Object"/>
      <param name="customizeParser" type="com.google.api.client.json.CustomizeJsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse a JSON Object from the given JSON parser into the given destination object, optionally
 using the given parser customizer.
 <p>
 Before this method is called, the parser must either point to the start or end of a JSON object
 or to a field name. After this method ends, the current token will be the
 {@link JsonToken#END_OBJECT} of the current object.
 </p>

 @param destination destination object
 @param customizeParser optional parser customizer or {@code null} for none]]>
      </doc>
    </method>
    <method name="parseArrayAndClose" return="java.util.Collection&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="destinationCollectionClass" type="java.lang.Class&lt;?&gt;"/>
      <param name="destinationItemClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="customizeParser" type="com.google.api.client.json.CustomizeJsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse a JSON Array from the given JSON parser (which is closed after parsing completes) into
 the given destination collection, optionally using the given parser customizer.

 @param destinationCollectionClass class of destination collection (must have a public default
        constructor)
 @param destinationItemClass class of destination collection item (must have a public default
        constructor)
 @param customizeParser optional parser customizer or {@code null} for none]]>
      </doc>
    </method>
    <method name="parseArrayAndClose"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="destinationCollection" type="java.util.Collection&lt;? super T&gt;"/>
      <param name="destinationItemClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="customizeParser" type="com.google.api.client.json.CustomizeJsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse a JSON Array from the given JSON parser (which is closed after parsing completes) into
 the given destination collection, optionally using the given parser customizer.

 @param destinationCollection destination collection
 @param destinationItemClass class of destination collection item (must have a public default
        constructor)
 @param customizeParser optional parser customizer or {@code null} for none]]>
      </doc>
    </method>
    <method name="parseArray" return="java.util.Collection&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="destinationCollectionClass" type="java.lang.Class&lt;?&gt;"/>
      <param name="destinationItemClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="customizeParser" type="com.google.api.client.json.CustomizeJsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse a JSON Array from the given JSON parser into the given destination collection, optionally
 using the given parser customizer.

 @param destinationCollectionClass class of destination collection (must have a public default
        constructor)
 @param destinationItemClass class of destination collection item (must have a public default
        constructor)
 @param customizeParser optional parser customizer or {@code null} for none]]>
      </doc>
    </method>
    <method name="parseArray"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="destinationCollection" type="java.util.Collection&lt;? super T&gt;"/>
      <param name="destinationItemClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="customizeParser" type="com.google.api.client.json.CustomizeJsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse a JSON Array from the given JSON parser into the given destination collection, optionally
 using the given parser customizer.

 @param destinationCollection destination collection
 @param destinationItemClass class of destination collection item (must have a public default
        constructor)
 @param customizeParser optional parser customizer or {@code null} for none]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Abstract low-level JSON parser.

 @since 1.3
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.JsonParser -->
  <!-- start class com.google.api.client.json.JsonString -->
  <class name="JsonString"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Use this annotation to specify that a declared numeric Java field should map to a JSON string.

 <p>
 By default declared Java numeric fields are stored as JSON numbers. For example:

 <pre>
 <code>
class A {
  &#64;Key BigInteger value;
}
 </code>
 </pre>

  can be used for this JSON content:

 <pre>
 <code>
{"value" : 12345768901234576890123457689012345768901234576890}
 </code>
 </pre>

  However, if instead the JSON content uses a JSON String to store the value, one needs to use the
 {@link JsonString} annotation. For example:

 <pre>
 <code>
class B {
  &#64;Key &#64;JsonString BigInteger value;
}
 </code>
 </pre>

  can be used for this JSON content:

 <pre>
 <code>
{"value" : "12345768901234576890123457689012345768901234576890"}
 </code>
 </pre>
 </p>

 @since 1.3
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.JsonString -->
  <!-- start class com.google.api.client.json.JsonToken -->
  <class name="JsonToken" extends="java.lang.Enum&lt;com.google.api.client.json.JsonToken&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.api.client.json.JsonToken[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.api.client.json.JsonToken"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[JSON token in the low-level JSON library.

 @since 1.3
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.JsonToken -->
</package>
<package name="com.google.api.client.json.gson">
  <!-- start class com.google.api.client.json.gson.GsonFactory -->
  <class name="GsonFactory" extends="com.google.api.client.json.JsonFactory"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GsonFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createJsonParser" return="com.google.api.client.json.JsonParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
    </method>
    <method name="createJsonParser" return="com.google.api.client.json.JsonParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
    </method>
    <method name="createJsonParser" return="com.google.api.client.json.JsonParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
    </method>
    <method name="createJsonGenerator" return="com.google.api.client.json.JsonGenerator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <param name="enc" type="com.google.api.client.json.JsonEncoding"/>
    </method>
    <method name="createJsonGenerator" return="com.google.api.client.json.JsonGenerator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.io.Writer"/>
    </method>
    <doc>
    <![CDATA[Low-level JSON library implementation based on GSON.

 @since 1.3
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.gson.GsonFactory -->
  <!-- start class com.google.api.client.json.gson.GsonGenerator -->
  <class name="GsonGenerator" extends="com.google.api.client.json.JsonGenerator"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFactory" return="com.google.api.client.json.JsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="writeBoolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="state" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeEndArray"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeEndObject"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeFieldName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNull"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNumber"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNumber"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNumber"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.math.BigInteger"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNumber"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="double"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNumber"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="float"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNumber"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.math.BigDecimal"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNumber"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="encodedValue" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeStartArray"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeStartObject"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeString"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Low-level JSON serializer implementation based on GSON.

 @since 1.3
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.gson.GsonGenerator -->
  <!-- start class com.google.api.client.json.gson.GsonParser -->
  <class name="GsonParser" extends="com.google.api.client.json.JsonParser"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getCurrentName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCurrentToken" return="com.google.api.client.json.JsonToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFactory" return="com.google.api.client.json.JsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getByteValue" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getShortValue" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIntValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFloatValue" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getBigIntegerValue" return="java.math.BigInteger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDecimalValue" return="java.math.BigDecimal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDoubleValue" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLongValue" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getText" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="nextToken" return="com.google.api.client.json.JsonToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skipChildren" return="com.google.api.client.json.JsonParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Low-level JSON serializer implementation based on GSON.

 @since 1.3
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.gson.GsonParser -->
</package>
<package name="com.google.api.client.json.jackson">
  <!-- start class com.google.api.client.json.jackson.JacksonFactory -->
  <class name="JacksonFactory" extends="com.google.api.client.json.JsonFactory"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="JacksonFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createJsonGenerator" return="com.google.api.client.json.JsonGenerator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <param name="enc" type="com.google.api.client.json.JsonEncoding"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createJsonGenerator" return="com.google.api.client.json.JsonGenerator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createJsonParser" return="com.google.api.client.json.JsonParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createJsonParser" return="com.google.api.client.json.JsonParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createJsonParser" return="com.google.api.client.json.JsonParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Low-level JSON library implementation based on Jackson.

 @since 1.3
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.jackson.JacksonFactory -->
</package>
<package name="com.google.api.client.json.rpc2">
  <!-- start class com.google.api.client.json.rpc2.JsonRpcRequest -->
  <class name="JsonRpcRequest" extends="com.google.api.client.util.GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JsonRpcRequest"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="jsonrpc" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A String specifying the version of the JSON-RPC protocol. MUST be exactly "2.0".]]>
      </doc>
    </field>
    <field name="id" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An identifier established by the Client that MUST contain a String or a Number. If it is not
 included it is assumed to be a notification, and will not receive a response.]]>
      </doc>
    </field>
    <field name="method" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A String containing the name of the method to be invoked.]]>
      </doc>
    </field>
    <field name="params" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A Structured value that holds the parameter values to be used during the invocation of the
 method. This member MAY be omitted.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[JSON-RPC 2.0 request object.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.rpc2.JsonRpcRequest -->
</package>
<package name="com.google.api.client.testing.http">
  <!-- start class com.google.api.client.testing.http.MockHttpContent -->
  <class name="MockHttpContent" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpContent"/>
    <constructor name="MockHttpContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEncoding" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="retrySupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="encoding" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP content encoding or {@code null} by default.]]>
      </doc>
    </field>
    <field name="length" type="long"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP content length or {@code -1} by default.]]>
      </doc>
    </field>
    <field name="type" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP content type or {@code null} by default.]]>
      </doc>
    </field>
    <field name="content" type="byte[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP content or an empty byte array by default.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Mock for {@link HttpContent}.

 @author Yaniv Inbar
 @since 1.3]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.testing.http.MockHttpContent -->
  <!-- start class com.google.api.client.testing.http.MockHttpTransport -->
  <class name="MockHttpTransport" extends="com.google.api.client.http.HttpTransport"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MockHttpTransport"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="buildDeleteRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildGetRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildHeadRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildPatchRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildPostRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildPutRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="supportsHead" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="supportsPatch" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="supportedOptionalMethods" type="java.util.EnumSet&lt;com.google.api.client.http.HttpMethod&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Set of supported optional methods or {@link HttpMethod#HEAD} and {@link HttpMethod#PATCH} by
 default.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Mock for {@link HttpTransport}.

 @author Yaniv Inbar
 @since 1.3]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.testing.http.MockHttpTransport -->
  <!-- start class com.google.api.client.testing.http.MockLowLevelHttpRequest -->
  <class name="MockLowLevelHttpRequest" extends="com.google.api.client.http.LowLevelHttpRequest"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MockLowLevelHttpRequest"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MockLowLevelHttpRequest" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param url Request URL or {@code null} for none
 @since 1.4]]>
      </doc>
    </constructor>
    <method name="addHeader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
    </method>
    <method name="execute" return="com.google.api.client.http.LowLevelHttpResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setContent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="content" type="com.google.api.client.http.HttpContent"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="url" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Request URL or {@code null} for none.

 @since 1.4]]>
      </doc>
    </field>
    <field name="headers" type="&lt;any&gt;"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Headers added in {@link #addHeader(String, String)}.

 @since 1.4]]>
      </doc>
    </field>
    <field name="content" type="com.google.api.client.http.HttpContent"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP content or {@code null} for none.

 @since 1.4]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Mock for {@link LowLevelHttpRequest}.

 @author Yaniv Inbar
 @since 1.3]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.testing.http.MockLowLevelHttpRequest -->
  <!-- start class com.google.api.client.testing.http.MockLowLevelHttpResponse -->
  <class name="MockLowLevelHttpResponse" extends="com.google.api.client.http.LowLevelHttpResponse"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MockLowLevelHttpResponse"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="addHeader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds a header to the response.

 @param name header name
 @param value header value]]>
      </doc>
    </method>
    <method name="setContent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stringContent" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the response content to the given content string.

 @param stringContent content string]]>
      </doc>
    </method>
    <method name="getContent" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getContentEncoding" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getContentLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getContentType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHeaderCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHeaderName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
    </method>
    <method name="getHeaderValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
    </method>
    <method name="getReasonPhrase" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStatusCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStatusLine" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="content" type="java.io.InputStream"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Input stream content of HTTP response or {@code null} by default.]]>
      </doc>
    </field>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Content type of HTTP response or {@code null} by default.]]>
      </doc>
    </field>
    <field name="statusCode" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Status code of HTTP response or {@code 200} by default.]]>
      </doc>
    </field>
    <field name="headerNames" type="java.util.ArrayList&lt;java.lang.String&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[List of header names of HTTP response (empty array list by default).]]>
      </doc>
    </field>
    <field name="headerValues" type="java.util.ArrayList&lt;java.lang.String&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[List of header values of HTTP response (empty array list by default).]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Mock for {@link LowLevelHttpResponse}.

 @author Yaniv Inbar
 @since 1.3]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.testing.http.MockLowLevelHttpResponse -->
</package>
<package name="com.google.api.client.testing.json">
  <!-- start class com.google.api.client.testing.json.AbstractJsonGeneratorTest -->
  <class name="AbstractJsonGeneratorTest" extends="TestCase"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonGeneratorTest" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="newFactory" return="com.google.api.client.json.JsonFactory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="testGenerateEntry"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="testGenerateFeed"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[Abstract test case for {@link JsonGenerator}.

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonGeneratorTest -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonGeneratorTest.Entry -->
  <class name="AbstractJsonGeneratorTest.Entry" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="title" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonGeneratorTest.Entry -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonGeneratorTest.Feed -->
  <class name="AbstractJsonGeneratorTest.Feed" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonGeneratorTest.Feed"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="entries" type="java.util.Collection&lt;com.google.api.client.testing.json.AbstractJsonGeneratorTest.Entry&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonGeneratorTest.Feed -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest -->
  <class name="AbstractJsonParserTest" extends="TestCase"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="newFactory" return="com.google.api.client.json.JsonFactory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="testParse_emptyMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParse_emptyGenericJson"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParseEntry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="testParseFeed"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="testParseEntryAsMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testSkipToKey_missingEmpty"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testSkipToKey_missing"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testSkipToKey_found"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testSkipToKey_startWithFieldName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testSkipChildren_string"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testSkipChildren_object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testSkipChildren_array"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testNextToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testCurrentToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_numberTypes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testToFromString"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_anyType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_arrayType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_collectionType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_mapType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_hashmapForMapType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_wildCardType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_integerTypeVariableType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_intArrayTypeVariableType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_doubleListTypeVariableType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_floatMapTypeVariableType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_treemapForTypeVariableType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_nullValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_enumValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="testParser_typeVariablesPassAround"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Abstract test case for {@link JsonParser}.

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.A -->
  <class name="AbstractJsonParserTest.A" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.A"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="map" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.A -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.AnyType -->
  <class name="AbstractJsonParserTest.AnyType" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.AnyType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="arr" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="bool" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="num" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="obj" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="str" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="nul" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.AnyType -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.ArrayType -->
  <class name="AbstractJsonParserTest.ArrayType" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.ArrayType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="integerArr" type="java.lang.Integer[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.ArrayType -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.CollectionOfCollectionType -->
  <class name="AbstractJsonParserTest.CollectionOfCollectionType" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.CollectionOfCollectionType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="arr" type="java.util.LinkedList&lt;java.util.LinkedList&lt;java.lang.String&gt;&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.CollectionOfCollectionType -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.DoubleListTypeVariableType -->
  <class name="AbstractJsonParserTest.DoubleListTypeVariableType" extends="com.google.api.client.testing.json.AbstractJsonParserTest.TypeVariableType&lt;java.util.List&lt;java.lang.Double&gt;&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.DoubleListTypeVariableType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.DoubleListTypeVariableType -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.E -->
  <class name="AbstractJsonParserTest.E" extends="java.lang.Enum&lt;com.google.api.client.testing.json.AbstractJsonParserTest.E&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.api.client.testing.json.AbstractJsonParserTest.E[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.api.client.testing.json.AbstractJsonParserTest.E"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.E -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.Entry -->
  <class name="AbstractJsonParserTest.Entry" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.Entry"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="title" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.Entry -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.EnumValue -->
  <class name="AbstractJsonParserTest.EnumValue" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.EnumValue"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="value" type="com.google.api.client.testing.json.AbstractJsonParserTest.E"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="otherValue" type="com.google.api.client.testing.json.AbstractJsonParserTest.E"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="nullValue" type="com.google.api.client.testing.json.AbstractJsonParserTest.E"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.EnumValue -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.Feed -->
  <class name="AbstractJsonParserTest.Feed" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.Feed"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="entries" type="java.util.Collection&lt;com.google.api.client.testing.json.AbstractJsonParserTest.Entry&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.Feed -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.FloatMapTypeVariableType -->
  <class name="AbstractJsonParserTest.FloatMapTypeVariableType" extends="com.google.api.client.testing.json.AbstractJsonParserTest.TypeVariableType&lt;java.util.Map&lt;java.lang.String, java.lang.Float&gt;&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.FloatMapTypeVariableType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.FloatMapTypeVariableType -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.IntArrayTypeVariableType -->
  <class name="AbstractJsonParserTest.IntArrayTypeVariableType" extends="com.google.api.client.testing.json.AbstractJsonParserTest.TypeVariableType&lt;int[]&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.IntArrayTypeVariableType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.IntArrayTypeVariableType -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.IntegerTypeVariableType -->
  <class name="AbstractJsonParserTest.IntegerTypeVariableType" extends="com.google.api.client.testing.json.AbstractJsonParserTest.TypeVariableType&lt;java.lang.Integer&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.IntegerTypeVariableType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.IntegerTypeVariableType -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.MapOfMapType -->
  <class name="AbstractJsonParserTest.MapOfMapType" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.MapOfMapType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="value" type="java.util.Map[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.MapOfMapType -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.NumberTypes -->
  <class name="AbstractJsonParserTest.NumberTypes" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.NumberTypes"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.NumberTypes -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.NumberTypesAsString -->
  <class name="AbstractJsonParserTest.NumberTypesAsString" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.NumberTypesAsString"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.NumberTypesAsString -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.StringNullValue -->
  <class name="AbstractJsonParserTest.StringNullValue" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.StringNullValue"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="arr2" type="java.lang.String[][]"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="arr" type="java.lang.String[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="value" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.StringNullValue -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.TypeVariablesPassedAround -->
  <class name="AbstractJsonParserTest.TypeVariablesPassedAround" extends="com.google.api.client.testing.json.AbstractJsonParserTest.X&lt;java.util.LinkedList&lt;java.lang.String&gt;&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.TypeVariablesPassedAround"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.TypeVariablesPassedAround -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.TypeVariableType -->
  <class name="AbstractJsonParserTest.TypeVariableType" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.TypeVariableType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="arr" type="T[][]"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="list" type="java.util.LinkedList&lt;java.util.LinkedList&lt;T&gt;&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="nullValue" type="T"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="value" type="T"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.TypeVariableType -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.WildCardTypes -->
  <class name="AbstractJsonParserTest.WildCardTypes" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.WildCardTypes"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="lower" type="java.util.Collection[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="map" type="java.util.Map&lt;java.lang.String, ?&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="mapInWild" type="java.util.Collection&lt;? super java.util.TreeMap&lt;java.lang.String, ? extends java.lang.Integer&gt;&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="mapUpper" type="java.util.Map&lt;java.lang.String, ? extends java.lang.Integer&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="simple" type="java.util.Collection[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="upper" type="java.util.Collection[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.WildCardTypes -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.X -->
  <class name="AbstractJsonParserTest.X" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.X"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.X -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.Y -->
  <class name="AbstractJsonParserTest.Y" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.Y"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.Y -->
  <!-- start class com.google.api.client.testing.json.AbstractJsonParserTest.Z -->
  <class name="AbstractJsonParserTest.Z" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJsonParserTest.Z"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.google.api.client.testing.json.AbstractJsonParserTest.Z -->
</package>
<package name="com.google.api.client.util">
  <!-- start class com.google.api.client.util.ArrayMap -->
  <class name="ArrayMap" extends="java.util.AbstractMap&lt;K, V&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Cloneable"/>
    <constructor name="ArrayMap"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="create" return="com.google.api.client.util.ArrayMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new instance of an array map with initial capacity of zero. Equivalent to calling the
 default constructor, except without the need to specify the type parameters. For example:
 {@code ArrayMap<String, String> map = ArrayMap.create();}.]]>
      </doc>
    </method>
    <method name="create" return="com.google.api.client.util.ArrayMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialCapacity" type="int"/>
      <doc>
      <![CDATA[Returns a new instance of an array map of the given initial capacity. For example: {@code
 ArrayMap<String, String> map = ArrayMap.create(8);}.]]>
      </doc>
    </method>
    <method name="of" return="com.google.api.client.util.ArrayMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyValuePairs" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Returns a new instance of an array map of the given key value pairs in alternating order. For
 example: {@code ArrayMap<String, String> map = ArrayMap.of("key1", "value1", "key2", "value2",
 ...);}.
 <p>
 WARNING: there is no compile-time checking of the {@code keyValuePairs} parameter to ensure
 that the keys or values have the correct type, so if the wrong type is passed in, any problems
 will occur at runtime. Also, there is no checking that the keys are unique, which the caller
 must ensure is true.]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of key-value pairs set.]]>
      </doc>
    </method>
    <method name="getKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Returns the key at the given index or {@code null} if out of bounds.]]>
      </doc>
    </method>
    <method name="getValue" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Returns the value at the given index or {@code null} if out of bounds.]]>
      </doc>
    </method>
    <method name="set" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Sets the key/value mapping at the given index, overriding any existing key/value mapping.
 <p>
 There is no checking done to ensure that the key does not already exist. Therefore, this method
 is dangerous to call unless the caller can be certain the key does not already exist in the
 map.

 @return previous value or {@code null} for none
 @throws IndexOutOfBoundsException if index is negative]]>
      </doc>
    </method>
    <method name="set" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Sets the value at the given index, overriding any existing value mapping.

 @return previous value or {@code null} for none
 @throws IndexOutOfBoundsException if index is negative or {@code >=} size]]>
      </doc>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Adds the key/value mapping at the end of the list. Behaves identically to {@code set(size(),
 key, value)}.

 @throws IndexOutOfBoundsException if index is negative]]>
      </doc>
    </method>
    <method name="remove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Removes the key/value mapping at the given index, or ignored if the index is out of bounds.

 @return previous value or {@code null} for none]]>
      </doc>
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns whether there is a mapping for the given key.]]>
      </doc>
    </method>
    <method name="getIndexOfKey" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Returns the index of the given key or {@code -1} if there is no such key.]]>
      </doc>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the value set for the given key or {@code null} if there is no such mapping or if the
 mapping value is {@code null}.]]>
      </doc>
    </method>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Sets the value for the given key, overriding any existing value.

 @return previous value or {@code null} for none]]>
      </doc>
    </method>
    <method name="remove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Removes the key-value pair of the given key, or ignore if the key cannot be found.

 @return previous value or {@code null} for none]]>
      </doc>
    </method>
    <method name="trim"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Trims the internal array storage to minimize memory usage.]]>
      </doc>
    </method>
    <method name="ensureCapacity"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="minCapacity" type="int"/>
      <doc>
      <![CDATA[Ensures that the capacity of the internal arrays is at least a given capacity.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="entrySet" return="java.util.Set&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="com.google.api.client.util.ArrayMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Memory-efficient map of keys to values with list-style random-access semantics.
 <p>
 Supports null keys and values. Conceptually, the keys and values are stored in a simpler array in
 order to minimize memory use and provide for fast access to a key/value at a certain index (for
 example {@link #getKey(int)}). However, traditional mapping operations like {@link #get(Object)}
 and {@link #put(Object, Object)} are slower because they need to look up all key/value pairs in
 the worst case.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.ArrayMap -->
  <!-- start class com.google.api.client.util.ArrayValueMap -->
  <class name="ArrayValueMap" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ArrayValueMap" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param destination destination object whose fields must be set, or destination map whose values
        must be set]]>
      </doc>
    </constructor>
    <method name="setValues"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sets the fields of the given object using the values collected during parsing of the object's
 fields.]]>
      </doc>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field" type="java.lang.reflect.Field"/>
      <param name="arrayComponentType" type="java.lang.Class&lt;?&gt;"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Puts an additional value for the given field, accumulating values on repeated calls on the same
 field.

 @param field field
 @param arrayComponentType array component type
 @param value value]]>
      </doc>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyName" type="java.lang.String"/>
      <param name="arrayComponentType" type="java.lang.Class&lt;?&gt;"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Puts an additional value for the given key name, accumulating values on repeated calls on the
 same key name.

 @param keyName key name
 @param arrayComponentType array component type
 @param value value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Collects the array values of a key/value data object, writing the fields or map values only after
 all values have been collected.

 <p>
 The typical application for this is when parsing JSON or XML when the value type is known to be
 an array. It stores the values in a collection during the parsing, and only when the parsing of
 an object is finished does it convert the collection into an array and stores it.
 </p>

 <p>
 Use {@link #put(String, Class, Object)} when the destination object is a map with string keys and
 whose values accept an array of objects. Use {@link #put(Field, Class, Object)} when setting the
 value of a field using reflection, assuming its type accepts an array of objects. One can
 potentially use both {@code put} methods for example on an instance of {@link GenericData}.
 </p>

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.ArrayValueMap -->
  <!-- start class com.google.api.client.util.Base64 -->
  <class name="Base64" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="encode" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="byte[]"/>
      <doc>
      <![CDATA[Similar to {@link #encode(byte[])} but returns a byte array instead of instantiating a String.
 This is more efficient if you're working with I/O streams and have large data sets to encode.


 @param source The data to convert
 @return The Base64-encoded data as a byte[] (of ASCII characters)
 @throws NullPointerException if source array is null
 @since 2.3.1]]>
      </doc>
    </method>
    <method name="encode" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Similar to {@link #encode(byte[], int, int)} but returns a byte array instead of instantiating
 a String. This is more efficient if you're working with I/O streams and have large data sets to
 encode.


 @param source The data to convert
 @param off Offset in array where conversion should begin
 @param len Length of data to convert
 @return The Base64-encoded data as a String
 @throws NullPointerException if source array is null
 @throws IllegalArgumentException if source array, offset, or length are invalid
 @since 2.3.1]]>
      </doc>
    </method>
    <method name="decode" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Low-level access to decoding ASCII characters in the form of a byte array. <strong>Ignores
 GUNZIP option, if it's set.</strong> This is not generally a recommended method, although it is
 used internally as part of the decoding process. Special case: if len = 0, an empty array is
 returned. Still, if you need more speed and reduced memory footprint (and aren't gzipping),
 consider this method.

 @param source The Base64 encoded data
 @return decoded data
 @since 2.3.1]]>
      </doc>
    </method>
    <method name="decode" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Low-level access to decoding ASCII characters in the form of a byte array. <strong>Ignores
 GUNZIP option, if it's set.</strong> This is not generally a recommended method, although it is
 used internally as part of the decoding process. Special case: if len = 0, an empty array is
 returned. Still, if you need more speed and reduced memory footprint (and aren't gzipping),
 consider this method.

 @param source The Base64 encoded data
 @param off The offset of where to begin decoding
 @param len The length of characters to decode
 @return decoded data
 @throws java.io.IOException If bogus characters exist in source data
 @since 1.3]]>
      </doc>
    </method>
  </class>
  <!-- end class com.google.api.client.util.Base64 -->
  <!-- start class com.google.api.client.util.ClassInfo -->
  <class name="ClassInfo" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="of" return="com.google.api.client.util.ClassInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="underlyingClass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the class information for the given underlying class.

 @param underlyingClass underlying class or {@code null} for {@code null} result
 @return class information or {@code null} for {@code null} input]]>
      </doc>
    </method>
    <method name="getUnderlyingClass" return="java.lang.Class&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the underlying class.

 @since 1.4]]>
      </doc>
    </method>
    <method name="getFieldInfo" return="com.google.api.client.util.FieldInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the information for the given {@link FieldInfo#getName()}.

 @param name {@link FieldInfo#getName()} or {@code null}
 @return field information or {@code null} for none]]>
      </doc>
    </method>
    <method name="getField" return="java.lang.reflect.Field"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the field for the given {@link FieldInfo#getName()}.

 @param name {@link FieldInfo#getName()} or {@code null}
 @return field or {@code null} for none]]>
      </doc>
    </method>
    <method name="isEnum" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the underlying class is an enum.

 @since 1.4]]>
      </doc>
    </method>
    <method name="getKeyCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.5) Use {@link #getNames()}{@code .size()}">
      <doc>
      <![CDATA[Returns the number of fields associated with this data class.

 @deprecated (scheduled to be removed in 1.5) Use {@link #getNames()}{@code .size()}]]>
      </doc>
    </method>
    <method name="getKeyNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.5) Use {@link #getNames()}">
      <doc>
      <![CDATA[Returns the data key names associated with this data class.

 @deprecated (scheduled to be removed in 1.5) Use {@link #getNames()}]]>
      </doc>
    </method>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodifiable sorted set (with any possible {@code null} member first) of
 {@link FieldInfo#getName() names}.]]>
      </doc>
    </method>
    <method name="newInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.5) use {@link Types#newInstance(Class)}">
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Creates a new instance of the given class using reflection.

 @deprecated (scheduled to be removed in 1.5) use {@link Types#newInstance(Class)}]]>
      </doc>
    </method>
    <method name="newCollectionInstance" return="java.util.Collection&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.5) use {@link Data#newCollectionInstance(Type)}">
      <param name="collectionClass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a new instance of the given collection class.
 <p>
 If a concrete collection class in the The class of the returned collection instance depends on
 the input collection class as follows (first that matches):
 <ul>
 <li>{@code null} or {@link ArrayList} is an instance of the collection class: returns an
 {@link ArrayList}</li>
 <li>Concrete subclass of {@link Collection}: returns an instance of that collection class</li>
 <li>{@link HashSet} is an instance of the collection class: returns a {@link HashSet}</li>
 <li>{@link TreeSet} is an instance of the collection class: returns a {@link TreeSet}</li>
 </ul>

 @param collectionClass collection class or {@code null} for {@link ArrayList}.
 @return new collection instance
 @deprecated (scheduled to be removed in 1.5) use {@link Data#newCollectionInstance(Type)}]]>
      </doc>
    </method>
    <method name="newMapInstance" return="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.5) use {@link Data#newMapInstance(Class)}">
      <param name="mapClass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a new instance of the given map class.

 @deprecated (scheduled to be removed in 1.5) use {@link Data#newMapInstance(Class)}]]>
      </doc>
    </method>
    <method name="getCollectionParameter" return="java.lang.Class&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.5) use {@link Types#getIterableParameter(Type)} on
             the {@link Field#getGenericType()}">
      <param name="field" type="java.lang.reflect.Field"/>
      <doc>
      <![CDATA[Returns the type parameter for the given field assuming it is of type collection.

 @deprecated (scheduled to be removed in 1.5) use {@link Types#getIterableParameter(Type)} on
             the {@link Field#getGenericType()}]]>
      </doc>
    </method>
    <method name="getMapValueParameter" return="java.lang.Class&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.5) use {@link Types#getMapValueParameter(Type)} on
             the {@link Field#getGenericType()}">
      <param name="field" type="java.lang.reflect.Field"/>
      <doc>
      <![CDATA[Returns the type parameter for the given field assuming it is of type map.

 @deprecated (scheduled to be removed in 1.5) use {@link Types#getMapValueParameter(Type)} on
             the {@link Field#getGenericType()}]]>
      </doc>
    </method>
    <method name="getMapValueParameter" return="java.lang.Class&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.5) use {@link Types#getMapValueParameter(Type)}">
      <param name="genericType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns the type parameter for the given genericType assuming it is of type map.

 @deprecated (scheduled to be removed in 1.5) use {@link Types#getMapValueParameter(Type)}]]>
      </doc>
    </method>
    <field name="clazz" type="java.lang.Class&lt;?&gt;"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be made private in 1.5) Use {@link #getUnderlyingClass()}">
      <doc>
      <![CDATA[Class.

 @deprecated (scheduled to be made private in 1.5) Use {@link #getUnderlyingClass()}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Parses class information to determine data key name/value pairs associated with the class.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.ClassInfo -->
  <!-- start class com.google.api.client.util.Data -->
  <class name="Data" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Data"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="nullOf" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="objClass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the single instance of the magic object that represents the "null" value for the given
 Java class (including array or enum).

 @param objClass class of the object needed
 @return magic object instance that represents the "null" value (not Java {@code null})
 @throws IllegalArgumentException if unable to create a new instance]]>
      </doc>
    </method>
    <method name="isNull" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns whether the given object is the magic object that represents the null value of its
 class.

 @param object object or {@code null}
 @return whether it is the magic null value or {@code false} for {@code null} input]]>
      </doc>
    </method>
    <method name="mapOf" return="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the map to use for the given data that is treated as a map from string key to some
 value.

 <p>
 If the input is {@code null}, it returns an empty map. If the input is a map, it simply returns
 the input. Otherwise, it will create a map view using reflection that is backed by the object,
 so that any changes to the map will be reflected on the object. The map keys of that map view
 are based on the {@link Key} annotation, and null is not a possible map value, although the
 magic null instance is possible (see {@link #nullOf(Class)} and {@link #isNull(Object)}).
 Iteration order of the data keys is based on the sorted (ascending) key names of the declared
 fields. Note that since the map view is backed by the object, and that the object may change,
 many methods in the map view must recompute the field values using reflection, for example
 {@link Map#size()} must check the number of non-null fields.
 </p>

 @param data any key value data, represented by an object or a map, or {@code null}
 @return key/value map to use]]>
      </doc>
    </method>
    <method name="clone" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="T"/>
      <doc>
      <![CDATA[Returns a deep clone of the given key/value data, such that the result is a completely
 independent copy.
 <p>
 This should not be used directly in the implementation of {@code Object.clone()}. Instead use
 {@link #deepCopy(Object, Object)} for that purpose.
 </p>
 <p>
 Final fields cannot be changed and therefore their value won't be copied.
 </p>

 @param data key/value data object or map to clone or {@code null} for a {@code null} return
        value
 @return deep clone or {@code null} for {@code null} input]]>
      </doc>
    </method>
    <method name="deepCopy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="java.lang.Object"/>
      <param name="dest" type="java.lang.Object"/>
      <doc>
      <![CDATA[Makes a deep copy of the given source object into the destination object that is assumed to be
 constructed using {@code Object.clone()}.

 <p>
 Example usage of this method in {@code Object.clone()}:
 </p>

 <pre>
  &#64;Override
  public MyObject clone() {
    try {
      &#64;SuppressWarnings("unchecked")
      MyObject result = (MyObject) super.clone();
      Data.deepCopy(this, result);
      return result;
    } catch (CloneNotSupportedException e) {
      throw new IllegalStateException(e);
    }
  }
 </pre>
 <p>
 Final fields cannot be changed and therefore their value won't be copied.
 </p>

 @param src source object (non-primitive as defined by {@link Data#isPrimitive(Type)}
 @param dest destination object of identical type as source object, and any contained arrays
        must be the same length]]>
      </doc>
    </method>
    <method name="isPrimitive" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns whether the given type is one of the supported primitive classes like number and
 date/time, or is a wildcard of one.

 @param type type or {@code null} for {@code false} result
 @return whether it is a primitive]]>
      </doc>
    </method>
    <method name="isValueOfPrimitiveType" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldValue" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns whether to given value is {@code null} or its class is primitive as defined by
 {@link Data#isPrimitive(Type)}.]]>
      </doc>
    </method>
    <method name="parsePrimitiveValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="stringValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Parses the given string value based on the given primitive type.
 <p>
 Types are parsed as follows:
 <ul>
 <li>{@code null} or is assignable from {@link String} (like {@link Object}): no parsing</li>
 <li>{@code char} or {@link Character}: {@link String#charAt(int) String.charAt}(0) (requires
 length to be exactly 1)</li>
 <li>{@code boolean} or {@link Boolean}: {@link Boolean#valueOf(String)}</li>
 <li>{@code byte} or {@link Byte}: {@link Byte#valueOf(String)}</li>
 <li>{@code short} or {@link Short}: {@link Short#valueOf(String)}</li>
 <li>{@code int} or {@link Integer}: {@link Integer#valueOf(String)}</li>
 <li>{@code long} or {@link Long}: {@link Long#valueOf(String)}</li>
 <li>{@code float} or {@link Float}: {@link Float#valueOf(String)}</li>
 <li>{@code double} or {@link Double}: {@link Double#valueOf(String)}</li>
 <li>{@link BigInteger}: {@link BigInteger#BigInteger(String) BigInteger(String)}</li>
 <li>{@link BigDecimal}: {@link BigDecimal#BigDecimal(String) BigDecimal(String)}</li>
 <li>{@link DateTime}: {@link DateTime#parseRfc3339(String)}</li>
 </ul>
 Note that this may not be the right behavior for some use cases.

 @param type primitive type or {@code null} to parse as a string
 @param stringValue string value to parse or {@code null} for {@code null} result
 @return parsed object or {@code null} for {@code null} input
 @throws IllegalArgumentException if the given class is not a primitive class]]>
      </doc>
    </method>
    <method name="newCollectionInstance" return="java.util.Collection&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a new collection instance for the given type.
 <p>
 Creates a new collection instance specified for the first input collection class that matches
 as follows:
 <ul>
 <li>{@code null} or an array or assignable from {@link ArrayList} (like {@link List} or
 {@link Collection} or {@link Object}): returns an {@link ArrayList}</li>
 <li>assignable from {@link HashSet}: returns a {@link HashSet}</li>
 <li>assignable from {@link TreeSet}: returns a {@link TreeSet}</li>
 <li>else: calls {@link Types#newInstance(Class)}</li>
 </ul>

 @param type type or {@code null} for {@link ArrayList}.
 @return new collection instance
 @throws ClassCastException if result is does not extend {@link Collection}]]>
      </doc>
    </method>
    <method name="newMapInstance" return="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mapClass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a new instance of a map based on the given field class.
 <p>
 Creates a new map instance specified for the first input map class that matches as follows:
 </p>
 <ul>
 <li>{@code null} or assignable from {@link ArrayMap} (like {@link Map} or {@link Object}):
 returns an {@link ArrayMap}</li>
 <li>assignable from {@link TreeMap} (like {@link SortedMap}): returns a {@link TreeMap}</li>
 <li>else: calls {@link Types#newInstance(Class)}</li>
 </ul>

 @param mapClass field class
 @throws ClassCastException if result is does not extend {@link Map}]]>
      </doc>
    </method>
    <method name="resolveWildcardTypeOrTypeVariable" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="java.util.List&lt;java.lang.reflect.Type&gt;"/>
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Aggressively resolves the given type in such a way that the resolved type is not a wildcard
 type or a type variable, returning {@code Object.class} if the type variable cannot be
 resolved.

 @param context context list, ordering from least specific to most specific type context, for
        example container class and then its field
 @param type type or {@code null} for {@code null} result
 @return resolved type (which may be class, parameterized type, or generic array type, but not
         wildcard type or type variable) or {@code null} for {@code null} input]]>
      </doc>
    </method>
    <field name="NULL_BOOLEAN" type="java.lang.Boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The single instance of the magic null object for a {@link Boolean}.]]>
      </doc>
    </field>
    <field name="NULL_STRING" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The single instance of the magic null object for a {@link String}.]]>
      </doc>
    </field>
    <field name="NULL_CHARACTER" type="java.lang.Character"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The single instance of the magic null object for a {@link Character}.]]>
      </doc>
    </field>
    <field name="NULL_BYTE" type="java.lang.Byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The single instance of the magic null object for a {@link Byte}.]]>
      </doc>
    </field>
    <field name="NULL_SHORT" type="java.lang.Short"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The single instance of the magic null object for a {@link Short}.]]>
      </doc>
    </field>
    <field name="NULL_INTEGER" type="java.lang.Integer"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The single instance of the magic null object for a {@link Integer}.]]>
      </doc>
    </field>
    <field name="NULL_FLOAT" type="java.lang.Float"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The single instance of the magic null object for a {@link Float}.]]>
      </doc>
    </field>
    <field name="NULL_LONG" type="java.lang.Long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The single instance of the magic null object for a {@link Long}.]]>
      </doc>
    </field>
    <field name="NULL_DOUBLE" type="java.lang.Double"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The single instance of the magic null object for a {@link Double}.]]>
      </doc>
    </field>
    <field name="NULL_BIG_INTEGER" type="java.math.BigInteger"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The single instance of the magic null object for a {@link BigInteger}.]]>
      </doc>
    </field>
    <field name="NULL_BIG_DECIMAL" type="java.math.BigDecimal"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The single instance of the magic null object for a {@link BigDecimal}.]]>
      </doc>
    </field>
    <field name="NULL_DATE_TIME" type="com.google.api.client.util.DateTime"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The single instance of the magic null object for a {@link DateTime}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Utilities for working with key/value data based on the {@link Key} annotation.

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.Data -->
  <!-- start class com.google.api.client.util.DataUtil -->
  <class name="DataUtil" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="(scheduled to be removed in 1.5) Use {@link Data}">
    <method name="mapOf" return="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.5) Use {@link Data#mapOf(Object)}">
      <param name="data" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the map to use for the given key/value data.

 @param data any key value data, represented by an object or a map, or {@code null}
 @return if {@code data} is a map returns {@code data}; else if {@code data} is {@code null},
         returns an empty map; else returns {@link ReflectionMap} on the data object
 @deprecated (scheduled to be removed in 1.5) Use {@link Data#mapOf(Object)}]]>
      </doc>
    </method>
    <method name="clone" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.5) Use {@link Data#deepCopy(Object, Object)} or
             {@link Data#clone(Object)}">
      <param name="data" type="T"/>
      <doc>
      <![CDATA[Returns a deep clone of the given key/value data, such that the result is a completely
 independent copy.
 <p>
 Note that final fields cannot be changed and therefore their value won't be copied.

 @param data key/value data object or map to clone or {@code null} for a {@code null} return
        value
 @return deep clone or {@code null} for {@code null} input
 @deprecated (scheduled to be removed in 1.5) Use {@link Data#deepCopy(Object, Object)} or
             {@link Data#clone(Object)}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utilities for working with key/value data.

 @since 1.0
 @author Yaniv Inbar
 @deprecated (scheduled to be removed in 1.5) Use {@link Data}]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.DataUtil -->
  <!-- start class com.google.api.client.util.DateTime -->
  <class name="DateTime" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="DateTime" type="java.util.Date, java.util.TimeZone"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DateTime" type="long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DateTime" type="java.util.Date"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DateTime" type="long, java.lang.Integer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DateTime" type="boolean, long, java.lang.Integer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="toStringRfc3339" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Formats the value as an RFC 3339 date/time string.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="parseRfc3339" return="com.google.api.client.util.DateTime"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <exception name="NumberFormatException" type="java.lang.NumberFormatException"/>
      <doc>
      <![CDATA[Parses an RFC 3339 date/time value.]]>
      </doc>
    </method>
    <field name="value" type="long"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Date/time value expressed as the number of ms since the Unix epoch.

  If the time zone is specified, this value is normalized to UTC, so to format this date/time
 value, the time zone shift has to be applied.]]>
      </doc>
    </field>
    <field name="dateOnly" type="boolean"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Specifies whether this is a date-only value.]]>
      </doc>
    </field>
    <field name="tzShift" type="java.lang.Integer"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Time zone shift from UTC in minutes. If {@code null}, no time zone is set, and the time is
 always interpreted as local time.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Immutable representation of a date with an optional time and an optional time zone based on RFC
 3339.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.DateTime -->
  <!-- start class com.google.api.client.util.FieldInfo -->
  <class name="FieldInfo" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="of" return="com.google.api.client.util.FieldInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enumValue" type="java.lang.Enum&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the field information for the given enum value.

 @param enumValue enum value
 @return field information
 @throws IllegalArgumentException if the enum value has no value annotation
 @since 1.4]]>
      </doc>
    </method>
    <method name="of" return="com.google.api.client.util.FieldInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field" type="java.lang.reflect.Field"/>
      <doc>
      <![CDATA[Returns the field information for the given field.

 @param field field or {@code null} for {@code null} result
 @return field information or {@code null} if the field has no {@link #name} or for {@code null}
         input]]>
      </doc>
    </method>
    <method name="getField" return="java.lang.reflect.Field"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the field.

 @since 1.4]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the data key name associated with the field for a non-enum-constant with a {@link Key}
 annotation, or data key value associated with the enum constant with a {@link Value} annotation
 or {@code null} for an enum constant with a {@link NullValue} annotation.

 <p>
 This string is interned.
 </p>

 @since 1.4]]>
      </doc>
    </method>
    <method name="getType" return="java.lang.Class&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the field's type.

 @since 1.4]]>
      </doc>
    </method>
    <method name="getGenericType" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the field's generic type, which is a class, parameterized type, generic array type, or
 type variable, but not a wildcard type.

 @since 1.4]]>
      </doc>
    </method>
    <method name="isFinal" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the field is final.

 @since 1.4]]>
      </doc>
    </method>
    <method name="isPrimitive" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the field is primitive as defined by {@link Data#isPrimitive(Type)}.

 @since 1.4]]>
      </doc>
    </method>
    <method name="getValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the value of the field in the given object instance using reflection.]]>
      </doc>
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Sets to the given value of the field in the given object instance using reflection.
 <p>
 If the field is final, it checks that value being set is identical to the existing value.]]>
      </doc>
    </method>
    <method name="getClassInfo" return="com.google.api.client.util.ClassInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the class information of the field's declaring class.]]>
      </doc>
    </method>
    <method name="enumValue" return="T extends java.lang.Enum&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isPrimitive" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.5) Use {@link Data#isPrimitive(Type)}">
      <param name="fieldClass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns whether the given field class is one of the supported primitive types like number and
 date/time.

 @deprecated (scheduled to be removed in 1.5) Use {@link Data#isPrimitive(Type)}]]>
      </doc>
    </method>
    <method name="isPrimitive" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.5) Use {@link Data#isPrimitive(Type)} on the
             {@link Object#getClass()}">
      <param name="fieldValue" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns whether to given value is {@code null} or its class is primitive as defined by
 {@link #isPrimitive(Class)}.

 @deprecated (scheduled to be removed in 1.5) Use {@link Data#isPrimitive(Type)} on the
             {@link Object#getClass()}]]>
      </doc>
    </method>
    <method name="getFieldValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field" type="java.lang.reflect.Field"/>
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the value of the given field in the given object instance using reflection.]]>
      </doc>
    </method>
    <method name="setFieldValue"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field" type="java.lang.reflect.Field"/>
      <param name="obj" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Sets to the given value of the given field in the given object instance using reflection.
 <p>
 If the field is final, it checks that value being set is identical to the existing value.]]>
      </doc>
    </method>
    <method name="parsePrimitiveValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="(scheduled to be removed in 1.5) Use {@link Data#parsePrimitiveValue(Type, String)}">
      <param name="primitiveClass" type="java.lang.Class&lt;?&gt;"/>
      <param name="stringValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Parses the given string value based on the given primitive class.
 <p>
 Types are parsed as follows:
 <ul>
 <li>{@code null} or {@link String}: no parsing</li>
 <li>{@code char} or {@link Character}: {@link String#charAt(int) String.charAt}(0) (requires
 length to be exactly 1)</li>
 <li>{@code boolean} or {@link Boolean}: {@link Boolean#valueOf(String)}</li>
 <li>{@code byte} or {@link Byte}: {@link Byte#valueOf(String)}</li>
 <li>{@code short} or {@link Short}: {@link Short#valueOf(String)}</li>
 <li>{@code int} or {@link Integer}: {@link Integer#valueOf(String)}</li>
 <li>{@code long} or {@link Long}: {@link Long#valueOf(String)}</li>
 <li>{@code float} or {@link Float}: {@link Float#valueOf(String)}</li>
 <li>{@code double} or {@link Double}: {@link Double#valueOf(String)}</li>
 <li>{@link BigInteger}: {@link BigInteger#BigInteger(String) BigInteger(String)}</li>
 <li>{@link BigDecimal}: {@link BigDecimal#BigDecimal(String) BigDecimal(String)}</li>
 <li>{@link DateTime}: {@link DateTime#parseRfc3339(String)}</li>
 </ul>
 Note that this may not be the right behavior for some use cases.

 @param primitiveClass primitive class (see {@link #isPrimitive(Class)} or {@code null} to parse
        as a string
 @param stringValue string value to parse or {@code null} for {@code null} result
 @return parsed object or {@code null} for {@code null} input
 @throws IllegalArgumentException if the given class is not a primitive class as defined by
         {@link #isPrimitive(Class)}
 @deprecated (scheduled to be removed in 1.5) Use {@link Data#parsePrimitiveValue(Type, String)}]]>
      </doc>
    </method>
    <field name="isFinal" type="boolean"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be removed in 1.5) Use {@link #isFinal()}">
      <doc>
      <![CDATA[Whether the field is final.

 @deprecated (scheduled to be removed in 1.5) Use {@link #isFinal()}]]>
      </doc>
    </field>
    <field name="isPrimitive" type="boolean"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be made private in 1.5) Use {@link #isPrimitive()}">
      <doc>
      <![CDATA[Whether the field class is "primitive" as defined by {@link Data#isPrimitive(Type)}.

 @deprecated (scheduled to be made private in 1.5) Use {@link #isPrimitive()}]]>
      </doc>
    </field>
    <field name="type" type="java.lang.Class&lt;?&gt;"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be removed in 1.5) Use {@link #getType()}">
      <doc>
      <![CDATA[Field class.

 @deprecated (scheduled to be removed in 1.5) Use {@link #getType()}]]>
      </doc>
    </field>
    <field name="field" type="java.lang.reflect.Field"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be made private in 1.5) Use {@link #getField()}">
      <doc>
      <![CDATA[Field.

 @deprecated (scheduled to be made private in 1.5) Use {@link #getField()}]]>
      </doc>
    </field>
    <field name="name" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="(scheduled to be made private in 1.5) Use {@link #getName()}">
      <doc>
      <![CDATA[Data key name associated with the field for a non-enum-constant with a {@link Key} annotation,
 or data key value associated with the enum constant with a {@link Value} annotation or {@code
 null} for an enum constant with a {@link NullValue} annotation.

 <p>
 This string is interned.
 </p>

 @deprecated (scheduled to be made private in 1.5) Use {@link #getName()}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Parses field information to determine data key name/value pair associated with the field.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.FieldInfo -->
  <!-- start class com.google.api.client.util.GenericData -->
  <class name="GenericData" extends="java.util.AbstractMap&lt;java.lang.String, java.lang.Object&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Cloneable"/>
    <constructor name="GenericData"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.Object"/>
    </method>
    <method name="put" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Sets the given field value (may be {@code null}) for the given field name. Any existing value
 for the field will be overwritten. It may be more slightly more efficient than
 {@link #put(String, Object)} because it avoids accessing the field's original value.]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends java.lang.String, ?&gt;"/>
    </method>
    <method name="remove" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.Object"/>
    </method>
    <method name="entrySet" return="java.util.Set&lt;java.util.Map.Entry&lt;java.lang.String, java.lang.Object&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="com.google.api.client.util.GenericData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Makes a "deep" clone of the generic data, in which the clone is completely independent of the
 original.]]>
      </doc>
    </method>
    <field name="unknownFields" type="com.google.api.client.util.ArrayMap&lt;java.lang.String, java.lang.Object&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Map of unknown fields.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Generic data that stores all unknown data key name/value pairs.
 <p>
 Subclasses can declare fields for known data keys using the {@link Key} annotation. Each field
 can be of any visibility (private, package private, protected, or public) and must not be static.
 {@code null} unknown data key names are not allowed, but {@code null} data values are allowed.
 <p>
 Iteration order of the data keys is based on the sorted (ascending) key names of the declared
 fields, followed by the iteration order of all of the unknown data key name/value pairs.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.GenericData -->
  <!-- start class com.google.api.client.util.Key -->
  <class name="Key"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Use this annotation to specify that a field is a data key, optionally providing the data key name
 to use.
 <p>
 If the data key name is not specified, the default is the Java field's name. For example:
 </p>

 <pre><code>
  public class A {

    // uses data key name of "dataKeyNameMatchesFieldName"
    &#64;Key
    public String dataKeyNameMatchesFieldName;

    // uses data key name of "some_other_name"
    &#64;Key("some_other_name")
    private String dataKeyNameIsOverriden;

    // not a data key
    private String notADataKey;
  }
 </code></pre>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.Key -->
  <!-- start class com.google.api.client.util.NullValue -->
  <class name="NullValue"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Use this annotation to specify that an enum constant is the "null" data value to use for
 {@link Data#nullOf(Class)}.
 <p>
 See {@link Value} for an example.
 </p>

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.NullValue -->
  <!-- start class com.google.api.client.util.ReflectionMap -->
  <class name="ReflectionMap" extends="java.util.AbstractMap&lt;java.lang.String, java.lang.Object&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="(scheduled to be removed in 1.5) Use {@link Data#mapOf(Object)}">
    <constructor name="ReflectionMap" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="entrySet" return="java.util.Set&lt;java.util.Map.Entry&lt;java.lang.String, java.lang.Object&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Map that uses {@link ClassInfo} to parse the key/value pairs into a map.
 <p>
 Iteration order of the keys is based on the sorted (ascending) key names.

 @deprecated (scheduled to be removed in 1.5) Use {@link Data#mapOf(Object)}
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.ReflectionMap -->
  <!-- start class com.google.api.client.util.Strings -->
  <class name="Strings" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="toBytesUtf8" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a new byte array that is the result of encoding the given string into a sequence of
 bytes using the {@code "UTF-8"} charset.

 @param string given string
 @return resultant byte array
 @since 1.2]]>
      </doc>
    </method>
    <method name="fromBytesUtf8" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Returns a new {@code String} by decoding the specified array of bytes using the {@code "UTF-8"}
 charset.

 <p>
 The length of the new {@code String} is a function of the charset, and hence may not be equal
 to the length of the byte array.
 </p>

 @param bytes bytes to be decoded into characters
 @return resultant string
 @since 1.2]]>
      </doc>
    </method>
    <field name="VERSION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Current version of the Google API Client Library for Java.

 @since 1.3]]>
      </doc>
    </field>
    <field name="LINE_SEPARATOR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Line separator to use for this OS, i.e. {@code "\n"} or {@code "\r\n"}.]]>
      </doc>
    </field>
    <field name="UTF8_CHARSET" type="java.nio.charset.Charset"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="(scheduled to be removed in 1.5) Use {@link Charsets#UTF_8}">
      <doc>
      <![CDATA[UTF-8 character set.

 @since 1.3
 @deprecated (scheduled to be removed in 1.5) Use {@link Charsets#UTF_8}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Utilities for strings.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.Strings -->
  <!-- start class com.google.api.client.util.Types -->
  <class name="Types" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getSuperParameterizedType" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="superClass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the parameterized type that is or extends the given type that matches the given super
 class.

 <p>
 For example, if the input type is {@code HashMap<String,Integer>} and the input super class is
 {@code Map.class}, it will return the extended parameterized type {@link Map}, but which
 retains the actual type information from the original {@code HashMap}.
 </p>

 @param type class or parameterized type
 @param superClass super class
 @return matching parameterized type or {@code null}]]>
      </doc>
    </method>
    <method name="isAssignableToOrFrom" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classToCheck" type="java.lang.Class&lt;?&gt;"/>
      <param name="anotherClass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns whether a class is either assignable to or from another class

 @param classToCheck class to check
 @param anotherClass another class]]>
      </doc>
    </method>
    <method name="newInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Creates a new instance of the given class by invoking its default constructor.

 <p>
 The given class must be public and must have a public default constructor, and must not be an
 array or an interface or be abstract. If an enclosing class, it must be static.
 </p>]]>
      </doc>
    </method>
    <method name="isArray" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns whether the given type is an array.]]>
      </doc>
    </method>
    <method name="getArrayComponentType" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns the component type of the given array type, assuming {@link #isArray(Type)}.

 <p>
 Return type will either be class, parameterized type, generic array type, or type variable, but
 not a wildcard type.
 </p>

 @throws ClassCastException if {@link #isArray(Type)} is false]]>
      </doc>
    </method>
    <method name="getRawClass" return="java.lang.Class&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parameterType" type="java.lang.reflect.ParameterizedType"/>
      <doc>
      <![CDATA[Returns the raw class for the given parameter type as defined in
 {@link ParameterizedType#getRawType()}.

 @param parameterType parameter type
 @return raw class]]>
      </doc>
    </method>
    <method name="getBound" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="wildcardType" type="java.lang.reflect.WildcardType"/>
      <doc>
      <![CDATA[Returns the only bound of the given wildcard type.

 @param wildcardType wildcard type
 @return only bound or {@code Object.class} for none]]>
      </doc>
    </method>
    <method name="resolveTypeVariable" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="java.util.List&lt;java.lang.reflect.Type&gt;"/>
      <param name="typeVariable" type="java.lang.reflect.TypeVariable&lt;?&gt;"/>
      <doc>
      <![CDATA[Resolves the actual type of the given type variable that comes from a field type based on the
 given context list.
 <p>
 In case the type variable can be resolved partially, it will return the partially resolved type
 variable.
 </p>

 @param context context list, ordering from least specific to most specific type context, for
        example container class and then its field
 @param typeVariable type variable
 @return resolved or partially resolved actual type (type variable, class, parameterized type,
         or generic array type, but not wildcard type) or {@code null} if unable to resolve at
         all]]>
      </doc>
    </method>
    <method name="getRawArrayComponentType" return="java.lang.Class&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="java.util.List&lt;java.lang.reflect.Type&gt;"/>
      <param name="componentType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns the raw array component type to use -- for example for the first parameter of
 {@link Array#newInstance(Class, int)} -- for the given component type.

 @param context context list, ordering from least specific to most specific type context, for
        example container class and then its field
 @param componentType array component type or {@code null} for {@code Object.class} result
 @return raw array component type]]>
      </doc>
    </method>
    <method name="getIterableParameter" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterableType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns the type parameter of {@link Iterable} that is assignable from the given iterable type.

 <p>
 For example, for the type {@code ArrayList<Integer>} -- or for a class that extends {@code
 ArrayList<Integer>} -- it will return {@code Integer}.
 </p>

 @param iterableType iterable type (must extend {@link Iterable})
 @return type parameter, which may be any type]]>
      </doc>
    </method>
    <method name="getMapValueParameter" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mapType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns the value type parameter of {@link Map} that is assignable from the given map type.

 <p>
 For example, for the type {@code Map<String, Integer>} -- or for a class that extends {@code
 Map<String, Integer>} -- it will return {@code Integer}.
 </p>

 @param mapType map type (must extend {@link Map})
 @return type parameter, which may be any type]]>
      </doc>
    </method>
    <method name="iterableOf" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns an iterable for an input iterable or array value.

 <p>
 If the input value extends {@link Iterable}, it will just return the input value. Otherwise, it
 will return an iterable that can handle arrays of primitive and non-primitive component type.
 </p>

 @param value iterable (extends {@link Iterable}) or array value
 @return iterable]]>
      </doc>
    </method>
    <method name="toArray" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;?&gt;"/>
      <param name="componentType" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a new array of the given component type (possibly a Java primitive) that is a copy of
 the content of the given collection.

 @param collection collection
 @param componentType component type (possibly a Java primitive)
 @return new array]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utilities for working with Java types.

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.Types -->
  <!-- start class com.google.api.client.util.Value -->
  <class name="Value"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Use this annotation to specify that an enum constant is a string data value, optionally providing
 the string data value to use.
 <p>
 If the string data value is not specified, the default is the Java field's name. For example:
 </p>

 <pre>
  public enum A {

    // value is "USE_FIELD_NAME"
    &#64;Value
    USE_FIELD_NAME,

    // value is "specifiedValue"
    &#64;Value("specifiedValue")
    USE_SPECIFIED_VALUE, 

    // value is null
    &#64;NullValue
    NULL_VALUE

    // not a value
    NOT_A_VALUE
  }
 </pre>

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.Value -->
</package>
<package name="com.google.api.client.util.escape">
  <!-- start class com.google.api.client.util.escape.CharEscapers -->
  <class name="CharEscapers" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="escapeUri" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Escapes the string value so it can be safely included in URIs. For details on escaping URIs,
 see section 2.4 of <a href="http://www.ietf.org/rfc/rfc2396.txt">RFC 2396</a>.

 <p>
 When encoding a String, the following rules apply:
 <ul>
 <li>The alphanumeric characters "a" through "z", "A" through "Z" and "0" through "9" remain the
 same.
 <li>The special characters ".", "-", "*", and "_" remain the same.
 <li>The space character " " is converted into a plus sign "+".
 <li>All other characters are converted into one or more bytes using UTF-8 encoding and each
 byte is then represented by the 3-character string "%XY", where "XY" is the two-digit,
 uppercase, hexadecimal representation of the byte value.
 <ul>

 <p>
 <b>Note</b>: Unlike other escapers, URI escapers produce uppercase hexadecimal sequences. From
 <a href="http://www.ietf.org/rfc/rfc3986.txt"> RFC 3986</a>:<br> <i>"URI producers and
 normalizers should use uppercase hexadecimal digits for all percent-encodings."</i>

 <p>
 This escaper has identical behavior to (but is potentially much faster than):
 <ul>
 <li>{@link java.net.URLEncoder#encode(String, String)} with the encoding name "UTF-8"
 </ul>]]>
      </doc>
    </method>
    <method name="decodeUri" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <doc>
      <![CDATA[Percent-decodes a US-ASCII string into a Unicode string. UTF-8 encoding is used to determine
 what characters are represented by any consecutive sequences of the form "%<i>XX</i>".

 <p>
 This replaces each occurrence of '+' with a space, ' '. So this method should not be used for
 non application/x-www-form-urlencoded strings such as host and path.

 @param uri a percent-encoded US-ASCII string
 @return a Unicode string]]>
      </doc>
    </method>
    <method name="escapeUriPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Escapes the string value so it can be safely included in URI path segments. For details on
 escaping URIs, see section 2.4 of <a href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>.

 <p>
 When encoding a String, the following rules apply:
 <ul>
 <li>The alphanumeric characters "a" through "z", "A" through "Z" and "0" through "9" remain the
 same.
 <li>The unreserved characters ".", "-", "~", and "_" remain the same.
 <li>The general delimiters "@" and ":" remain the same.
 <li>The subdelimiters "!", "$", "&amp;", "'", "(", ")", "*", ",", ";", and "=" remain the same.
 <li>The space character " " is converted into %20.
 <li>All other characters are converted into one or more bytes using UTF-8 encoding and each
 byte is then represented by the 3-character string "%XY", where "XY" is the two-digit,
 uppercase, hexadecimal representation of the byte value.
 </ul>

 <p>
 <b>Note</b>: Unlike other escapers, URI escapers produce uppercase hexadecimal sequences. From
 <a href="http://www.ietf.org/rfc/rfc3986.txt"> RFC 3986</a>:<br> <i>"URI producers and
 normalizers should use uppercase hexadecimal digits for all percent-encodings."</i>]]>
      </doc>
    </method>
    <method name="escapeUriQuery" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Escapes the string value so it can be safely included in URI query string segments. When the
 query string consists of a sequence of name=value pairs separated by &amp;, the names and
 values should be individually encoded. If you escape an entire query string in one pass with
 this escaper, then the "=" and "&amp;" characters used as separators will also be escaped.

 <p>
 This escaper is also suitable for escaping fragment identifiers.

 <p>
 For details on escaping URIs, see section 2.4 of <a
 href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>.

 <p>
 When encoding a String, the following rules apply:
 <ul>
 <li>The alphanumeric characters "a" through "z", "A" through "Z" and "0" through "9" remain the
 same.
 <li>The unreserved characters ".", "-", "~", and "_" remain the same.
 <li>The general delimiters "@" and ":" remain the same.
 <li>The path delimiters "/" and "?" remain the same.
 <li>The subdelimiters "!", "$", "'", "(", ")", "*", ",", and ";", remain the same.
 <li>The space character " " is converted into %20.
 <li>The equals sign "=" is converted into %3D.
 <li>The ampersand "&amp;" is converted into %26.
 <li>All other characters are converted into one or more bytes using UTF-8 encoding and each
 byte is then represented by the 3-character string "%XY", where "XY" is the two-digit,
 uppercase, hexadecimal representation of the byte value.
 </ul>

 <p>
 <b>Note</b>: Unlike other escapers, URI escapers produce uppercase hexadecimal sequences. From
 <a href="http://www.ietf.org/rfc/rfc3986.txt"> RFC 3986</a>:<br> <i>"URI producers and
 normalizers should use uppercase hexadecimal digits for all percent-encodings."</i>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility functions for dealing with {@code CharEscaper}s, and some commonly used {@code
 CharEscaper} instances.

 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.escape.CharEscapers -->
  <!-- start class com.google.api.client.util.escape.Escaper -->
  <class name="Escaper" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Escaper"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="escape" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the escaped form of a given literal string.

 <p>
 Note that this method may treat input characters differently depending on the specific escaper
 implementation.
 <ul>
 <li>{@link UnicodeEscaper} handles <a href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a>
 correctly, including surrogate character pairs. If the input is badly formed the escaper should
 throw {@link IllegalArgumentException}.
 </ul>

 @param string the literal string to be escaped
 @return the escaped form of {@code string}
 @throws NullPointerException if {@code string} is null
 @throws IllegalArgumentException if {@code string} contains badly formed UTF-16 or cannot be
         escaped for any other reason]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object that converts literal text into a format safe for inclusion in a particular context
 (such as an XML document). Typically (but not always), the inverse process of "unescaping" the
 text is performed automatically by the relevant parser.

 <p>
 For example, an XML escaper would convert the literal string {@code "Foo<Bar>"} into {@code
 "Foo&lt;Bar&gt;"} to prevent {@code "<Bar>"} from being confused with an XML tag. When the
 resulting XML document is parsed, the parser API will return this text as the original literal
 string {@code "Foo<Bar>"}.

 <p>
 An {@code Escaper} instance is required to be stateless, and safe when used concurrently by
 multiple threads.

 <p>
 Several popular escapers are defined as constants in the class {@link CharEscapers}.

 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.escape.Escaper -->
  <!-- start class com.google.api.client.util.escape.PercentEscaper -->
  <class name="PercentEscaper" extends="com.google.api.client.util.escape.UnicodeEscaper"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PercentEscaper" type="java.lang.String, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a URI escaper with the specified safe characters and optional handling of the space
 character.

 @param safeChars a non null string specifying additional safe characters for this escaper (the
        ranges 0..9, a..z and A..Z are always safe and should not be specified here)
 @param plusForSpace true if ASCII space should be escaped to {@code +} rather than {@code %20}
 @throws IllegalArgumentException if any of the parameters were invalid]]>
      </doc>
    </constructor>
    <method name="nextEscapeIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="csq" type="java.lang.CharSequence"/>
      <param name="index" type="int"/>
      <param name="end" type="int"/>
    </method>
    <method name="escape" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
    </method>
    <method name="escape" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="cp" type="int"/>
      <doc>
      <![CDATA[Escapes the given Unicode code point in UTF-8.]]>
      </doc>
    </method>
    <field name="SAFECHARS_URLENCODER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A string of safe characters that mimics the behavior of {@link java.net.URLEncoder}.

 TODO: Fix escapers to be compliant with RFC 3986]]>
      </doc>
    </field>
    <field name="SAFEPATHCHARS_URLENCODER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A string of characters that do not need to be encoded when used in URI path segments, as
 specified in RFC 3986. Note that some of these characters do need to be escaped when used in
 other parts of the URI.]]>
      </doc>
    </field>
    <field name="SAFEQUERYSTRINGCHARS_URLENCODER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A string of characters that do not need to be encoded when used in URI query strings, as
 specified in RFC 3986. Note that some of these characters do need to be escaped when used in
 other parts of the URI.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A {@code UnicodeEscaper} that escapes some set of Java characters using the URI percent encoding
 scheme. The set of safe characters (those which remain unescaped) can be specified on
 construction.

 <p>
 For details on escaping URIs for use in web pages, see section 2.4 of <a
 href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>.

 <p>
 When encoding a String, the following rules apply:
 <ul>
 <li>The alphanumeric characters "a" through "z", "A" through "Z" and "0" through "9" remain the
 same.
 <li>Any additionally specified safe characters remain the same.
 <li>If {@code plusForSpace} was specified, the space character " " is converted into a plus sign
 "+".
 <li>All other characters are converted into one or more bytes using UTF-8 encoding and each byte
 is then represented by the 3-character string "%XY", where "XY" is the two-digit, uppercase,
 hexadecimal representation of the byte value.
 </ul>

 <p>
 RFC 2396 specifies the set of unreserved characters as "-", "_", ".", "!", "~", "*", "'", "(" and
 ")". It goes on to state:

 <p>
 <i>Unreserved characters can be escaped without changing the semantics of the URI, but this
 should not be done unless the URI is being used in a context that does not allow the unescaped
 character to appear.</i>

 <p>
 For performance reasons the only currently supported character encoding of this class is UTF-8.

 <p>
 <b>Note</b>: This escaper produces uppercase hexadecimal sequences. From <a
 href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>:<br> <i>"URI producers and normalizers
 should use uppercase hexadecimal digits for all percent-encodings."</i>

 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.escape.PercentEscaper -->
  <!-- start class com.google.api.client.util.escape.UnicodeEscaper -->
  <class name="UnicodeEscaper" extends="com.google.api.client.util.escape.Escaper"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UnicodeEscaper"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="escape" return="char[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="cp" type="int"/>
      <doc>
      <![CDATA[Returns the escaped form of the given Unicode code point, or {@code null} if this code point
 does not need to be escaped. When called as part of an escaping operation, the given code point
 is guaranteed to be in the range {@code 0 <= cp <= Character#MAX_CODE_POINT}.

 <p>
 If an empty array is returned, this effectively strips the input character from the resulting
 text.

 <p>
 If the character does not need to be escaped, this method should return {@code null}, rather
 than an array containing the character representation of the code point. This enables the
 escaping algorithm to perform more efficiently.

 <p>
 If the implementation of this method cannot correctly handle a particular code point then it
 should either throw an appropriate runtime exception or return a suitable replacement
 character. It must never silently discard invalid input as this may constitute a security risk.

 @param cp the Unicode code point to escape if necessary
 @return the replacement characters, or {@code null} if no escaping was needed]]>
      </doc>
    </method>
    <method name="nextEscapeIndex" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="csq" type="java.lang.CharSequence"/>
      <param name="start" type="int"/>
      <param name="end" type="int"/>
      <doc>
      <![CDATA[Scans a sub-sequence of characters from a given {@link CharSequence}, returning the index of
 the next character that requires escaping.

 <p>
 <b>Note:</b> When implementing an escaper, it is a good idea to override this method for
 efficiency. The base class implementation determines successive Unicode code points and invokes
 {@link #escape(int)} for each of them. If the semantics of your escaper are such that code
 points in the supplementary range are either all escaped or all unescaped, this method can be
 implemented more efficiently using {@link CharSequence#charAt(int)}.

 <p>
 Note however that if your escaper does not escape characters in the supplementary range, you
 should either continue to validate the correctness of any surrogate characters encountered or
 provide a clear warning to users that your escaper does not validate its input.

 <p>
 See {@link PercentEscaper} for an example.

 @param csq a sequence of characters
 @param start the index of the first character to be scanned
 @param end the index immediately after the last character to be scanned
 @throws IllegalArgumentException if the scanned sub-sequence of {@code csq} contains invalid
         surrogate pairs]]>
      </doc>
    </method>
    <method name="escape" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the escaped form of a given literal string.

 <p>
 If you are escaping input in arbitrary successive chunks, then it is not generally safe to use
 this method. If an input string ends with an unmatched high surrogate character, then this
 method will throw {@link IllegalArgumentException}. You should ensure your input is valid <a
 href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a> before calling this method.

 @param string the literal string to be escaped
 @return the escaped form of {@code string}
 @throws NullPointerException if {@code string} is null
 @throws IllegalArgumentException if invalid surrogate characters are encountered]]>
      </doc>
    </method>
    <method name="escapeSlow" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Returns the escaped form of a given literal string, starting at the given index. This method is
 called by the {@link #escape(String)} method when it discovers that escaping is required. It is
 protected to allow subclasses to override the fastpath escaping function to inline their
 escaping test.

 <p>
 This method is not reentrant and may only be invoked by the top level {@link #escape(String)}
 method.

 @param s the literal string to be escaped
 @param index the index to start escaping from
 @return the escaped form of {@code string}
 @throws NullPointerException if {@code string} is null
 @throws IllegalArgumentException if invalid surrogate characters are encountered]]>
      </doc>
    </method>
    <method name="codePointAt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="seq" type="java.lang.CharSequence"/>
      <param name="index" type="int"/>
      <param name="end" type="int"/>
      <doc>
      <![CDATA[Returns the Unicode code point of the character at the given index.

 <p>
 Unlike {@link Character#codePointAt(CharSequence, int)} or {@link String#codePointAt(int)} this
 method will never fail silently when encountering an invalid surrogate pair.

 <p>
 The behaviour of this method is as follows:
 <ol>
 <li>If {@code index >= end}, {@link IndexOutOfBoundsException} is thrown.
 <li><b>If the character at the specified index is not a surrogate, it is returned.</b>
 <li>If the first character was a high surrogate value, then an attempt is made to read the next
 character.
 <ol>
 <li><b>If the end of the sequence was reached, the negated value of the trailing high surrogate
 is returned.</b>
 <li><b>If the next character was a valid low surrogate, the code point value of the high/low
 surrogate pair is returned.</b>
 <li>If the next character was not a low surrogate value, then {@link IllegalArgumentException}
 is thrown.
 </ol>
 <li>If the first character was a low surrogate value, {@link IllegalArgumentException} is
 thrown.
 </ol>

 @param seq the sequence of characters from which to decode the code point
 @param index the index of the first character to decode
 @param end the index beyond the last valid character to decode
 @return the Unicode code point for the given index or the negated value of the trailing high
         surrogate character at the end of the sequence]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An {@link Escaper} that converts literal text into a format safe for inclusion in a particular
 context (such as an XML document). Typically (but not always), the inverse process of
 "unescaping" the text is performed automatically by the relevant parser.

 <p>
 For example, an XML escaper would convert the literal string {@code "Foo<Bar>"} into {@code
 "Foo&lt;Bar&gt;"} to prevent {@code "<Bar>"} from being confused with an XML tag. When the
 resulting XML document is parsed, the parser API will return this text as the original literal
 string {@code "Foo<Bar>"}.

 <p>
 As there are important reasons, including potential security issues, to handle Unicode correctly
 if you are considering implementing a new escaper you should favor using UnicodeEscaper wherever
 possible.

 <p>
 A {@code UnicodeEscaper} instance is required to be stateless, and safe when used concurrently by
 multiple threads.

 <p>
 Several popular escapers are defined as constants in the class {@link CharEscapers}. To create
 your own escapers extend this class and implement the {@link #escape(int)} method.

 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.escape.UnicodeEscaper -->
</package>
<package name="com.google.api.client.xml">
  <!-- start class com.google.api.client.xml.GenericXml -->
  <class name="GenericXml" extends="com.google.api.client.util.GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Cloneable"/>
    <constructor name="GenericXml"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="clone" return="com.google.api.client.xml.GenericXml"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="name" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Optional XML element local name prefixed by its namespace alias -- for example {@code
 "atom:entry"} -- or {@code null} if not set.]]>
      </doc>
    </field>
    <field name="namespaceDictionary" type="com.google.api.client.xml.XmlNamespaceDictionary"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Optional namespace dictionary or {@code null} if not set.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Generic XML data that stores all unknown key name/value pairs.

 <p>
 Each data key name maps into the name of the XPath expression value for the XML element,
 attribute, or text content (using {@code "text()"}). Subclasses can declare fields for known XML
 content using the {@link Key} annotation. Each field can be of any visibility (private, package
 private, protected, or public) and must not be static. {@code null} unknown data key names are
 not allowed, but {@code null} data values are allowed.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.GenericXml -->
  <!-- start class com.google.api.client.xml.Xml -->
  <class name="Xml" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="createSerializer" return="XmlSerializer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new XML serializer.

 @throws IllegalArgumentException if encountered an {@link XmlPullParserException}]]>
      </doc>
    </method>
    <method name="createParser" return="XmlPullParser"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
      <doc>
      <![CDATA[Returns a new XML pull parser.]]>
      </doc>
    </method>
    <method name="toStringOf" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Shows a debug string representation of an element data object of key/value pairs.
 <p>
 It will make up something for the element name and XML namespaces. If those are known, it is
 better to use {@link XmlNamespaceDictionary#toStringOf(String, Object)}.

 @param element element data object of key/value pairs ({@link GenericXml}, {@link Map}, or any
        object with public fields)]]>
      </doc>
    </method>
    <method name="parseElement"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parser" type="XmlPullParser"/>
      <param name="destination" type="java.lang.Object"/>
      <param name="namespaceDictionary" type="com.google.api.client.xml.XmlNamespaceDictionary"/>
      <param name="customizeParser" type="com.google.api.client.xml.Xml.CustomizeParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
      <doc>
      <![CDATA[Parses an XML element using the given XML pull parser into the given destination object.

 <p>
 Requires the the current event be {@link XmlPullParser#START_TAG} (skipping any initial
 {@link XmlPullParser#START_DOCUMENT}) of the element being parsed. At normal parsing
 completion, the current event will either be {@link XmlPullParser#END_TAG} of the element being
 parsed, or the {@link XmlPullParser#START_TAG} of the requested {@code atom:entry}.
 </p>

 @param parser XML pull parser
 @param destination optional destination object to parser into or {@code null} to ignore XML
        content
 @param namespaceDictionary XML namespace dictionary to store unknown namespaces
 @param customizeParser optional parser customizer or {@code null} for none]]>
      </doc>
    </method>
    <doc>
    <![CDATA[XML utilities.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.Xml -->
  <!-- start class com.google.api.client.xml.Xml.CustomizeParser -->
  <class name="Xml.CustomizeParser" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Xml.CustomizeParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="stopBeforeStartTag" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="namespace" type="java.lang.String"/>
      <param name="localName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns whether to stop parsing when reaching the start tag of an XML element before it has
 been processed. Only called if the element is actually being processed. By default, returns
 {@code false}, but subclasses may override.

 @param namespace XML element's namespace URI
 @param localName XML element's local name]]>
      </doc>
    </method>
    <method name="stopAfterEndTag" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="namespace" type="java.lang.String"/>
      <param name="localName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns whether to stop parsing when reaching the end tag of an XML element after it has been
 processed. Only called if the element is actually being processed. By default, returns {@code
 false}, but subclasses may override.

 @param namespace XML element's namespace URI
 @param localName XML element's local name]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Customizes the behavior of XML parsing. Subclasses may override any methods they need to
 customize behavior.]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.Xml.CustomizeParser -->
  <!-- start class com.google.api.client.xml.XmlNamespaceDictionary -->
  <class name="XmlNamespaceDictionary" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="XmlNamespaceDictionary"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAliasForUri" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the namespace alias (or {@code ""} for the default namespace) for the given namespace
 URI.

 @param uri namespace URI
 @since 1.3]]>
      </doc>
    </method>
    <method name="getUriForAlias" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="alias" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the namespace URI for the given namespace alias (or {@code ""} for the default
 namespace).

 @param alias namespace alias (or {@code ""} for the default namespace)
 @since 1.3]]>
      </doc>
    </method>
    <method name="getAliasToUriMap" return="java.util.Map&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodified set of map entries for the map from namespace alias (or {@code ""} for
 the default namespace) to namespace URI.

 @since 1.3]]>
      </doc>
    </method>
    <method name="getUriToAliasMap" return="java.util.Map&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodified set of map entries for the map from namespace URI to namespace alias (or
 {@code ""} for the default namespace).

 @since 1.3]]>
      </doc>
    </method>
    <method name="set" return="com.google.api.client.xml.XmlNamespaceDictionary"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="alias" type="java.lang.String"/>
      <param name="uri" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds a namespace of the given alias and URI.

 <p>
 If the uri is {@code null}, the namespace alias will be removed. Similarly, if the alias is
 {@code null}, the namespace URI will be removed. Otherwise, if the alias is already mapped to a
 different URI, it will be remapped to the new URI. Similarly, if a URI is already mapped to a
 different alias, it will be remapped to the new alias.
 </p>

 @param alias alias or {@code null} to remove the namespace URI
 @param uri namespace URI or {@code null} to remove the namespace alias
 @return this namespace dictionary
 @since 1.3]]>
      </doc>
    </method>
    <method name="toStringOf" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elementName" type="java.lang.String"/>
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Shows a debug string representation of an element data object of key/value pairs.

 @param element element data object ({@link GenericXml}, {@link Map}, or any object with public
        fields)
 @param elementName optional XML element local name prefixed by its namespace alias -- for
        example {@code "atom:entry"} -- or {@code null} to make up something]]>
      </doc>
    </method>
    <method name="serialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serializer" type="XmlSerializer"/>
      <param name="elementNamespaceUri" type="java.lang.String"/>
      <param name="elementLocalName" type="java.lang.String"/>
      <param name="element" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Shows a debug string representation of an element data object of key/value pairs.

 @param element element data object ({@link GenericXml}, {@link Map}, or any object with public
        fields)
 @param elementNamespaceUri XML namespace URI or {@code null} for no namespace
 @param elementLocalName XML local name
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="serialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serializer" type="XmlSerializer"/>
      <param name="elementName" type="java.lang.String"/>
      <param name="element" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Shows a debug string representation of an element data object of key/value pairs.

 @param element element data object ({@link GenericXml}, {@link Map}, or any object with public
        fields)
 @param elementName XML element local name prefixed by its namespace alias
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Thread-safe XML namespace dictionary that provides a one-to-one map of namespace alias to URI.

 <p>
 A namespace alias is uniquely mapped to a single namespace URI, and a namespace URI is uniquely
 mapped to a single namespace alias. In other words, it is not possible to have duplicates.
 </p>

 <p>
 Sample usage:

 <pre>{@code
  static final XmlNamespaceDictionary DICTIONARY = new XmlNamespaceDictionary()
      .set("", "http://www.w3.org/2005/Atom")
      .set("activity", "http://activitystrea.ms/spec/1.0/")
      .set("georss", "http://www.georss.org/georss")
      .set("media", "http://search.yahoo.com/mrss/")
      .set("thr", "http://purl.org/syndication/thread/1.0");
}</pre>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.XmlNamespaceDictionary -->
</package>
<package name="com.google.api.client.xml.atom">
  <!-- start class com.google.api.client.xml.atom.AbstractAtomFeedParser -->
  <class name="AbstractAtomFeedParser" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractAtomFeedParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="parseFeed" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
      <doc>
      <![CDATA[Parse the feed and return a new parsed instance of the feed type. This method can be skipped if
 all you want are the items.

 @throws IOException I/O exception
 @throws XmlPullParserException XML pull parser exception]]>
      </doc>
    </method>
    <method name="parseNextEntry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
      <doc>
      <![CDATA[Parse the next item in the feed and return a new parsed instance of the item type. If there is
 no item to parse, it will return {@code null} and automatically close the parser (in which case
 there is no need to call {@link #close()}.

 @throws IOException I/O exception
 @throws XmlPullParserException XML pull parser exception]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Closes the underlying parser.]]>
      </doc>
    </method>
    <method name="parseEntryInternal" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
      <doc>
      <![CDATA[Parses a single entry.

 @return object representing the entry
 @throws IOException I/O exception
 @throws XmlPullParserException XML pull parser exception]]>
      </doc>
    </method>
    <field name="parser" type="XmlPullParser"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[XML pull parser to use.]]>
      </doc>
    </field>
    <field name="inputStream" type="java.io.InputStream"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Input stream to read.]]>
      </doc>
    </field>
    <field name="feedClass" type="java.lang.Class&lt;T&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Feed class to parse.]]>
      </doc>
    </field>
    <field name="namespaceDictionary" type="com.google.api.client.xml.XmlNamespaceDictionary"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[XML namespace dictionary.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Abstract base class for an Atom feed parser when the feed type is known in advance.

 @param <T> feed type
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.atom.AbstractAtomFeedParser -->
  <!-- start class com.google.api.client.xml.atom.Atom -->
  <class name="Atom" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="checkContentType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contentType" type="java.lang.String"/>
      <doc>
      <![CDATA[Checks the given content type matches the Atom content type specified in {@link #CONTENT_TYPE}.

 @throws IllegalArgumentException if content type doesn't match]]>
      </doc>
    </method>
    <field name="ATOM_NAMESPACE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Atom namespace.]]>
      </doc>
    </field>
    <field name="CONTENT_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Atom content type.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[@since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.atom.Atom -->
  <!-- start class com.google.api.client.xml.atom.AtomContent -->
  <class name="AtomContent" extends="com.google.api.client.http.xml.AbstractXmlHttpContent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="(scheduled to be removed in 1.5) Use
             {@link com.google.api.client.http.xml.atom.AtomContent}">
    <constructor name="AtomContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="serializer" type="XmlSerializer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="entry" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key/value pair data for the Atom entry.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Serializes Atom XML HTTP content based on the data key/value mapping object for an Atom entry.
 <p>
 Default value for {@link #contentType} is {@link Atom#CONTENT_TYPE}.
 <p>
 Sample usage:

 <pre>
 <code>
  static void setContent(
      HttpRequest request, XmlNamespaceDictionary namespaceDictionary, Object entry) {
    AtomContent content = new AtomContent();
    content.namespaceDictionary = namespaceDictionary;
    content.entry = entry;
    request.content = content;
  }
 </code>
 </pre>

 @since 1.0
 @author Yaniv Inbar
 @deprecated (scheduled to be removed in 1.5) Use
             {@link com.google.api.client.http.xml.atom.AtomContent}]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.atom.AtomContent -->
  <!-- start class com.google.api.client.xml.atom.AtomFeedContent -->
  <class name="AtomFeedContent" extends="com.google.api.client.http.xml.AbstractXmlHttpContent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="(scheduled to be removed in 1.5) Use
             {@link com.google.api.client.http.xml.atom.AtomFeedContent}">
    <constructor name="AtomFeedContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="serializer" type="XmlSerializer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="feed" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key/value pair data for the Atom feed.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Serializes Atom XML HTTP content based on the data key/value mapping object for an Atom feed.
 <p>
 Default value for {@link #contentType} is {@link Atom#CONTENT_TYPE}.
 <p>
 Sample usage:

 <pre>
 <code>
  static void setContent(
      HttpRequest request, XmlNamespaceDictionary namespaceDictionary, Object feed) {
    AtomFeedContent content = new AtomFeedContent();
    content.namespaceDictionary = namespaceDictionary;
    content.feed = feed;
    request.content = content;
  }
 </code>
 </pre>

 @since 1.1
 @author Yaniv Inbar
 @deprecated (scheduled to be removed in 1.5) Use
             {@link com.google.api.client.http.xml.atom.AtomFeedContent}]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.atom.AtomFeedContent -->
  <!-- start class com.google.api.client.xml.atom.AtomFeedParser -->
  <class name="AtomFeedParser" extends="com.google.api.client.xml.atom.AbstractAtomFeedParser&lt;T&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="(scheduled to be removed in 1.5) Use
             {@link com.google.api.client.http.xml.atom.AtomFeedParser}">
    <constructor name="AtomFeedParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="parseNextEntry" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
    </method>
    <method name="parseEntryInternal" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
    </method>
    <method name="create" return="com.google.api.client.xml.atom.AtomFeedParser&lt;T, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="namespaceDictionary" type="com.google.api.client.xml.XmlNamespaceDictionary"/>
      <param name="feedClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="entryClass" type="java.lang.Class&lt;E&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
      <doc>
      <![CDATA[Parses the given HTTP response using the given feed class and entry class.

 @param <T> feed type
 @param <E> entry type
 @param response HTTP response
 @param namespaceDictionary XML namespace dictionary
 @param feedClass feed class
 @param entryClass entry class
 @return Atom feed parser
 @throws IOException I/O exception
 @throws XmlPullParserException XML pull parser exception]]>
      </doc>
    </method>
    <field name="entryClass" type="java.lang.Class&lt;E&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Atom entry class to parse.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Atom feed pull parser when the Atom entry class is known in advance.

 @param <T> feed type
 @param <E> entry type
 @since 1.0
 @author Yaniv Inbar
 @deprecated (scheduled to be removed in 1.5) Use
             {@link com.google.api.client.http.xml.atom.AtomFeedParser}]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.atom.AtomFeedParser -->
  <!-- start class com.google.api.client.xml.atom.AtomParser -->
  <class name="AtomParser" extends="com.google.api.client.http.xml.XmlHttpParser"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="(scheduled to be removed in 1.5) Use
             {@link com.google.api.client.http.xml.atom.AtomParser}">
    <constructor name="AtomParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Atom XML HTTP parser into an data class of key/value pairs.
 <p>
 It overrides the {@link #contentType} to {@link Atom#CONTENT_TYPE}.
 <p>
 Sample usage:

 <pre>
 <code>
  static void setParser(HttpTransport transport) {
    AtomParser parser = new AtomParser();
    parser.namespaceDictionary = NAMESPACE_DICTIONARY;
    transport.addParser(parser);
  }
 </code>
 </pre>

 @since 1.0
 @author Yaniv Inbar
 @deprecated (scheduled to be removed in 1.5) Use
             {@link com.google.api.client.http.xml.atom.AtomParser}]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.atom.AtomParser -->
</package>

</api>
