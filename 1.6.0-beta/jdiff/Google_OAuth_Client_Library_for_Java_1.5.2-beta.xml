<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Fri Nov 04 11:59:22 PDT 2011 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="Google OAuth Client Library for Java 1.5.2-beta"
  jdversion="1.1.1">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath /home/rmistry/jdiff-1.1.1/jdiff.jar:/home/rmistry/jdiff-1.1.1/xerces.jar -d /tmp/google-oauth-java-client/javadoc/1.6.0-beta/jdiff -classpath /usr/share/ant/lib/ant-launcher.jar:/usr/share/java/xmlParserAPIs.jar:/usr/share/java/xercesImpl.jar:/usr/share/ant/lib/ant-apache-bcel.jar:/usr/share/ant/lib/ant-apache-oro.jar:/usr/share/ant/lib/ant.jar:/usr/share/ant/lib/ant-antlr.jar:/usr/share/ant/lib/ant-swing.jar:/usr/share/ant/lib/ant-apache-bsf.jar:/usr/share/ant/lib/ant-jmf.jar:/usr/share/ant/lib/ant-jdepend.jar:/usr/share/ant/lib/ant-junit.jar:/usr/share/ant/lib/ant-nodeps.jar:/usr/share/ant/lib/ant-javamail.jar:/usr/share/ant/lib/ant-apache-regexp.jar:/usr/share/ant/lib/ant-apache-log4j.jar:/usr/share/ant/lib/ant-commons-logging.jar:/usr/share/ant/lib/ant-jsch.jar:/usr/share/ant/lib/ant-apache-resolver.jar:/usr/share/ant/lib/ant-commons-net.jar:/usr/share/ant/lib/ant-trax.jar:/usr/local/buildtools/java/jdk6-google-v4/lib/tools.jar -sourcepath /tmp/google-oauth-java-client/1.5.2-beta/google-oauth-client/src/main/java:/tmp/google-oauth-java-client/1.5.2-beta/google-oauth-client-extensions/src/main/java -apiname Google OAuth Client Library for Java 1.5.2-beta -baseURI http://www.w3.org -apidir /tmp/google-oauth-java-client/javadoc/1.6.0-beta/jdiff -source 1.5 -->
<package name="com.google.api.client.auth">
  <!-- start class com.google.api.client.auth.HmacSha -->
  <class name="HmacSha" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="sign" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="data" type="java.lang.String"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
      <doc>
      <![CDATA[Signs the given data using the given secret key.

 @throws GeneralSecurityException general security exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility methods for {@code "HMAC-SHA1"} signing method.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.HmacSha -->
  <!-- start class com.google.api.client.auth.RsaSha -->
  <class name="RsaSha" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getPrivateKeyFromKeystore" return="java.security.PrivateKey"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyStream" type="java.io.InputStream"/>
      <param name="storePass" type="java.lang.String"/>
      <param name="alias" type="java.lang.String"/>
      <param name="keyPass" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
      <doc>
      <![CDATA[Retrieves the private key from the specified key store.

 @param keyStream input stream to the key store file
 @param storePass password protecting the key store file
 @param alias alias under which the private key is stored
 @param keyPass password protecting the private key
 @return the private key from the specified key store
 @throws GeneralSecurityException if the key store cannot be loaded
 @throws IOException if the file cannot be accessed]]>
      </doc>
    </method>
    <method name="getPrivateKeyFromPk8" return="java.security.PrivateKey"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
      <doc>
      <![CDATA[Reads a {@code PKCS#8} format private key from a given file.

 @throws NoSuchAlgorithmException]]>
      </doc>
    </method>
    <method name="sign" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="privateKey" type="java.security.PrivateKey"/>
      <param name="data" type="java.lang.String"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
      <doc>
      <![CDATA[Signs the given data using the given private key.

 @throws GeneralSecurityException general security exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility methods for {@code "RSA-SHA1"} signing method.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.RsaSha -->
</package>
<package name="com.google.api.client.auth.oauth">
  <!-- start class com.google.api.client.auth.oauth.AbstractOAuthGetToken -->
  <class name="AbstractOAuthGetToken" extends="GenericUrl"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractOAuthGetToken" type="java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param authorizationServerUrl encoded authorization server URL]]>
      </doc>
    </constructor>
    <method name="execute" return="com.google.api.client.auth.oauth.OAuthCredentialsResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Executes the HTTP request for a temporary or long-lived token.

 @return OAuth credentials response object
 @throws HttpResponseException for an HTTP error code
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="createParameters" return="com.google.api.client.auth.oauth.OAuthParameters"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new instance of the OAuth authentication provider. Subclasses may override by calling
 this super implementation and then adding OAuth parameters.]]>
      </doc>
    </method>
    <field name="transport" type="HttpTransport"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP transport required for executing request in {@link #execute()}.

 @since 1.3]]>
      </doc>
    </field>
    <field name="consumerKey" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required identifier portion of the client credentials (equivalent to a username).]]>
      </doc>
    </field>
    <field name="signer" type="com.google.api.client.auth.oauth.OAuthSigner"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required OAuth signature algorithm.]]>
      </doc>
    </field>
    <field name="usePost" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code true} for POST request or the default {@code false} for GET request.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Generic OAuth 1.0a URL to request a temporary or long-lived token from an authorization server.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.AbstractOAuthGetToken -->
  <!-- start class com.google.api.client.auth.oauth.OAuthAuthorizeTemporaryTokenUrl -->
  <class name="OAuthAuthorizeTemporaryTokenUrl" extends="GenericUrl"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="OAuthAuthorizeTemporaryTokenUrl" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param encodedUserAuthorizationUrl encoded user authorization URL]]>
      </doc>
    </constructor>
    <field name="temporaryToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The temporary credentials token obtained from temporary credentials request in the
 "oauth_token" parameter. It is found in the {@link OAuthCredentialsResponse#token} returned by
 {@link OAuthGetTemporaryToken#execute()}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 1.0a URL builder for an authorization web page to allow the end user to authorize the
 temporary token.
 <p>
 The {@link #temporaryToken} should be set from the {@link OAuthCredentialsResponse#token}
 returned by {@link OAuthGetTemporaryToken#execute()}. Use {@link #build()} to build the
 authorization URL. If a {@link OAuthGetTemporaryToken#callback} was specified, after the end user
 grants the authorization, the authorization server will redirect to that callback URL. To parse
 the response, use {@link OAuthCallbackUrl}.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.OAuthAuthorizeTemporaryTokenUrl -->
  <!-- start class com.google.api.client.auth.oauth.OAuthCallbackUrl -->
  <class name="OAuthCallbackUrl" extends="GenericUrl"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="OAuthCallbackUrl" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="token" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The temporary credentials identifier received from the client.]]>
      </doc>
    </field>
    <field name="verifier" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The verification code.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Generic URL that parses the callback URL after a temporary token has been authorized by the end
 user.
 <p>
 The {@link #verifier} is required in order to exchange the authorized temporary token for a
 long-lived access token in {@link OAuthGetAccessToken#verifier}.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.OAuthCallbackUrl -->
  <!-- start class com.google.api.client.auth.oauth.OAuthCredentialsResponse -->
  <class name="OAuthCredentialsResponse" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="OAuthCredentialsResponse"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="token" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Credentials token.]]>
      </doc>
    </field>
    <field name="tokenSecret" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Credentials shared-secret for use with {@code "HMAC-SHA1"} signature algorithm. Used for
 {@link OAuthHmacSigner#tokenSharedSecret}.]]>
      </doc>
    </field>
    <field name="callbackConfirmed" type="java.lang.Boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "true"} for temporary credentials request or {@code null} for a token credentials
 request. The parameter is used to differentiate from previous versions of the protocol.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Data to parse a success response to a request for temporary or token credentials.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.OAuthCredentialsResponse -->
  <!-- start class com.google.api.client.auth.oauth.OAuthGetAccessToken -->
  <class name="OAuthGetAccessToken" extends="com.google.api.client.auth.oauth.AbstractOAuthGetToken"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="OAuthGetAccessToken" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param authorizationServerUrl encoded authorization server URL]]>
      </doc>
    </constructor>
    <method name="createParameters" return="com.google.api.client.auth.oauth.OAuthParameters"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="temporaryToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required temporary token. It is retrieved from the {@link OAuthCredentialsResponse#token}
 returned from {@link OAuthGetTemporaryToken#execute()}.]]>
      </doc>
    </field>
    <field name="verifier" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required verifier code received from the server when the temporary token was authorized. It is
 retrieved from {@link OAuthCallbackUrl#verifier}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Generic OAuth 1.0a URL to request to exchange the temporary credentials token (or "request
 token") for a long-lived credentials token (or "access token") from an authorization server.
 <p>
 Use {@link #execute()} to execute the request. The long-lived access token acquired with this
 request is found in {@link OAuthCredentialsResponse#token} . This token must be stored. It may
 then be used to authorize HTTP requests to protected resources by using {@link OAuthParameters}.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.OAuthGetAccessToken -->
  <!-- start class com.google.api.client.auth.oauth.OAuthGetTemporaryToken -->
  <class name="OAuthGetTemporaryToken" extends="com.google.api.client.auth.oauth.AbstractOAuthGetToken"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="OAuthGetTemporaryToken" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param authorizationServerUrl encoded authorization server URL]]>
      </doc>
    </constructor>
    <method name="createParameters" return="com.google.api.client.auth.oauth.OAuthParameters"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="callback" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Optional absolute URI back to which the server will redirect the resource owner when the
 Resource Owner Authorization step is completed or {@code null} for none.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Generic OAuth 1.0a URL to request a temporary credentials token (or "request token") from an
 authorization server.
 <p>
 Use {@link #execute()} to execute the request. The temporary token acquired with this request is
 found in {@link OAuthCredentialsResponse#token}. This temporary token is used in
 {@link OAuthAuthorizeTemporaryTokenUrl#temporaryToken} to direct the end user to an authorization
 page to allow the end user to authorize the temporary token.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.OAuthGetTemporaryToken -->
  <!-- start class com.google.api.client.auth.oauth.OAuthHmacSigner -->
  <class name="OAuthHmacSigner" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.auth.oauth.OAuthSigner"/>
    <constructor name="OAuthHmacSigner"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSignatureMethod" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="computeSignature" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="signatureBaseString" type="java.lang.String"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
    </method>
    <field name="clientSharedSecret" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Client-shared secret or {@code null} for none.]]>
      </doc>
    </field>
    <field name="tokenSharedSecret" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Token-shared secret or {@code null} for none.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth {@code "HMAC-SHA1"} signature method.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.OAuthHmacSigner -->
  <!-- start class com.google.api.client.auth.oauth.OAuthParameters -->
  <class name="OAuthParameters" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="OAuthParameters"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="computeNonce"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Computes a nonce based on the hex string of a random non-negative long, setting the value of
 the {@link #nonce} field.]]>
      </doc>
    </method>
    <method name="computeTimestamp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Computes a timestamp based on the current system time, setting the value of the
 {@link #timestamp} field.]]>
      </doc>
    </method>
    <method name="computeSignature"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="requestMethod" type="java.lang.String"/>
      <param name="requestUrl" type="GenericUrl"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
      <doc>
      <![CDATA[Computes a new signature based on the fields and the given request method and URL, setting the
 values of the {@link #signature} and {@link #signatureMethod} fields.

 @throws GeneralSecurityException general security exception]]>
      </doc>
    </method>
    <method name="getAuthorizationHeader" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code Authorization} header value to use with the OAuth parameter values found in
 the fields.]]>
      </doc>
    </method>
    <method name="escape" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the escaped form of the given value using OAuth escaping rules.]]>
      </doc>
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="HttpRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="intercept"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="HttpRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="signer" type="com.google.api.client.auth.oauth.OAuthSigner"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required OAuth signature algorithm.]]>
      </doc>
    </field>
    <field name="callback" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Absolute URI back to which the server will redirect the resource owner when the Resource Owner
 Authorization step is completed.]]>
      </doc>
    </field>
    <field name="consumerKey" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required identifier portion of the client credentials (equivalent to a username).]]>
      </doc>
    </field>
    <field name="nonce" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required nonce value. Should be computed using {@link #computeNonce()}.]]>
      </doc>
    </field>
    <field name="realm" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Realm.]]>
      </doc>
    </field>
    <field name="signature" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Signature. Required but normally computed using {@link #computeSignature}.]]>
      </doc>
    </field>
    <field name="signatureMethod" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Name of the signature method used by the client to sign the request. Required, but normally
 computed using {@link #computeSignature}.]]>
      </doc>
    </field>
    <field name="timestamp" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required timestamp value. Should be computed using {@link #computeTimestamp()}.]]>
      </doc>
    </field>
    <field name="token" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Token value used to associate the request with the resource owner or {@code null} if the
 request is not associated with a resource owner.]]>
      </doc>
    </field>
    <field name="verifier" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The verification code received from the server.]]>
      </doc>
    </field>
    <field name="version" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Must either be "1.0" or {@code null} to skip. Provides the version of the authentication
 process as defined in this specification.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 1.0a parameter manager.
 <p>
 The only required non-computed fields are {@link #signer} and {@link #consumerKey}. Use
 {@link #token} to specify token or temporary credentials.

 <p>
 Sample usage, taking advantage that this class implements {@link HttpRequestInitializer}:
 </p>

 <pre>
  public static HttpRequestFactory createRequestFactory(HttpTransport transport) {
    OAuthParameters parameters = new OAuthParameters();
    // ...
    return transport.createRequestFactory(parameters);
  }
 </pre>

 <p>
 If you have a custom request initializer, take a look at the sample usage for
 {@link HttpExecuteInterceptor}, which this class also implements.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.OAuthParameters -->
  <!-- start class com.google.api.client.auth.oauth.OAuthRsaSigner -->
  <class name="OAuthRsaSigner" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.auth.oauth.OAuthSigner"/>
    <constructor name="OAuthRsaSigner"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSignatureMethod" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="computeSignature" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="signatureBaseString" type="java.lang.String"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
    </method>
    <field name="privateKey" type="java.security.PrivateKey"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Private key.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth {@code "RSA-SHA1"} signature method.
 <p>
 The private key may be retrieved using the utilities in {@link RsaSha}.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.OAuthRsaSigner -->
  <!-- start interface com.google.api.client.auth.oauth.OAuthSigner -->
  <interface name="OAuthSigner"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getSignatureMethod" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the signature method.]]>
      </doc>
    </method>
    <method name="computeSignature" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="signatureBaseString" type="java.lang.String"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
      <doc>
      <![CDATA[Returns the signature computed from the given signature base string.

 @throws GeneralSecurityException general security exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[OAuth signature method.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </interface>
  <!-- end interface com.google.api.client.auth.oauth.OAuthSigner -->
</package>
<package name="com.google.api.client.auth.oauth2.draft10">
  <!-- start class com.google.api.client.auth.oauth2.draft10.AccessProtectedResource -->
  <class name="AccessProtectedResource" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AccessProtectedResource" type="java.lang.String, com.google.api.client.auth.oauth2.draft10.AccessProtectedResource.Method"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor that uses a non-expired access token.
 
 @param accessToken access token or {@code null} for none (does not call
        {@link #setAccessToken(String)})
 @param method method of accessing protected resources]]>
      </doc>
    </constructor>
    <constructor name="AccessProtectedResource" type="java.lang.String, com.google.api.client.auth.oauth2.draft10.AccessProtectedResource.Method, HttpTransport, JsonFactory, java.lang.String, java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor to use to be able to refresh token when an access token expires.

 @param accessToken access token or {@code null} for none (does not call
        {@link #setAccessToken(String)})
 @param method method of accessing protected resources
 @param transport HTTP transport for executing refresh token request
 @param jsonFactory JSON factory to use for parsing response for refresh token request
 @param authorizationServerUrl encoded authorization server URL
 @param clientId client identifier
 @param clientSecret client secret
 @param refreshToken refresh token associated with the access token to be refreshed or
        {@code null} for none]]>
      </doc>
    </constructor>
    <method name="getAccessToken" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the access token or {@code null} for none.]]>
      </doc>
    </method>
    <method name="setAccessToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="accessToken" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the access token.

 @param accessToken access token or {@code null} for none]]>
      </doc>
    </method>
    <method name="getMethod" return="com.google.api.client.auth.oauth2.draft10.AccessProtectedResource.Method"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the method of accessing protected resources.]]>
      </doc>
    </method>
    <method name="getTransport" return="HttpTransport"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the HTTP transport for executing refresh token request or {@code null} for none.]]>
      </doc>
    </method>
    <method name="getJsonFactory" return="JsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the JSON factory to use for parsing response for refresh token request or {@code null}
 for none.]]>
      </doc>
    </method>
    <method name="getAuthorizationServerUrl" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the encoded authorization server URL or {@code null} for none.]]>
      </doc>
    </method>
    <method name="getClientId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the client identifier or {@code null} for none.]]>
      </doc>
    </method>
    <method name="getClientSecret" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the client secret or {@code null} for none.]]>
      </doc>
    </method>
    <method name="getRefreshToken" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the refresh token associated with the access token to be refreshed or {@code null} for
 none.]]>
      </doc>
    </method>
    <method name="refreshToken" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Request a new access token from the authorization endpoint, acquiring a lock on the access
 token so other threads calling {@link #getAccessToken()} must wait until the new access token
 has been retrieved.

 @return whether a new access token was retrieved]]>
      </doc>
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="HttpRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="intercept"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="HttpRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}
 <p>
 Default implementation checks if there is an access token and sets the access token parameter
 using the appropriate method. Subclasses may override.
 </p>]]>
      </doc>
    </method>
    <method name="handleResponse" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="HttpRequest"/>
      <param name="response" type="HttpResponse"/>
      <param name="retrySupported" type="boolean"/>
      <doc>
      <![CDATA[{@inheritDoc}
 <p>
 Default implementation checks for a 401 error code and calls {@link #refreshToken()}. If
 {@link #executeRefreshToken()} throws an I/O exception, this implementation will log the
 exception and return {@code false}. Subclasses may override.
 </p>]]>
      </doc>
    </method>
    <method name="executeRefreshToken" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Request a new access token from the authorization endpoint.

 <p>
 If the refresh token grant parameter passed to the constructor was {@code null}, default
 implementation uses just always returns {@code false}. Otherwise, it uses
 {@link RefreshTokenGrant} based on the refresh token and then passes it to
 {@link #executeAccessTokenRequest(AccessTokenRequest)} to execute.
 </p>
 <p>
 Subclasses may override. Implementations can assume proper thread synchronization is already
 taken care of inside {@link #refreshToken()}, where this is called from.
 </p>

 @return whether a new access token was successfully retrieved
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="executeAccessTokenRequest" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="request" type="com.google.api.client.auth.oauth2.draft10.AccessTokenRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Executes the given access token request and calls {@link #setAccessToken(String)} to the access
 token from the response or {@code null} for an error response (whose error message is silently
 ignored).

 @param request access token request
 @return whether a new access token was successfully retrieved
 @throws IOException any I/O problem except {@link HttpResponseException} which is silently
         handled
 @since 1.5]]>
      </doc>
    </method>
    <method name="onAccessToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="accessToken" type="java.lang.String"/>
      <doc>
      <![CDATA[Notifies of a new access token.

 <p>
 Default implementation does nothing, but subclasses may override in order to provide
 functionality like persisting the access token in a data store. Implementations can assume
 proper thread synchronization is already taken care of inside {@link #setAccessToken(String)},
 where this is called from.
 </p>

 @param accessToken access token or {@code null} for none]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Thread-safe OAuth 2.0 (draft 10) method for specifying and refreshing the access token parameter
 as a request parameter as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-5">Accessing a Protected
 Resource</a>.

 <p>
 Sample usage, taking advantage that this class implements {@link HttpRequestInitializer}:
 </p>

 <pre>
  public static HttpRequestFactory createRequestFactoryNoRefresh(HttpTransport transport,
      JsonFactory jsonFactory, AccessTokenResponse accessTokenResponse) {
    return transport.createRequestFactory(new AccessProtectedResource(
        accessTokenResponse.accessToken, Method.AUTHORIZATION_HEADER));
  }

  public static HttpRequestFactory createRequestFactory(HttpTransport transport,
      JsonFactory jsonFactory, AccessTokenResponse accessTokenResponse) {
    return transport.createRequestFactory(new AccessProtectedResource(
        accessTokenResponse.accessToken, Method.AUTHORIZATION_HEADER, transport, jsonFactory,
        "https://server.example.com/authorize", "s6BhdRkqt3", "gX1fBat3bV",
        accessTokenResponse.refreshToken));
  }
 </pre>

 <p>
 If you need to persist the access token in a data store, override {@link #onAccessToken(String)}.
 </p>

 <p>
 If you have a custom request initializer, request execute interceptor, or unsuccessful response
 handler, take a look at the sample usage for {@link HttpExecuteInterceptor} and
 {@link HttpUnsuccessfulResponseHandler}, which are interfaces that this class also implements.
 </p>

 @author Yaniv Inbar
 @since 1.4]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AccessProtectedResource -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AccessProtectedResource.Method -->
  <class name="AccessProtectedResource.Method" extends="java.lang.Enum&lt;com.google.api.client.auth.oauth2.draft10.AccessProtectedResource.Method&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.api.client.auth.oauth2.draft10.AccessProtectedResource.Method[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.api.client.auth.oauth2.draft10.AccessProtectedResource.Method"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Method of accessing protected resources.
 <p>
 The only method required to be implemented by the specification is
 {@link #AUTHORIZATION_HEADER}.
 </p>]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AccessProtectedResource.Method -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AccessTokenErrorResponse -->
  <class name="AccessTokenErrorResponse" extends="GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AccessTokenErrorResponse"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getErrorCodeIfKnown" return="com.google.api.client.auth.oauth2.draft10.AccessTokenErrorResponse.KnownError"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a known error code if {@link #error} is one of the error codes listed in the OAuth 2
 specification or {@code null} if the {@link #error} is {@code null} or not known.]]>
      </doc>
    </method>
    <field name="error" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) A single error code.

 @see #getErrorCodeIfKnown()]]>
      </doc>
    </field>
    <field name="errorDescription" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) A human-readable text providing additional information, used to assist in the
 understanding and resolution of the error occurred.]]>
      </doc>
    </field>
    <field name="errorUri" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) A URI identifying a human-readable web page with information about the error, used
 to provide the end-user with additional information about the error.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 (draft 10) access token error response as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-4.3">Error Response</a>.

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AccessTokenErrorResponse -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AccessTokenErrorResponse.KnownError -->
  <class name="AccessTokenErrorResponse.KnownError" extends="java.lang.Enum&lt;com.google.api.client.auth.oauth2.draft10.AccessTokenErrorResponse.KnownError&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.api.client.auth.oauth2.draft10.AccessTokenErrorResponse.KnownError[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.api.client.auth.oauth2.draft10.AccessTokenErrorResponse.KnownError"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Error codes listed in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-4.3.1">Error Codes</a>.]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AccessTokenErrorResponse.KnownError -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AccessTokenRequest -->
  <class name="AccessTokenRequest" extends="GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AccessTokenRequest"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AccessTokenRequest" type="HttpTransport, JsonFactory, java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param transport HTTP transport for executing request in {@link #execute()}
 @param jsonFactory JSON factory to use for parsing response in {@link #execute()}
 @param authorizationServerUrl encoded authorization server URL]]>
      </doc>
    </constructor>
    <constructor name="AccessTokenRequest" type="HttpTransport, JsonFactory, java.lang.String, java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param transport HTTP transport for executing request in {@link #execute()}
 @param jsonFactory JSON factory to use for parsing response in {@link #execute()}
 @param authorizationServerUrl encoded authorization server URL
 @param clientSecret client secret]]>
      </doc>
    </constructor>
    <constructor name="AccessTokenRequest" type="HttpTransport, JsonFactory, java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param transport HTTP transport for executing request in {@link #execute()}
 @param jsonFactory JSON factory to use for parsing response in {@link #execute()}
 @param authorizationServerUrl encoded authorization server URL
 @param clientId client identifier
 @param clientSecret client secret]]>
      </doc>
    </constructor>
    <method name="executeUnparsed" return="HttpResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Executes request for an access token, and returns the HTTP response.

 <p>
 To execute and parse the response to {@link AccessTokenResponse}, use {@link #execute()}
 </p>

 @return HTTP response, which can then be parsed directly using
         {@link HttpResponse#parseAs(Class)} or some other parsing method
 @throws HttpResponseException for an HTTP error response, which can then be parsed using
         {@link HttpResponse#parseAs(Class)} on {@link HttpResponseException#getResponse()}
         using {@link AccessTokenErrorResponse}]]>
      </doc>
    </method>
    <method name="execute" return="com.google.api.client.auth.oauth2.draft10.AccessTokenResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Executes request for an access token, and returns the parsed access token response.

 <p>
 To execute without parsing the response, use {@link #executeUnparsed()}
 </p>

 @return parsed access token response
 @throws HttpResponseException for an HTTP error response, which can then be parsed using
         {@link HttpResponse#parseAs(Class)} on {@link HttpResponseException#getResponse()}
         using {@link AccessTokenErrorResponse}]]>
      </doc>
    </method>
    <field name="transport" type="HttpTransport"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) HTTP transport required for executing request in {@link #execute()}.]]>
      </doc>
    </field>
    <field name="jsonFactory" type="JsonFactory"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) JSON factory to use for parsing response in {@link #execute()}.]]>
      </doc>
    </field>
    <field name="grantType" type="com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.GrantType"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The access grant type included in the request.]]>
      </doc>
    </field>
    <field name="clientId" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED, unless the client identity can be establish via other means, for example assertion)
 The client identifier or {@code null} for none.]]>
      </doc>
    </field>
    <field name="clientSecret" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The client secret.]]>
      </doc>
    </field>
    <field name="scope" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The scope of the access request expressed as a list of space-delimited strings or
 {@code null} for none. The value of the "scope" parameter is defined by the authorization
 server. If the value contains multiple space-delimited strings, their order does not matter,
 and each string adds an additional access range to the requested scope. If the access grant
 being used already represents an approved scope (e.g. authorization code, assertion), the
 requested scope MUST be equal or lesser than the scope previously granted.]]>
      </doc>
    </field>
    <field name="authorizationServerUrl" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) Encoded authorization server URL.]]>
      </doc>
    </field>
    <field name="useBasicAuthorization" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code false} to specify the password in the request body using the {@code "clientSecret"}
 parameter in the HTTP body or {@code true} to use Basic Authentication as recommended in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-2.1">Client Password
 Credentials</a>.
 <p>
 Defaults to {@code false}.
 </p>]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 (draft 10) request for an access token as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-4">Obtaining an Access Token</a>.
 <p>
 The {@link #AccessTokenRequest()} or
 {@link #AccessTokenRequest(HttpTransport, JsonFactory, String, String, String)} constructors may
 be used directly when no access grant is included, such as when the client is requesting access
 to the protected resources under its control. Otherwise, use one of the subclasses, which add
 custom parameters to specify the access grant. Call {@link #execute()} to execute the request and
 use the {@link AccessTokenResponse}. On error, use {@link AccessTokenErrorResponse} instead.
 <p>
 Sample usage when the client is requesting access to the protected resources under its control:

 <pre>
 <code>
  static void requestAccessToken() throws IOException {
    try {
      AccessTokenRequest request =
          new AccessTokenRequest(new NetHttpTransport(), new JacksonFactory(),
              "https://server.example.com/authorize", "s6BhdRkqt3", "gX1fBat3bV");
      AccessTokenResponse response = request.execute();
      System.out.println("Access token: " + response.accessToken);
    } catch (HttpResponseException e) {
      AccessTokenErrorResponse response = e.response.parseAs(AccessTokenErrorResponse.class);
      System.out.println("Error: " + response.error);
    }
  }
 </code>
 </pre>
 </p>

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AccessTokenRequest -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.AssertionGrant -->
  <class name="AccessTokenRequest.AssertionGrant" extends="com.google.api.client.auth.oauth2.draft10.AccessTokenRequest"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AccessTokenRequest.AssertionGrant"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AccessTokenRequest.AssertionGrant" type="HttpTransport, JsonFactory, java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param transport HTTP transport for executing request in {@link #execute()}
 @param jsonFactory JSON factory to use for parsing response in {@link #execute()}
 @param authorizationServerUrl encoded authorization server URL
 @param assertionType format of the assertion as defined by the authorization server. The
        value MUST be an absolute URI
 @param assertion assertion]]>
      </doc>
    </constructor>
    <field name="assertionType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The format of the assertion as defined by the authorization server. The value MUST
 be an absolute URI.]]>
      </doc>
    </field>
    <field name="assertion" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The assertion.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 Assertion Flow: request an access token based on as assertion as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-4.1.3">Assertion</a>.
 <p>
 Sample usage:

 <pre>
 <code>
    static void requestAccessToken() throws IOException {
      try {
        AssertionGrant request = new AssertionGrant(new NetHttpTransport(),
            new JacksonFactory(),
            "https://server.example.com/authorize",
            "gX1fBat3bV",
            "urn:oasis:names:tc:SAML:2.0:",
            "PHNhbWxwOl...[omitted for brevity]...ZT4=");
        AccessTokenResponse response = request.execute();
        System.out.println("Access token: " + response.accessToken);
      } catch (HttpResponseException e) {
        AccessTokenErrorResponse response = e.response.parseAs(AccessTokenErrorResponse.class);
        System.out.println("Error: " + response.error);
      }
    }
 </code>
 </pre>
 </p>]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.AssertionGrant -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.AuthorizationCodeGrant -->
  <class name="AccessTokenRequest.AuthorizationCodeGrant" extends="com.google.api.client.auth.oauth2.draft10.AccessTokenRequest"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AccessTokenRequest.AuthorizationCodeGrant"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AccessTokenRequest.AuthorizationCodeGrant" type="HttpTransport, JsonFactory, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param transport HTTP transport for executing request in {@link #execute()}
 @param jsonFactory JSON factory to use for parsing response in {@link #execute()}
 @param authorizationServerUrl encoded authorization server URL
 @param clientId client identifier
 @param clientSecret client secret
 @param code authorization code received from the authorization server
 @param redirectUri redirection URI used in the initial request]]>
      </doc>
    </constructor>
    <field name="code" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The authorization code received from the authorization server.]]>
      </doc>
    </field>
    <field name="redirectUri" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The redirection URI used in the initial request.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 Web Server Flow: request an access token based on a verification code as specified in
 <a href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-4.1.1">Authorization
 Code</a>.
 <p>
 Sample usage:

 <pre>
 <code>
    static void requestAccessToken() throws IOException {
      try {
        AuthorizationCodeGrant request = new AuthorizationCodeGrant(new NetHttpTransport(),
            new JacksonFactory(),
            "https://server.example.com/authorize",
            "s6BhdRkqt3",
            "gX1fBat3bV",
            "i1WsRn1uB1",
            "https://client.example.com/cb");
        AccessTokenResponse response = request.execute();
        System.out.println("Access token: " + response.accessToken);
      } catch (HttpResponseException e) {
        AccessTokenErrorResponse response = e.response.parseAs(AccessTokenErrorResponse.class);
        System.out.println("Error: " + response.error);
      }
    }
 </code>
 </pre>
 </p>]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.AuthorizationCodeGrant -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.GrantType -->
  <class name="AccessTokenRequest.GrantType" extends="java.lang.Enum&lt;com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.GrantType&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.GrantType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.GrantType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Access grant type.]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.GrantType -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.RefreshTokenGrant -->
  <class name="AccessTokenRequest.RefreshTokenGrant" extends="com.google.api.client.auth.oauth2.draft10.AccessTokenRequest"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AccessTokenRequest.RefreshTokenGrant"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AccessTokenRequest.RefreshTokenGrant" type="HttpTransport, JsonFactory, java.lang.String, java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param transport HTTP transport for executing request in {@link #execute()}
 @param jsonFactory JSON factory to use for parsing response in {@link #execute()}
 @param authorizationServerUrl encoded authorization server URL
 @param clientId client identifier
 @param clientSecret client secret
 @param refreshToken refresh token associated with the access token to be refreshed]]>
      </doc>
    </constructor>
    <field name="refreshToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The refresh token associated with the access token to be refreshed.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 request to refresh an access token as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-4.1.4">Refresh Token</a>.
 <p>
 Sample usage:

 <pre>
 <code>
    static void requestAccessToken() throws IOException {
      try {
        RefreshTokenGrant request = new RefreshTokenGrant(new NetHttpTransport(),
            new JacksonFactory(),
            "https://server.example.com/authorize",
            "s6BhdRkqt3",
            "gX1fBat3bV",
            "n4E9O119d");
        AccessTokenResponse response = request.execute();
        System.out.println("Access token: " + response.accessToken);
      } catch (HttpResponseException e) {
        AccessTokenErrorResponse response = e.response.parseAs(AccessTokenErrorResponse.class);
        System.out.println("Error: " + response.error);
      }
    }
 </code>
 </pre>
 </p>]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.RefreshTokenGrant -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.ResourceOwnerPasswordCredentialsGrant -->
  <class name="AccessTokenRequest.ResourceOwnerPasswordCredentialsGrant" extends="com.google.api.client.auth.oauth2.draft10.AccessTokenRequest"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AccessTokenRequest.ResourceOwnerPasswordCredentialsGrant"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AccessTokenRequest.ResourceOwnerPasswordCredentialsGrant" type="HttpTransport, JsonFactory, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param transport HTTP transport for executing request in {@link #execute()}
 @param jsonFactory JSON factory to use for parsing response in {@link #execute()}
 @param authorizationServerUrl encoded authorization server URL
 @param clientId client identifier
 @param clientSecret client secret
 @param username resource owner's username
 @param password resource owner's password]]>
      </doc>
    </constructor>
    <field name="username" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The resource owner's username.]]>
      </doc>
    </field>
    <field name="password" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The resource owner's password.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 Username and Password Flow: request an access token based on resource owner
 credentials used in the as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-4.1.2">Resource Owner Password
 Credentials</a>.
 <p>
 Sample usage:

 <pre>
 <code>
    static void requestAccessToken() throws IOException {
      try {
        ResourceOwnerPasswordCredentialsGrant request =
            new ResourceOwnerPasswordCredentialsGrant(new NetHttpTransport(),
                new JacksonFactory(),
                "https://server.example.com/authorize",
                "s6BhdRkqt3",
                "gX1fBat3bV",
                "johndoe",
                "A3ddj3w");
        AccessTokenResponse response = request.execute();
        System.out.println("Access token: " + response.accessToken);
      } catch (HttpResponseException e) {
        AccessTokenErrorResponse response = e.response.parseAs(AccessTokenErrorResponse.class);
        System.out.println("Error: " + response.error);
      }
    }
 </code>
 </pre>
 </p>]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AccessTokenRequest.ResourceOwnerPasswordCredentialsGrant -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AccessTokenResponse -->
  <class name="AccessTokenResponse" extends="GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AccessTokenResponse"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="accessToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The access token issued by the authorization server.]]>
      </doc>
    </field>
    <field name="expiresIn" type="java.lang.Long"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The duration in seconds of the access token lifetime. For example, the value "3600"
 denotes that the access token will expire in one hour from the time the response was generated
 by the authorization server.]]>
      </doc>
    </field>
    <field name="refreshToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The refresh token used to obtain new access tokens. The authorization server SHOULD
 NOT issue a refresh token when the access grant type is set to "none".]]>
      </doc>
    </field>
    <field name="scope" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The scope of the access token as a list of space- delimited strings. The value of
 the "scope" parameter is defined by the authorization server. If the value contains multiple
 space-delimited strings, their order does not matter, and each string adds an additional access
 range to the requested scope. The authorization server SHOULD include the parameter if the
 requested scope is different from the one requested by the client.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 (draft 10) access token success response content as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-4.2">Access Token Response</a>.
 <p>
 Use {@link AccessProtectedResource} to authorize executed HTTP requests based on the
 {@link #accessToken}.
 </p>

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AccessTokenResponse -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AuthorizationRequestUrl -->
  <class name="AuthorizationRequestUrl" extends="GenericUrl"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AuthorizationRequestUrl" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param encodedAuthorizationServerUrl encoded authorization server URL]]>
      </doc>
    </constructor>
    <constructor name="AuthorizationRequestUrl" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param encodedAuthorizationServerUrl encoded authorization server URL
 @param clientId client identifier]]>
      </doc>
    </constructor>
    <field name="responseType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The requested response: an access token, an authorization code, or both. The
 parameter value MUST be set to "token" for requesting an access token, "code" for requesting an
 authorization code, or "code_and_token" to request both. The authorization server MAY decline
 to provide one or more of these response types. For convenience, you may use
 {@link ResponseType} to set this value.
 <p>
 By default, the response type is {@code "code"}, but this may be overridden.
 </p>]]>
      </doc>
    </field>
    <field name="clientId" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The client identifier.]]>
      </doc>
    </field>
    <field name="redirectUri" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED, unless a redirection URI has been established between the client and authorization
 server via other means) An absolute URI to which the authorization server will redirect the
 user-agent to when the end-user authorization step is completed. The authorization server
 SHOULD require the client to pre-register their redirection URI.]]>
      </doc>
    </field>
    <field name="scope" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The scope of the access request expressed as a list of space-delimited strings. The
 value of the "scope" parameter is defined by the authorization server. If the value contains
 multiple space-delimited strings, their order does not matter, and each string adds an
 additional access range to the requested scope.]]>
      </doc>
    </field>
    <field name="state" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) An opaque value used by the client to maintain state between the request and
 callback. The authorization server includes this value when redirecting the user-agent back to
 the client.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 (draft 10) URL builder for an authorization web page to allow the end user to authorize
 the application to access their protected resources as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-3">Obtaining End-User
 Authorization</a>.
 <p>
 Use {@link AuthorizationResponse} to parse the redirect response after the end user grants/denies
 the request.
 </p>
 <p>
 Sample usage for a web application:

 <pre>
 <code>
  public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    AuthorizationRequestUrl builder =
        new AuthorizationRequestUrl(BASE_AUTHORIZATION_URL, CLIENT_ID);
    builder.redirectUri = REDIRECT_URL;
    builder.scope = SCOPE;
    response.sendRedirect(builder.build());
    return;
  }
 </code>
 </pre>

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AuthorizationRequestUrl -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AuthorizationRequestUrl.ResponseType -->
  <class name="AuthorizationRequestUrl.ResponseType" extends="java.lang.Enum&lt;com.google.api.client.auth.oauth2.draft10.AuthorizationRequestUrl.ResponseType&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.api.client.auth.oauth2.draft10.AuthorizationRequestUrl.ResponseType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.api.client.auth.oauth2.draft10.AuthorizationRequestUrl.ResponseType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="com.google.api.client.auth.oauth2.draft10.AuthorizationRequestUrl"/>
      <doc>
      <![CDATA[Sets the response type on an authorization request URL.

 @param url authorization request URL]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Response type enumeration that may be used for setting the
 {@link AuthorizationRequestUrl#responseType}.
 <p>
 Call {@link #set(AuthorizationRequestUrl)} to set the response type on an authorization request
 URL.
 </p>]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AuthorizationRequestUrl.ResponseType -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AuthorizationResponse -->
  <class name="AuthorizationResponse" extends="GenericJson"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AuthorizationResponse" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param redirectUrl encoded redirect URL
 @throws IllegalArgumentException URI syntax exception]]>
      </doc>
    </constructor>
    <method name="getErrorCodeIfKnown" return="com.google.api.client.auth.oauth2.draft10.AuthorizationResponse.KnownError"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a known error code if {@link #error} is one of the error codes listed in the OAuth 2
 specification or {@code null} if the {@link #error} is {@code null} or not known.]]>
      </doc>
    </method>
    <field name="code" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED if the end user grants authorization and the response type is "code" or
 "code_and_token", otherwise MUST NOT be included) The authorization code generated by the
 authorization server. The authorization code SHOULD expire shortly after it is issued. The
 authorization server MUST invalidate the authorization code after a single usage. The
 authorization code is bound to the client identifier and redirection URI.]]>
      </doc>
    </field>
    <field name="accessToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED if the end user grants authorization and the response type is "token" or
 "code_and_token", otherwise MUST NOT be included) The access token issued by the authorization
 server.]]>
      </doc>
    </field>
    <field name="expiresIn" type="java.lang.Long"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The duration in seconds of the access token lifetime if an access token is included.
 For example, the value "3600" denotes that the access token will expire in one hour from the
 time the response was generated by the authorization server.]]>
      </doc>
    </field>
    <field name="scope" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The scope of the access token as a list of space- delimited strings if an access
 token is included. The value of the "scope" parameter is defined by the authorization server.
 If the value contains multiple space-delimited strings, their order does not matter, and each
 string adds an additional access range to the requested scope. The authorization server SHOULD
 include the parameter if the requested scope is different from the one requested by the client.]]>
      </doc>
    </field>
    <field name="error" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED if the end user denies authorization) A single error code.

 @see #getErrorCodeIfKnown()]]>
      </doc>
    </field>
    <field name="errorDescription" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) A human-readable text providing additional information, used to assist in the
 understanding and resolution of the error occurred.]]>
      </doc>
    </field>
    <field name="errorUri" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) A URI identifying a human-readable web page with information about the error, used
 to provide the end-user with additional information about the error.]]>
      </doc>
    </field>
    <field name="state" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED if the "state" parameter was present in the client authorization request) Set to the
 exact value received from the client.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 (draft 10) parser for the redirect URL after end user grants or denies authorization as
 specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-3.1">Authorization Response</a>.
 <p>
 Check if {@link #error} is {@code null} to check if the end-user granted authorization.
 </p>
 <p>
 Sample usage for a web application:

 <pre><code>
  public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    StringBuffer fullUrlBuf = request.getRequestURL();
    if (request.getQueryString() != null) {
      fullUrlBuf.append('?').append(request.getQueryString());
    }
    AuthorizationResponse authResponse = new AuthorizationResponse(fullUrlBuf.toString());
    // check for user-denied error
    if (authResponse.error != null) {
      // authorization denied...
    } else {
      // request access token using authResponse.code...
    }
  }
 </code></pre>
 </p>
 <p>
 Sample usage for an installed application:

 <pre><code>
  static void processRedirectUrl(HttpTransport transport, String redirectUrl) {
    AuthorizationResponse response = new AuthorizationResponse(redirectUrl);
    if (response.error != null) {
      throw new RuntimeException("Authorization denied");
    }
    AccessProtectedResource.usingAuthorizationHeader(transport, response.accessToken);
  }
 </code></pre>
 </p>

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AuthorizationResponse -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.AuthorizationResponse.KnownError -->
  <class name="AuthorizationResponse.KnownError" extends="java.lang.Enum&lt;com.google.api.client.auth.oauth2.draft10.AuthorizationResponse.KnownError&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.api.client.auth.oauth2.draft10.AuthorizationResponse.KnownError[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.api.client.auth.oauth2.draft10.AuthorizationResponse.KnownError"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Error codes listed in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-3.2.1">Error Codes</a>.]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.AuthorizationResponse.KnownError -->
  <!-- start class com.google.api.client.auth.oauth2.draft10.InstalledApp -->
  <class name="InstalledApp" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="OOB_REDIRECT_URI" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Redirect URI to use for "Out Of Band", meaning that the end-user is given an access code that
 they must then enter into the installed application.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Constants for installed (or "native") applications.

 @since 1.4
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.draft10.InstalledApp -->
</package>
<package name="com.google.api.client.extensions.appengine.auth">
  <!-- start class com.google.api.client.extensions.appengine.auth.AbstractAppEngineCallbackServlet -->
  <class name="AbstractAppEngineCallbackServlet" extends="com.google.api.client.extensions.servlet.auth.AbstractCallbackServlet"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractAppEngineCallbackServlet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getUserId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the user ID of the user that is logged in.

 @throws IllegalStateException Thrown when no user is logged in.]]>
      </doc>
    </method>
    <method name="newHttpTransportInstance" return="HttpTransport"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="newJsonFactoryInstance" return="JsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This servlet fills in some of the required information for the {@link AbstractCallbackServlet}
 with reasonable defaults for App Engine. It will default the servlet to creating
 {@link UrlFetchTransport} objects whenever an {@link HttpTransport} is needed. It will also
 default the user identifier to the logged in App Engine user. This servlet requires that the App
 Engine user must be logged in to work correctly. This can be accomplished by adding a security
 constraint in your web.xml for the path at which this servlet will live.
 <p>
 Example that requires login for all pages:

 <pre>
 <code>
  &lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
      &lt;web-resource-name&gt;any&lt;/web-resource-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;
      &lt;role-name&gt;*&lt;/role-name&gt;
    &lt;/auth-constraint&gt;
  &lt;/security-constraint&gt;
 </code>
 </pre>

 @author moshenko@google.com (Jacob Moshenko)
 @since 1.4]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.appengine.auth.AbstractAppEngineCallbackServlet -->
  <!-- start class com.google.api.client.extensions.appengine.auth.AbstractAppEngineFlowServlet -->
  <class name="AbstractAppEngineFlowServlet" extends="com.google.api.client.extensions.servlet.auth.AbstractFlowUserServlet"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractAppEngineFlowServlet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getUserId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the user ID of the user that is logged in.

 @throws IllegalStateException Thrown when no user is logged in.]]>
      </doc>
    </method>
    <method name="newHttpTransportInstance" return="HttpTransport"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="newJsonFactoryInstance" return="JsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This class fills in some of the unknowns of the generic {@link AbstractFlowUserServlet} with
 reasonable defaults for App Engine. This servlet requires that the App Engine user must be logged
 in to work correctly.

 @author moshenko@google.com (Jacob Moshenko)
 @since 1.4]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.appengine.auth.AbstractAppEngineFlowServlet -->
  <!-- start class com.google.api.client.extensions.appengine.auth.AbstractAppEngineTwoLeggedFlowServlet -->
  <class name="AbstractAppEngineTwoLeggedFlowServlet" extends="com.google.api.client.extensions.servlet.auth.AbstractTwoLeggedFlowServlet"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractAppEngineTwoLeggedFlowServlet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getUserId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the user ID of the user that is logged in.

 @throws IllegalStateException Thrown when no user is logged in.]]>
      </doc>
    </method>
    <method name="newHttpTransportInstance" return="HttpTransport"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="newJsonFactoryInstance" return="JsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Specialization of the two-legged flow that uses some simple defaults for App Engine.

 @author moshenko@google.com (Jacob Moshenko)
 @since 1.5]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.appengine.auth.AbstractAppEngineTwoLeggedFlowServlet -->
  <!-- start class com.google.api.client.extensions.appengine.auth.SignedTokenGenerator -->
  <class name="SignedTokenGenerator" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SignedTokenGenerator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createJsonTokenForScopes" return="JsonToken"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scope" type="java.lang.String"/>
      <param name="audience" type="java.lang.String"/>
      <doc>
      <![CDATA[Static function to create a signable JSON token initialized with the proper parameters for
 performing an assertion token request.

 @param scope Scope for which we are requesting access.
 @param audience Audience field in the json web token.
 @return Signable JSON web token (JWT).]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class will allow you to create a signed JSON web token (JWT) that can be used for assertion
 flows with an appropriate auth endpoint.

 @author moshenko@google.com (Jacob Moshenko)

 @since 1.5]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.appengine.auth.SignedTokenGenerator -->
</package>
<package name="com.google.api.client.extensions.auth.helpers">
  <!-- start interface com.google.api.client.extensions.auth.helpers.Credential -->
  <interface name="Credential"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="isInvalid" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determine if the Credential is no longer valid, after being revoked for example.

 @since 1.5]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implementations of this class will have all of the information necessary to create and install
 the necessary handlers on an {@link HttpTransport} object to allow for a streamlined auth
 experience.

 Implementations of this interface should use the {@link PersistenceCapable} annotation to allow
 credentials to be managed on behalf of the application.

 @author moshenko@google.com (Jacob Moshenko)
 @since 1.4]]>
    </doc>
  </interface>
  <!-- end interface com.google.api.client.extensions.auth.helpers.Credential -->
  <!-- start interface com.google.api.client.extensions.auth.helpers.ThreeLeggedFlow -->
  <interface name="ThreeLeggedFlow"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getAuthorizationUrl" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[After the object is created, the developer should use this method to interrogate it for the
 authorization URL to which the user should be redirected to obtain permission.

 @return URL to which the user should be directed]]>
      </doc>
    </method>
    <method name="setHttpTransport"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transport" type="HttpTransport"/>
      <doc>
      <![CDATA[Set {@link HttpTransport} instance for this three legged flow.]]>
      </doc>
    </method>
    <method name="setJsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="jsonFactory" type="JsonFactory"/>
      <doc>
      <![CDATA[Set {@link JsonFactory} instance for this three legged flow.]]>
      </doc>
    </method>
    <method name="loadCredential" return="com.google.api.client.extensions.auth.helpers.Credential"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pm" type="PersistenceManager"/>
      <doc>
      <![CDATA[Convenience function that will load a credential based on the userId for which this flow was
 instantiated.

 @param pm {@link PersistenceManager} instance which this flow should use to interact with the
        data store. The caller must remember to call {@link PersistenceManager#close()} after
        this method returns.
 @return Fully initialized {@link Credential} object or {@code null} if none exists.]]>
      </doc>
    </method>
    <method name="complete" return="com.google.api.client.extensions.auth.helpers.Credential"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="authorizationCode" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[After the user has authorized the request, the token or code obtained should be passed to this
 complete function to allow us to exchange the code with the authentication server for a
 {@link Credential}.

 @param authorizationCode Code or token obtained after the user grants permission
 @return {@link Credential} object that is obtained from token server

 @throws IOException When an error occurs when communicating with the token server]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface for auth flows that require a user authorization step through a web browser to obtain
 an authorization code.

 <p>
 Implementations are required to be {@link PersistenceCapable} for storage in JDO compliant
 datastores during user authorization step.
 </p>

 @author moshenko@google.com (Jacob Moshenko)
 @since 1.4]]>
    </doc>
  </interface>
  <!-- end interface com.google.api.client.extensions.auth.helpers.ThreeLeggedFlow -->
  <!-- start interface com.google.api.client.extensions.auth.helpers.TwoLeggedFlow -->
  <interface name="TwoLeggedFlow"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="loadOrCreateCredential" return="com.google.api.client.extensions.auth.helpers.Credential"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pm" type="PersistenceManager"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Load the instance of {@link Credential} associated with this flow instance or create a new one
 if one can not be loaded.

 @param pm Persistence manager used for communicating with the datastore.
 @return {@link Credential} instance associated with this flow instance.
 @throws IOException Thrown when a failure occurs communicating with the auth server or the data
         store.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A two legged flow is able to create credentials without intervention from the user. It will
 manage the persistence of credentials as well as be able to mint them when they do not exist.

 @author moshenko@google.com (Jake Moshenko)

 @since 1.5]]>
    </doc>
  </interface>
  <!-- end interface com.google.api.client.extensions.auth.helpers.TwoLeggedFlow -->
</package>
<package name="com.google.api.client.extensions.auth.helpers.appengine">
  <!-- start class com.google.api.client.extensions.auth.helpers.appengine.AccessAppResource -->
  <class name="AccessAppResource" extends="com.google.api.client.auth.oauth2.draft10.AccessProtectedResource"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AccessAppResource" type="java.lang.String, com.google.api.client.auth.oauth2.draft10.AccessProtectedResource.Method, HttpTransport, JsonFactory, java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an instance of the access initializer.

 @param accessToken Initial access token, or {@code null} if one is not yet available.
 @param method Method with which to authorize the request.
 @param transport Instance used to communicate with the auth server.
 @param jsonFactory Instance used to deserialize communications from the auth server.
 @param authorizationServerUrl Url at which the auth server is located.
 @param scope Scope for which we are requesting access.
 @param audience Audience used in the JSON web token used when obtaining access tokens.]]>
      </doc>
    </constructor>
    <method name="executeRefreshToken" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Subclass of {@link AccessProtectedResource} that handles the different logic required to obtain a
 new access token using an assertion grant when the existing one expires.

 @author moshenko@google.com (Jake Moshenko)

 @since 1.5]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.auth.helpers.appengine.AccessAppResource -->
  <!-- start class com.google.api.client.extensions.auth.helpers.appengine.AppAssertionCredential -->
  <class name="AppAssertionCredential" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.extensions.auth.helpers.Credential"/>
    <constructor name="AppAssertionCredential" type="java.lang.String, java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an instance of this class. This will only set up on the object, and a call to
 {@link #postConstruct} is required before it can be used.

 @param applicationName Primary key for this data object in the data store. It is usually the
        robot name.
 @param authorizationServerUrl Server with which we can exchange an assertion for an access
        token.
 @param scope Scope(s) for which this credential will request access.
 @param audience Audience to be used in the JSON web token.]]>
      </doc>
    </constructor>
    <method name="setAccessToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="accessToken" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the access token to a new value.

 @param accessToken New access token or {@code null} for none]]>
      </doc>
    </method>
    <method name="postConstruct"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transport" type="HttpTransport"/>
      <param name="jsonFactory" type="JsonFactory"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Finish building the object. This should be called whether the object is loaded using JDO or
 created using the constructor.

 @param transport {@link HttpTransport} instance to use to access the network.
 @param jsonFactory {@link JsonFactory} instance to use to serialize and deserialize auth server
        communications.
 @throws IOException Thrown when we are unable to set up access token communications.]]>
      </doc>
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="HttpRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="intercept"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="HttpRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="handleResponse" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="HttpRequest"/>
      <param name="response" type="HttpResponse"/>
      <param name="retrySupported" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="isInvalid" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Implementation of credentials that is used to communicate with resources managed on behalf of an
 App Engine application.

 @author moshenko@google.com (Jake Moshenko)

 @since 1.5]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.auth.helpers.appengine.AppAssertionCredential -->
  <!-- start class com.google.api.client.extensions.auth.helpers.appengine.AppAssertionFlow -->
  <class name="AppAssertionFlow" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.extensions.auth.helpers.TwoLeggedFlow"/>
    <constructor name="AppAssertionFlow" type="java.lang.String, java.lang.String, java.lang.String, java.lang.String, HttpTransport, JsonFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an instance.

 @param robotName Identifier that will eventually become the primary key for the credential
        object created by this flow. This is usually the application's identifier.
 @param authorizationServerUrl Server with which we will exchange our assertion for an access
        token.
 @param scope Scope (or list of scopes) for which we require access.
 @param audience Audience that will be used when creating the assertion.
 @param transport {@link HttpTransport} instance that will be used for network communication.
 @param jsonFactory {@link JsonFactory} instance whtat will be used to serialize and deserialize
        auth server communications.]]>
      </doc>
    </constructor>
    <method name="loadOrCreateCredential" return="com.google.api.client.extensions.auth.helpers.Credential"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pm" type="PersistenceManager"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Class which will allow us to create or load instances of {@link AppAssertionCredential}.

 @author moshenko@google.com (Jake Moshenko)

 @since 1.5]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.auth.helpers.appengine.AppAssertionFlow -->
</package>
<package name="com.google.api.client.extensions.auth.helpers.oauth">
  <!-- start class com.google.api.client.extensions.auth.helpers.oauth.OAuthHmacCredential -->
  <class name="OAuthHmacCredential" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.extensions.auth.helpers.Credential"/>
    <constructor name="OAuthHmacCredential" type="java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an OAuth 1 credential object from information obtained from the server.

 @param userId User ID key that can be used to associate this credential with a user.
 @param consumerKey Key that identifies the server to the service provider.
 @param sharedSecret Secret that the server shares with the service provider.
 @param tokenSharedSecret Token secret that server uses to authenticate the requests.
 @param token Token that has been authorized by the end user to allow the server to access the
        resources or {@code null} for none]]>
      </doc>
    </constructor>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="HttpRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="intercept"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="HttpRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="handleResponse" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="HttpRequest"/>
      <param name="response" type="HttpResponse"/>
      <param name="retrySupported" type="boolean"/>
    </method>
    <method name="jdoPreClear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="jdoPreDelete"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="jdoPostLoad"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="jdoPreStore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isInvalid" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[OAuth 1 credential which uses the {@link OAuthHmacSigner} to sign requests.

 This class is both immutable and thread safe.

 @author moshenko@google.com (Jacob Moshenko)
 @since 1.5]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.auth.helpers.oauth.OAuthHmacCredential -->
  <!-- start class com.google.api.client.extensions.auth.helpers.oauth.OAuthHmacThreeLeggedFlow -->
  <class name="OAuthHmacThreeLeggedFlow" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.extensions.auth.helpers.ThreeLeggedFlow"/>
    <constructor name="OAuthHmacThreeLeggedFlow" type="java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, HttpTransport"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an OAuthThreeLeggedFlow instance from the required information.

 @param userId Key that can be used to associate this flow with an end user.
 @param consumerKey Key that identifies the server to the service provider.
 @param consumerSecret Secret that is shared between the server and the service provider.
 @param authorizationServerUrl Url with which we communicate to authorize tis application.
 @param temporaryTokenUrl Url which we will use to obtain a temporary token.
 @param callbackUrl Url which the server should redirect the user to after obtaining
        authorization.

 @throws IOException Exception thrown when the flow is unable to communicate with the service
         provider.]]>
      </doc>
    </constructor>
    <method name="getAuthorizationUrl" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="complete" return="com.google.api.client.extensions.auth.helpers.Credential"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="authorizationCode" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="loadCredential" return="com.google.api.client.extensions.auth.helpers.Credential"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pm" type="PersistenceManager"/>
    </method>
    <method name="setHttpTransport"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transport" type="HttpTransport"/>
    </method>
    <method name="setJsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="jsonFactory" type="JsonFactory"/>
    </method>
    <doc>
    <![CDATA[{@link ThreeLeggedFlow} implementation that will execute the proper requests to obtain an OAuth1
 Credential object that can be used to sign requests.

<p>
 This class is not thread safe, nor should you attempt to execute a flow from multiple threads
 simultaneously.
 </p>

 @author moshenko@google.com (Jacob Moshenko)
 @since 1.5]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.auth.helpers.oauth.OAuthHmacThreeLeggedFlow -->
</package>
<package name="com.google.api.client.extensions.auth.helpers.oauth2.draft10">
  <!-- start class com.google.api.client.extensions.auth.helpers.oauth2.draft10.OAuth2Credential -->
  <class name="OAuth2Credential" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.extensions.auth.helpers.Credential"/>
    <constructor name="OAuth2Credential" type="java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an instance of an OAuth2Credential that can be used to authorize requests on behalf of
 an end user. Once you construct the object, you must call
 {@link #initializeForRefresh(String, String, String, JsonFactory, HttpTransport)} to provide
 the necessary information to allow token refresh.

 @param userId Key that can be used to associate this Credential object with an end user.
 @param accessToken Access token that can be used to authorize this request.
 @param refreshToken Token that can be given to the token server in exchange for a new access
        token or {@code null} for none.]]>
      </doc>
    </constructor>
    <constructor name="OAuth2Credential" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an instance of an OAuth2Credential that can be used to authorize requests on behalf of
 an end user. Instances created through this constructor are not eligible for token refresh.

 @param userId Key that can be used to associate this Credential object with an end user.
 @param accessToken Access token that can be used to authorize this request.]]>
      </doc>
    </constructor>
    <method name="refresh" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transport" type="HttpTransport"/>
      <param name="factory" type="JsonFactory"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Force a refresh of this credential if possible using the {@link HttpTransport} and
 {@link JsonFactory} objects provided for the network communication.

 @param transport {@link HttpTransport} to use for the refresh
 @param factory {@link JsonFactory} to use to parse the auth response

 @return Success or failure of refresh operation

 @throws IOException When the credential can not communicate with the token server.]]>
      </doc>
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="HttpRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="intercept"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="HttpRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="handleResponse" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="HttpRequest"/>
      <param name="response" type="HttpResponse"/>
      <param name="retrySupported" type="boolean"/>
    </method>
    <method name="initializeForRefresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clientId" type="java.lang.String"/>
      <param name="clientSecret" type="java.lang.String"/>
      <param name="refreshUrl" type="java.lang.String"/>
      <param name="jsonFactory" type="JsonFactory"/>
      <param name="transport" type="HttpTransport"/>
      <doc>
      <![CDATA[Initialize the instance with the required information to allow token refresh. This must be done
 after construction or after loading the object from the data store.

 @param clientId Used to identify the client server with the token server.
 @param clientSecret Secret shared between the client server and the token server.
 @param refreshUrl Url which can be used to exchange the refresh token for a new access token.
 @param jsonFactory Json factory used to deserialize communications with the token server.
 @param transport Transport used to send requests to the token server.]]>
      </doc>
    </method>
    <method name="getAccessToken" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the current access token. This may be either the access token with which the object was
 constructed, or a token fetched through a successful refresh.]]>
      </doc>
    </method>
    <method name="setAccessToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="accessToken" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the access token or {@code null} for none.]]>
      </doc>
    </method>
    <method name="getRefreshToken" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the refresh token with which this object was constructed or {@code null} for none. This
 can be used for out of band use cases, but most users should just let the credential be
 refreshed by the library when a call fails.]]>
      </doc>
    </method>
    <method name="jdoPreClear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="jdoPreDelete"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="jdoPostLoad"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="jdoPreStore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isInvalid" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[{@link Credential} implementation that is used to authorize OAuth2 enabled requests through the
 use of the access_token header, as well as refresh the token when it is required. It is important
 that access to this class be made from within a managed JDO context and that the persistence
 manager be closed in a finally block to save any updates to the access token.

 This class is safe to use from multiple threads.

 @author moshenko@google.com (Jacob Moshenko)
 @since 1.4]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.auth.helpers.oauth2.draft10.OAuth2Credential -->
  <!-- start class com.google.api.client.extensions.auth.helpers.oauth2.draft10.OAuth2ThreeLeggedFlow -->
  <class name="OAuth2ThreeLeggedFlow" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.extensions.auth.helpers.ThreeLeggedFlow"/>
    <constructor name="OAuth2ThreeLeggedFlow" type="java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create the flow object with the information provided and create the authorization url.

 @param userId Key that will be used to associate this flow object with an end user.
 @param clientId Used to identify the client server with the token server.
 @param clientSecret Secret shared between the client server and the token server.
 @param scope OAuth2 scope or space delimited list of scopes for which we require access.
 @param callbackUrl Where the authorization should redirect the user to complete the flow.
 @param authorizationEndpoint Server to which we will redirect the user to grant authorization.
 @param tokenEndpoint Server with which we will exchange an authorization code for an access
        token.]]>
      </doc>
    </constructor>
    <method name="complete" return="com.google.api.client.extensions.auth.helpers.Credential"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="authorizationCode" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getAuthorizationUrl" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="loadCredential" return="com.google.api.client.extensions.auth.helpers.Credential"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pm" type="PersistenceManager"/>
    </method>
    <method name="setHttpTransport"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transport" type="HttpTransport"/>
    </method>
    <method name="setJsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="jsonFactory" type="JsonFactory"/>
    </method>
    <doc>
    <![CDATA[This class is designed to allow the three legged web app flow for OAuth2 to be accomplished
 easily. When the constructor is called an authorization url is generated from the provided
 information. The user should be redirected to that url for confirmation. When the code has been
 received, the flow will request the access and refresh tokens.

 <p>
 It is not safe to use one instance of this implementation from multiple threads.
 </p>

 @author moshenko@google.com (Jacob Moshenko)
 @since 1.4]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.auth.helpers.oauth2.draft10.OAuth2ThreeLeggedFlow -->
</package>
<package name="com.google.api.client.extensions.servlet.auth">
  <!-- start class com.google.api.client.extensions.servlet.auth.AbstractCallbackServlet -->
  <class name="AbstractCallbackServlet" extends="HttpServlet"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractCallbackServlet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with will ask the concrete subclass for all required information on the
 environment.]]>
      </doc>
    </constructor>
    <method name="getJsonFactory" return="JsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the {@link JsonFactory} instance for this servlet.]]>
      </doc>
    </method>
    <method name="getHttpTransport" return="HttpTransport"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the {@link HttpTransport} instance for this servlet.]]>
      </doc>
    </method>
    <method name="getPersistenceManagerFactory" return="PersistenceManagerFactory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Override with your chosen method to get a PersistenceManagerFactory. For app engine
 applications this should be a singleton.

 @return PersistenceManagerFactory instance.]]>
      </doc>
    </method>
    <method name="getConcreteFlowType" return="java.lang.Class&lt;? extends com.google.api.client.extensions.auth.helpers.ThreeLeggedFlow&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Specific ThreeLeggedFlow type that this callback should retreieve and complete.]]>
      </doc>
    </method>
    <method name="getSuccessRedirectUrl" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Url to redirect the user to upon a successful credential exchange.]]>
      </doc>
    </method>
    <method name="getDeniedRedirectUrl" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Url to redirect the user to upon failure.]]>
      </doc>
    </method>
    <method name="getCompletionCodeQueryParam" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Specific query parameter keyword to key off of to get completion code. (e.g. "code" for
         OAuth2 and "verifier" for OAuth1)]]>
      </doc>
    </method>
    <method name="getUserId" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Get a string representation of a userId that can be used to associate credentials and
         flows with a specific user.]]>
      </doc>
    </method>
    <method name="newHttpTransportInstance" return="HttpTransport"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link HttpTransport} instance. Implementations can create any type of applicable
 transport and should be as simple as:

 <pre>
  new NetHttpTransport();
 </pre>

 @return {@link HttpTransport} instance for your particular environment]]>
      </doc>
    </method>
    <method name="newJsonFactoryInstance" return="JsonFactory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link JsonFactory} instance. Implementations can create any type of applicable
 json factory and should be as simple as:

 <pre>
  new JacksonFactory();
 </pre>

 @return {@link JsonFactory} instance for your particular environment]]>
      </doc>
    </method>
    <method name="doGet"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="req" type="HttpServletRequest"/>
      <param name="resp" type="HttpServletResponse"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Callback that will retrieve and complete a {@link ThreeLeggedFlow} when redirected to by a token
 server or service provider. Developer should subclass to provide the necessary information
 tailored to their specific use case.

 @author moshenko@google.com (Jacob Moshenko)
 @since 1.4]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.servlet.auth.AbstractCallbackServlet -->
  <!-- start class com.google.api.client.extensions.servlet.auth.AbstractFlowUserServlet -->
  <class name="AbstractFlowUserServlet" extends="HttpServlet"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractFlowUserServlet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="service"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="req" type="HttpServletRequest"/>
      <param name="resp" type="HttpServletResponse"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="ServletException" type="ServletException"/>
    </method>
    <method name="doGet"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="req" type="HttpServletRequest"/>
      <param name="resp" type="HttpServletResponse"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Provided for backward compatibility only. User should feel free to override this with their own
 implementation and call {@link #getCredential(HttpServletRequest)}. This bridge implementation
 will be removed in 1.6.]]>
      </doc>
    </method>
    <method name="getCredential" return="com.google.api.client.extensions.auth.helpers.Credential"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="req" type="HttpServletRequest"/>
      <doc>
      <![CDATA[Fetch a credential associated with this request.

 @param req Request object to use as context for fetching the credential.
 @return Credential object for this request and user.

 @since 1.5]]>
      </doc>
    </method>
    <method name="getJsonFactory" return="JsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the {@link JsonFactory} instance for this servlet.]]>
      </doc>
    </method>
    <method name="getHttpTransport" return="HttpTransport"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the {@link HttpTransport} instance for this servlet.]]>
      </doc>
    </method>
    <method name="getPersistenceManagerFactory" return="PersistenceManagerFactory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Obtain a PersistenceManagerFactory for working with the datastore.

 @return PersistenceManagerFactory instance.]]>
      </doc>
    </method>
    <method name="newFlow" return="com.google.api.client.extensions.auth.helpers.ThreeLeggedFlow"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="userId" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a flow object which will be used to obtain credentials.

 @param userId User id to be passed to the constructor of the flow object
 @return Flow object used to obtain credentials]]>
      </doc>
    </method>
    <method name="newHttpTransportInstance" return="HttpTransport"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link HttpTransport} instance. Implementations can create any type of applicable
 transport and should be as simple as:

 <pre>
  new NetHttpTransport();
 </pre>

 @return {@link HttpTransport} instance for your particular environment]]>
      </doc>
    </method>
    <method name="newJsonFactoryInstance" return="JsonFactory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link JsonFactory} instance. Implementations can create any type of applicable
 json factory and should be as simple as:

 <pre>
  new JacksonFactory();
 </pre>

 @return {@link JsonFactory} instance for your particular environment]]>
      </doc>
    </method>
    <method name="getUserId" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Get a string representation of a userId that can be used to associate credentials and
         flows with a specific user.]]>
      </doc>
    </method>
    <method name="doGetWithCredentials"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="Will be removed in 1.6">
      <param name="req" type="HttpServletRequest"/>
      <param name="resp" type="HttpServletResponse"/>
      <param name="credential" type="com.google.api.client.extensions.auth.helpers.Credential"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Entry point for user code.

 @param req Request object passed to the servlet when invoked.
 @param resp Response object passed to the servlet when invoked.
 @param credential Credential which can be used to build a request factory for authenticated
        calls.
 @throws IOException

 @deprecated Will be removed in 1.6]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Servlet that can be used to invoke and manage a {@link ThreeLeggedFlow} object in the App Engine
 container. Developers should subclass this to provide the necessary information for their
 specific use case.

 @author moshenko@google.com (Jacob Moshenko)
 @since 1.4]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.servlet.auth.AbstractFlowUserServlet -->
  <!-- start class com.google.api.client.extensions.servlet.auth.AbstractTwoLeggedFlowServlet -->
  <class name="AbstractTwoLeggedFlowServlet" extends="HttpServlet"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractTwoLeggedFlowServlet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an instance of the servlet.]]>
      </doc>
    </constructor>
    <method name="service"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="req" type="HttpServletRequest"/>
      <param name="resp" type="HttpServletResponse"/>
      <exception name="ServletException" type="ServletException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getCredential" return="com.google.api.client.extensions.auth.helpers.Credential"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="req" type="HttpServletRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fetch a credential associated with this request.

 @param req Request object to use as context for fetching the credential.
 @return Credential object for this request and user.]]>
      </doc>
    </method>
    <method name="newFlow" return="com.google.api.client.extensions.auth.helpers.TwoLeggedFlow"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="userId" type="java.lang.String"/>
      <doc>
      <![CDATA[Create a two legged flow that can be used to create credentials for accessing protected
 resources using OAuth.

 @param userId Identifier used to associate a flow or credential object with a specific user.
 @return Flow object that the servlet can use to create a credential object.]]>
      </doc>
    </method>
    <method name="getJsonFactory" return="JsonFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the {@link JsonFactory} instance for this servlet.]]>
      </doc>
    </method>
    <method name="getHttpTransport" return="HttpTransport"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the {@link HttpTransport} instance for this servlet.]]>
      </doc>
    </method>
    <method name="getPersistenceManagerFactory" return="PersistenceManagerFactory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Obtain a PersistenceManagerFactory for working with the datastore.

 @return PersistenceManagerFactory instance.]]>
      </doc>
    </method>
    <method name="newHttpTransportInstance" return="HttpTransport"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link HttpTransport} instance. Implementations can create any type of applicable
 transport and should be as simple as:

 <pre>
  new NetHttpTransport();
 </pre>

 @return {@link HttpTransport} instance for your particular environment]]>
      </doc>
    </method>
    <method name="newJsonFactoryInstance" return="JsonFactory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link JsonFactory} instance. Implementations can create any type of applicable
 json factory and should be as simple as:

 <pre>
  new JacksonFactory();
 </pre>

 @return {@link JsonFactory} instance for your particular environment]]>
      </doc>
    </method>
    <method name="getUserId" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Get a string representation of a userId that can be used to associate credentials and
         flows with a specific user.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This specialization of {@link HttpServlet} allows accessing OAuth resources using a credential
 that can be created without user intervention. Subclasses should call getCredential in their
 handlers when they want access to protected resources.

 @author moshenko@google.com (Jacob Moshenko)

 @since 1.5]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.extensions.servlet.auth.AbstractTwoLeggedFlowServlet -->
</package>

</api>
